<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java8 Stream</title>
    <url>/2020/05/01/Java8%20Stream/</url>
    <content><![CDATA[<h2 id="Lambda表达式基本语法"><a href="#Lambda表达式基本语法" class="headerlink" title="Lambda表达式基本语法"></a>Lambda表达式基本语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   Lambda表达式基本语法：</span></span><br><span class="line"><span class="comment"> *          parameters -&gt; expression</span></span><br><span class="line"><span class="comment"> *  一、 无参  无返回值</span></span><br><span class="line"><span class="comment"> *       () -&gt; System.out.println("Hello Lambda");</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  二、 有参  无返回值</span></span><br><span class="line"><span class="comment"> *       x -&gt; System.out.println(x);</span></span><br><span class="line"><span class="comment"> *       (x,y) -&gt; System.out.println(x +y);</span></span><br><span class="line"><span class="comment"> *  三、 有参  有返回值 Lambda体有多条语句</span></span><br><span class="line"><span class="comment"> *       (x,y) -&gt; &#123;System.out.println(x +y); return x+y;&#125;</span></span><br><span class="line"><span class="comment"> *       若Lambda体只有一条语句可省略&#123;&#125;和return</span></span><br><span class="line"><span class="comment"> *       (x,y) -&gt; x+y</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Java8 内置四大核心函数式接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Consumer&lt;T&gt;: 消费型接口</span></span><br><span class="line"><span class="comment"> *      void accept(T t);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Supplier&lt;T&gt;: 供给型接口</span></span><br><span class="line"><span class="comment"> *      T get();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Function&lt;T,R&gt;: 函数型接口</span></span><br><span class="line"><span class="comment"> *      R apply(T t);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Predicate&lt;T&gt;: 断言型接口</span></span><br><span class="line"><span class="comment"> *      boolean test(T t);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  方法引用：若Lambda体中内容有方法已经实现，可以使用方法引用</span></span><br><span class="line"><span class="comment"> *  主要有三种语法格式：</span></span><br><span class="line"><span class="comment"> *      对象::实例方法名</span></span><br><span class="line"><span class="comment"> *      类::静态方法名</span></span><br><span class="line"><span class="comment"> *      类::实例方法名</span></span><br><span class="line"><span class="comment"> *  注意：</span></span><br><span class="line"><span class="comment"> *      ①Lambda体中调用方法的参数列表和返回值类型要与函数式接口中参数列表和返回值类型保持一致</span></span><br><span class="line"><span class="comment"> *      ②若Lambda参数列表中第一参数是方法调用者，第二参数是实例方法的参数，可以使用ClassName::method</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  构造器引用： ClassName::new</span></span><br><span class="line"><span class="comment"> *      需要调用的构造器参数列表与函数式接口中抽象方法参数列表保持一致</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  数组引用：Type[]::new</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        TreeSet&lt;Integer&gt; tree =<span class="keyword">new</span> TreeSet&lt;&gt;(com);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Lambda表达式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;((x,y) -&gt; Integer.compare(x,y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream流式操作"><a href="#Stream流式操作" class="headerlink" title="Stream流式操作"></a>Stream流式操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream的三个步骤</span></span><br><span class="line"><span class="comment"> * 1、创建Stream</span></span><br><span class="line"><span class="comment"> * 2、中间操作</span></span><br><span class="line"><span class="comment"> * 3、终止操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一、创建Stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、通过Collection系列集合提供的stream()或parallelStream()</span></span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、通过Arrays中的静态方法stream()获取数组流</span></span><br><span class="line">        User[] users=<span class="keyword">new</span> User[<span class="number">10</span>];</span><br><span class="line">        Stream&lt;User&gt; stream1 = Arrays.stream(users);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、通过Stream中的静态方法of()</span></span><br><span class="line">        Stream&lt;String&gt; ss = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、创建无限流</span></span><br><span class="line">        <span class="comment">//迭代</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>,x -&gt; x+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成</span></span><br><span class="line">        Stream.generate(() -&gt; Math.random()).limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二、中间操作</span></span><br><span class="line"><span class="comment">     * 筛选与切片</span></span><br><span class="line"><span class="comment">     * filter--接收Lambda  从流中过滤某些元素</span></span><br><span class="line"><span class="comment">     * limit--截断流，使其元素不超过给定数量</span></span><br><span class="line"><span class="comment">     * skip(n)--跳过元素，返回一个跳过了前n个元素的流，若流中元素不足n个，则返回一个空流</span></span><br><span class="line"><span class="comment">     * distinct--通过流中元素的hashCode和equals去重元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * filter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        <span class="comment">//中间操作</span></span><br><span class="line">        <span class="comment">//中间操作不会执行任何操作，只有执行终止操作，中间操作才会被全部执行 “惰性求值”</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 内部迭代:迭代操作由StreamAPI完成</span></span><br><span class="line"><span class="comment">         * 这里 “Stream的中间操作” 会输出userList.size()次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;User&gt; userStream = userList.stream().filter(e -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Stream的中间操作"</span>);</span><br><span class="line">            <span class="keyword">return</span> e.getAge() &gt; <span class="number">30</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止操作  一次性执行全部内容</span></span><br><span class="line">        userStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里 “断路” 不一定会输出userList.size()次 找到两条符合条件记录就不会再遍历</span></span><br><span class="line"><span class="comment">         * 短路操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        userList.stream().filter(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"短路"</span>);</span><br><span class="line">            <span class="keyword">return</span> e.getAge() &gt; <span class="number">22</span>;</span><br><span class="line">        &#125;).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * skip</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        <span class="comment">//满足filter条件的结果集跳过两个元素后输出</span></span><br><span class="line">        userList.stream().filter(e -&gt; e.getAge() &gt; <span class="number">20</span>).skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * distinct</span></span><br><span class="line"><span class="comment">     * 注意：distinct 是通过流中元素的hashCode和equals去重元素，必要时需重写hashCode和equals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        userList.stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 映射</span></span><br><span class="line"><span class="comment">     * map--接受Lambda，将元素转换为其他形式或提取信息。</span></span><br><span class="line"><span class="comment">     *      接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射为一个新元素</span></span><br><span class="line"><span class="comment">     * flatMap--接收一个函数作为参数，将流中每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ccc"</span>, <span class="string">"ddd"</span>, <span class="string">"eee"</span>);</span><br><span class="line">        list.stream().map((str) -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamDemo::filterCharacter);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        streamStream.forEach(sm -&gt; &#123;sm.forEach(System.out::println);&#125;);*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//flatMap</span></span><br><span class="line">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamDemo::filterCharacter);</span><br><span class="line">        characterStream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">filterCharacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        List&lt;Character&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character ch:str.toCharArray())&#123;</span><br><span class="line">                list.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * sorted--自然排序（comparable）</span></span><br><span class="line"><span class="comment">     * sorted（comparator）--定制排序（Comparator）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"ccc"</span>, <span class="string">"aaa"</span>, <span class="string">"abc"</span>, <span class="string">"cbd"</span>);</span><br><span class="line">        list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        userList.stream().sorted((e1,e2) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e1.getAge()==e2.getAge())&#123;</span><br><span class="line">                <span class="keyword">return</span> e1.getName().compareTo(e2.getName());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  e1.getAge() - e2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止操作</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *查找与匹配</span></span><br><span class="line"><span class="comment">     * allMatch--检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">     * anyMatch--检查是否至少匹配一个元素</span></span><br><span class="line"><span class="comment">     * noneMatch--检查是否没有匹配所有元素</span></span><br><span class="line"><span class="comment">     * findFirst--返回第一个元素</span></span><br><span class="line"><span class="comment">     * findAny--返回当前流中任意元素</span></span><br><span class="line"><span class="comment">     * count--返回流中元素总个数</span></span><br><span class="line"><span class="comment">     * max--返回流中最大值</span></span><br><span class="line"><span class="comment">     * min--返回流中最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"001"</span>, <span class="number">38</span>, User.Status.VOCATION),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"003"</span>, <span class="number">20</span>, User.Status.BUSY),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"005"</span>, <span class="number">18</span>, User.Status.FREE),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"004"</span>, <span class="number">35</span>, User.Status.BUSY),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"002"</span>, <span class="number">27</span>, User.Status.FREE)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = users.stream().allMatch(e -&gt; e.getStatus().equals(User.Status.BUSY));</span><br><span class="line">        System.out.println(b1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b2 = users.stream().anyMatch(e -&gt; e.getStatus().equals(User.Status.BUSY));</span><br><span class="line">        System.out.println(b2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b3 = users.stream().noneMatch(e -&gt; e.getStatus().equals(User.Status.BUSY));</span><br><span class="line">        System.out.println(b3);</span><br><span class="line"></span><br><span class="line">        Optional&lt;User&gt; first = users.stream().sorted((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge()))</span><br><span class="line">                .findFirst();</span><br><span class="line">        System.out.println(first.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//parallelStream  并行</span></span><br><span class="line">        Optional&lt;User&gt; any = users.parallelStream().filter(e -&gt; e.getStatus().equals(User.Status.FREE))</span><br><span class="line">                .findAny();</span><br><span class="line">        System.out.println(any.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(users.stream().count());</span><br><span class="line"></span><br><span class="line">        Optional&lt;User&gt; max = users.stream().max((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge()));</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归约</span></span><br><span class="line"><span class="comment">     * reduce(T,BinaryOperator) / reduce(BinaryOperator)  可将流中元素反复结合起来，得到一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        Integer sum = list.stream().reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收集</span></span><br><span class="line"><span class="comment">     * collect--将流转换为其他形式，接收一个Collect接口的实现 用于给Stream中元素做汇总的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"001"</span>, <span class="number">38</span>, User.Status.VOCATION),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"003"</span>, <span class="number">20</span>, User.Status.BUSY),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"005"</span>, <span class="number">18</span>, User.Status.FREE),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"004"</span>, <span class="number">35</span>, User.Status.BUSY),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"002"</span>, <span class="number">27</span>, User.Status.FREE)</span><br><span class="line">        );</span><br><span class="line">        users.stream().map(User::getName).collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">        users.stream().map(User::getName).collect(Collectors.toSet()).forEach(System.out::println);</span><br><span class="line">        users.stream().map(User::getName).collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>)).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.parallelStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCaculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinCaculate</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> length=end -start;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;=THRESHOLD)&#123;</span><br><span class="line">            <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> middle = (start + end) /<span class="number">2</span>;</span><br><span class="line">            ForkJoinCaculate left=<span class="keyword">new</span> ForkJoinCaculate(start,middle);</span><br><span class="line">            left.fork();</span><br><span class="line"></span><br><span class="line">            ForkJoinCaculate right=<span class="keyword">new</span> ForkJoinCaculate(middle+<span class="number">1</span>,end);</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.parallelStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task=<span class="keyword">new</span> ForkJoinCaculate(<span class="number">0</span>,<span class="number">100000000000L</span>);</span><br><span class="line">        Long sum=pool.invoke(task);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"耗时（ms）："</span>+ Duration.between(start,end).toMillis());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;=<span class="number">100000000000L</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"耗时（ms）："</span>+ Duration.between(start,end).toMillis());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java8并行流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        LongStream.rangeClosed(<span class="number">0</span>,<span class="number">100000000000L</span>)</span><br><span class="line">                .parallel()</span><br><span class="line">                .reduce(<span class="number">0</span>,Long::sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(sum);</span></span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"耗时（ms）："</span>+ Duration.between(start,end).toMillis());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java8日期API"><a href="#Java8日期API" class="headerlink" title="Java8日期API"></a>Java8日期API</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSimpleDateFormat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        SimpleDateFormat dateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line">        Callable&lt;Date&gt; task=<span class="keyword">new</span> Callable&lt;Date&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Date <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> dateFormat.parse(<span class="string">"20200425"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        List&lt;Future&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(pool.submit(task));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Future&lt;Date&gt; future: results)&#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">       ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">        Callable&lt;Date&gt; task=<span class="keyword">new</span> Callable&lt;Date&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Date <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> df.get().parse(<span class="string">"20200425"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        List&lt;Future&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(pool.submit(task));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Future&lt;Date&gt; future: results)&#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        DateTimeFormatter dtf=DateTimeFormatter.ofPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line">        Callable&lt;LocalDate&gt; task=<span class="keyword">new</span> Callable&lt;LocalDate&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalDate <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> LocalDate.parse(<span class="string">"20200425"</span>,dtf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        List&lt;Future&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(pool.submit(task));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Future&lt;Date&gt; future: results)&#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime ldt =LocalDateTime.now();</span><br><span class="line">        System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">        LocalDateTime ldt2 =LocalDateTime.of(<span class="number">2020</span>,<span class="number">04</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">00</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(ldt2);</span><br><span class="line"></span><br><span class="line">        LocalDateTime ldt3 =ldt2.plusYears(<span class="number">2</span>);</span><br><span class="line">        System.out.println(ldt3);</span><br><span class="line"></span><br><span class="line">        LocalDateTime ldt4 =ldt2.minusMonths(<span class="number">2</span>);</span><br><span class="line">        System.out.println(ldt4);</span><br><span class="line"></span><br><span class="line">        System.out.println(ldt2.getYear());</span><br><span class="line">        System.out.println(ldt2.getMonthValue());</span><br><span class="line">        System.out.println(ldt2.getDayOfMonth());</span><br><span class="line">        System.out.println(ldt2.getMinute());</span><br><span class="line">        System.out.println(ldt2.getSecond());</span><br><span class="line"></span><br><span class="line">        System.out.println(LocalDateTime.parse(<span class="string">"2020-04-25T23:00:18"</span>).</span><br><span class="line">                format(DateTimeFormatter.ofPattern(<span class="string">"yyyyMMdd"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Instant in1=Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Instant in2=Instant.now();</span><br><span class="line">        Duration duration =Duration.between(in1,in2);</span><br><span class="line">        System.out.println(duration.toMillis());</span><br><span class="line"></span><br><span class="line">        LocalDate ld1=LocalDate.of(<span class="number">2018</span>,<span class="number">07</span>,<span class="number">01</span>);</span><br><span class="line">        LocalDate ld2=LocalDate.now();</span><br><span class="line"></span><br><span class="line">        Period p=Period.between(ld1,ld2);</span><br><span class="line"></span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant instant =Instant.now();</span><br><span class="line">        LocalDateTime ld=LocalDateTime.ofInstant(instant,ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">        System.out.println(ld);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Spring事务</title>
    <url>/2020/04/07/Spring%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<a id="more"></a>

<h2 style="margin-left:0cm;"> </h2>

<h2 style="margin-left:0cm;"><strong>一、数据库的事物的基本特性</strong></h2>

<div>
<p style="margin-left:0cm;">事物是区分文件存储系统与Nosql数据库重要特性之一，其存在的意义是为了保证即使在并发情况下也能正确的执行crud操作。怎样才算是正确的呢？这时提出了事物需要保证的四个特性即ACID：</p>
</div>

<ol><li>A: 原子性(atomicity)
    <ul><li><span style="color:#a5a5a5;">事物中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事物的失败；</span></li>
    </ul></li>
    <li>C: 一致性(consistency)
    <ul><li><span style="color:#a5a5a5;">事物结束后系统状态是一致的；</span></li>
    </ul></li>
    <li>I:  隔离性(isolation)
    <ul><li><span style="color:#a5a5a5;">并发执行的事物彼此无法看到对方的中间状态；</span></li>
    </ul></li>
    <li>D: 持久性(durability)
    <ul><li><span style="color:#a5a5a5;">事物完成后所做的改动都会被持久化，即使发生灾难性的失败。</span></li>
    </ul></li>
</ol><p style="margin-left:0cm;">在高并发的情况下，要完全保证其ACID特性是非常困难的，除非把所有的事物串行化执行，但带来的负面的影响将是性能大打折扣。很多时候我们有些业务对事物的要求是不一样的，所以数据库中设计了四种隔离级别，供用户基于业务进行选择。</p>

<table border="1" cellspacing="0" style="margin-left:.5pt;width:412.7pt;"><tbody><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#4f4f4f;">隔离级别</span></strong></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#4f4f4f;">脏读（Dirty Read）</span></strong></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#4f4f4f;">不可重复读（NonRepeatable Read）</span></strong></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#4f4f4f;">幻读（Phantom Read）</span></strong></p>
            </td>
        </tr><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><span style="color:#4f4f4f;">未提交读（Read uncommitted）</span></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
        </tr><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><span style="color:#4f4f4f;">已提交读（Read committed）</span></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
        </tr><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><span style="color:#4f4f4f;">可重复读（Repeatable read）</span></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
        </tr><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><span style="color:#4f4f4f;">可串行化（SERIALIZABLE）</span></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
        </tr></tbody></table><p> </p>

<p style="margin-left:0cm;"><strong>脏读 :</strong></p>

<p style="margin-left:0cm;"><span style="color:#a5a5a5;">一个事物读取到另一事物未提交的更新数据</span></p>

<p style="margin-left:0cm;"><strong>不可重复读 : </strong></p>

<p style="margin-left:0cm;"><span style="color:#a5a5a5;">在同一事物中,多次读取同一数据返回的结果有所不同, 换句话说, 后续读取可以读到另一事物已提交的更新数据. 相反, “可重复读”在同一事物中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事物已提交的更新数据。</span></p>

<p style="margin-left:0cm;"><strong>幻读 :</strong></p>

<p style="margin-left:0cm;"><span style="color:#a5a5a5;">在同一事物中,多次读取同一表数据条数返回的结果有所不同,</span></p>

<p style="margin-left:0cm;"> <span style="color:#a5a5a5;">查询表中一条数据如果不存在就插入一条，并发的时候却发现，里面居然有两条相同的数据。这就幻读的问题。</span></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>数据库默认隔离级别：</strong></p>

<p style="margin-left:0cm;">Oracle中默认级别是 Read committed</p>

<p style="margin-left:0cm;">mysql 中默认级别 Repeatable read。另外要注意的是mysql 执行一条查询语句默认是一个独立的事物，所以看上去效果跟Read committed一样。</p>

<p style="margin-left:0cm;"># 查看mysql 的默认隔离级别</p>

<p style="margin-left:0cm;">SELECT @@tx_isolation</p>

<p style="margin-left:0cm;"> </p>

<div>
<h2 style="margin-left:0cm;"><strong>二、Sring 对事物的支持与使用</strong></h2>

<p style="margin-left:0cm;"><strong>1、spring 事物相关API说明</strong></p>

<p style="margin-left:0cm;">spring 事物是在数据库事物的基础上进行封装扩展 其主要特性如下：</p>

<ol><li>
    <ol><li>支持原有的数据事物的隔离级别</li>
        <li>加入了事物传播的概念 提供多个事物的和并或隔离的功能</li>
        <li>提供声明式事物，让业务代码与事物分离，事物变得更易用。</li>
    </ol></li>
</ol><p style="margin-left:0cm;">怎么样去使用Spring事物呢？spring 提供了三个接口供使用事物。分别是：</p>

<p style="margin-left:0cm;"> </p>

<ol><li>TransactionDefinition
    <ul><li><span style="color:#a5a5a5;">事物定义</span></li>
    </ul></li>
    <li>PlatformTransactionManager
    <ul><li><span style="color:#a5a5a5;">事物管理</span></li>
    </ul></li>
    <li>TransactionStatus
    <ul><li><span style="color:#a5a5a5;">事物运行时状态</span></li>
    </ul></li>
</ol><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>接口结构图：</strong></p>

<p style="margin-left:0cm;"><img alt height="241" src="https://img-blog.csdnimg.cn/2020040722121591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQ0Njk1,size_16,color_FFFFFF,t_70" width="547"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>API说明：</strong></p>

<pre>
<code class="language-java">public class SpringTransactionExample {
    private static String url = "jdbc:mysql://192.168.0.147:3306/test";
    private static String user = "root";
    private static String password = "123456";

    public static Connection openConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://192.168.0.147:3306/test", "root", "123456");
        return conn;
    }

    public static void main(String[] args) {
        final DataSource ds = new DriverManagerDataSource(url, user, password);
        final TransactionTemplate template = new TransactionTemplate();
        template.setTransactionManager(new DataSourceTransactionManager(ds));
        template.execute(new TransactionCallback&lt;Object&gt;() {
            @Override
            public Object doInTransaction(TransactionStatus status) {
                Connection conn = DataSourceUtils.getConnection(ds);
                Object savePoint = null;
                try {
                    {
                        // 插入
                        PreparedStatement prepare = conn.
                                prepareStatement("insert INTO account (accountName,user,money) VALUES (?,?,?)");
                        prepare.setString(1, "111");
                        prepare.setString(2, "aaaa");
                        prepare.setInt(3, 10000);
                        prepare.executeUpdate();
                    }
                    // 设置保存点
                    savePoint = status.createSavepoint();
                    {
                        // 插入
                        PreparedStatement prepare = conn.
                                prepareStatement("insert INTO account (accountName,user,money) VALUES (?,?,?)");
                        prepare.setString(1, "222");
                        prepare.setString(2, "bbb");
                        prepare.setInt(3, 10000);
                        prepare.executeUpdate();
                    }
                    {
                        // 更新
                        PreparedStatement prepare = conn.
                                prepareStatement("UPDATE account SET money= money+1 where user=?");
                        prepare.setString(1, "asdflkjaf");
                        Assert.isTrue(prepare.executeUpdate() &gt; 0, "");
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                } catch (Exception e) {
                    System.out.println("更新失败");
                    if (savePoint != null) {
                        status.rollbackToSavepoint(savePoint);
                    } else {
                        status.setRollbackOnly();
                    }
                }
                return null;
            }
        });
    }
}
</code></pre>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>2、声明示事物</strong></p>

<p style="margin-left:0cm;">我们前面是通过调用API来实现对事物的控制，这非常的繁琐，与直接操作JDBC事物并没有太多的改善，所以Spring提出了声明示事物，使我们对事物的操作变得非常简单，甚至不需要关心它。</p>

<p style="margin-left:0cm;">配置spring.xml</p>

<pre>
<code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;context:annotation-config/&gt;
    &lt;context:component-scan base-package="com.test.service.**"&gt;
    &lt;/context:component-scan&gt;

    &lt;bean class="org.springframework.jdbc.core.JdbcTemplate"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;!-- similarly, don't forget the PlatformTransactionManager --&gt;
    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;
    &lt;!-- don't forget the DataSource --&gt;
    &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;constructor-arg name="url" value="jdbc:mysql://192.168.0.147/test"/&gt;
        &lt;constructor-arg name="username" value="root"/&gt;
        &lt;constructor-arg name="password" value="123456"/&gt;
    &lt;/bean&gt;
    &lt;tx:annotation-driven transaction-manager="txManager"&gt;&lt;/tx:annotation-driven&gt;
&lt;/beans&gt;
</code></pre>

<p style="margin-left:0cm;">编写服务类</p>

<pre>
<code class="language-java">@Transactional
public void addAccount(String name, int initMenoy) {
    String accountid = new SimpleDateFormat("yyyyMMddhhmmss").format(new Date());
    jdbcTemplate.update("insert INTO account (accountName,user,money) VALUES (?,?,?)", accountid, name, initMenoy);
    // 人为报错
    int i = 1 / 0;
}
</code></pre>

<p style="margin-left:0cm;"><strong>3、事物传播机制</strong></p>

<p style="margin-left:0cm;"> </p>

<table border="1" cellspacing="0" style="margin-left:.5pt;width:412.7pt;"><tbody><tr><td style="width:75pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">类别</span></strong></p>
            </td>
            <td style="width:173.5pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">事物传播类型</span></strong></p>
            </td>
            <td style="width:164.15pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">说明</span></strong></p>
            </td>
        </tr><tr><td rowspan="3" style="width:75pt;">
            <p style="margin-left:0cm;">支持当前事物</p>
            </td>
            <td style="width:173.5pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">PROPAGATION_REQUIRED</span></p>

<pre><code>    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（必须的）&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;如果当前没有事物，就新建一个事物，如果已经存在一个事物中，加入到这个事物中。这是最常见的选择。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_SUPPORTS&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（支持）&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;支持当前事物，如果当前没有事物，就以非事物方式执行。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_MANDATORY&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（强制）&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;使用当前的事物，如果当前没有事物，就抛出异常。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;3&quot; style=&quot;width:75pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;不支持当前事物&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_REQUIRES_NEW&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;隔离)&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;新建事物，如果当前存在事物，把当前事物挂起。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_NOT_SUPPORTED&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;不支持)&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;以非事物方式执行操作，如果当前存在事物，就把当前事物挂起。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_NEVER&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;(强制非事物)&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;以非事物方式执行，如果当前存在事物，则抛出异常。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:75pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;套事物&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_NESTED&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（嵌套事物）&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;如果当前存在事物，则在嵌套事物内执行。如果当前没有事物，则执行与PROPAGATION_REQUIRED类似的操作。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;strong&gt;常用事物传播机制：&lt;/strong&gt;&lt;/p&gt;</code></pre><ol><li>PROPAGATION_REQUIRED，
    <ul><li><span style="color:#a5a5a5;">这个也是默认的传播机制；</span></li>
    </ul></li>
    <li>PROPAGATION_NOT_SUPPORTED
    <ul><li><span style="color:#a5a5a5;">可以用于发送提示消息，站内信、短信、邮件提示等。不属于并且不应当影响主体业务逻辑，即使发送失败也不应该对主体业务逻辑回滚。</span></li>
    </ul></li>
    <li>PROPAGATION_REQUIRES_NEW
    <ul><li><span style="color:#a5a5a5;">总是新启一个事物，这个传播机制适用于不受父方法事物影响的操作，比如某些业务场景下需要记录业务日志，用于异步反查，那么不管主体业务逻辑是否完成，日志都需要记录下来，不能因为主体业务逻辑报错而丢失日志；</span></li>
    </ul></li>
</ol><p style="margin-left:0cm;"><strong>用例1:</strong></p>

<p style="margin-left:0cm;">创建用户时初始化一个帐户，表结构和服务类如下。</p>

<table border="1" cellspacing="0" style="margin-left:.5pt;width:387.9pt;"><tbody><tr><td style="width:103.15pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">表结构</span></strong></p>
            </td>
            <td style="width:103.15pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">服务类</span></strong></p>
            </td>
            <td style="width:181.55pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">功能描述</span></strong></p>
            </td>
        </tr><tr><td style="vertical-align:top;width:103.15pt;">
            <p style="margin-left:0cm;">user</p>
            </td>
            <td style="vertical-align:top;width:103.15pt;">
            <p style="margin-left:0cm;">UserSerivce</p>
            </td>
            <td style="vertical-align:top;width:181.55pt;">
            <p style="margin-left:0cm;">创建用户，并添加帐户</p>
            </td>
        </tr><tr><td style="vertical-align:top;width:103.15pt;">
            <p style="margin-left:0cm;">account</p>
            </td>
            <td style="vertical-align:top;width:103.15pt;">
            <p style="margin-left:0cm;">AccountService</p>
            </td>
            <td style="vertical-align:top;width:181.55pt;">
            <p style="margin-left:0cm;">添加帐户</p>
            </td>
        </tr></tbody></table><p style="margin-left:0cm;">UserSerivce.createUser(name) 实现代码</p>

<pre>
<code class="language-java">@Transactional
public void createUser(String name) {
    // 新增用户基本信息
    jdbcTemplate.update("INSERT INTO `user` (name) VALUES(?)", name);
    //调用accountService添加帐户
    accountService.addAccount(name, 10000);
 ｝

AccountService.addAccount(name,initMoney) 实现代码（方法的最后有一个异常）
@Transactional(propagation = Propagation.REQUIRED)
public void addAccount(String name, int initMoney) {
    String accountid = new SimpleDateFormat("yyyyMMddhhmmss").format(new Date());
    jdbcTemplate.update("insert INTO account (accountName,user,money) VALUES (?,?,?)", accountid, name, initMenoy);
    // 出现分母为零的异常
    int i = 1 / 0;
}
</code></pre>

<p style="margin-left:0cm;">实验预测一：</p>

<table border="1" cellspacing="0" style="margin-left:.5pt;width:412.7pt;"><tbody><tr><td style="vertical-align:top;width:54.9pt;">
            <p style="margin-left:0cm;"> </p>
            </td>
            <td style="width:120.6pt;">
            <p style="margin-left:0cm;">createUser</p>
            </td>
            <td style="width:113.9pt;">
            <p style="margin-left:0cm;">addAccount<span style="color:#ff0000;">(</span><span style="color:#ff0000;">异常)</span></p>
            </td>
            <td style="width:123.25pt;">
            <p style="margin-left:0cm;">预测结果</p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景一</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">无事物</p>
            </td>
            <td style="vertical-align:top;width:113.9pt;">
            <p style="margin-left:0cm;">required</p>
            </td>
            <td style="vertical-align:top;width:123.25pt;">
            <p style="margin-left:0cm;">user （成功） Account（不成功） <span style="color:#1c7231;">正确</span></p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景二</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">required</p>
            </td>
            <td style="vertical-align:top;width:113.9pt;">
            <p style="margin-left:0cm;">无事物</p>
            </td>
            <td style="vertical-align:top;width:123.25pt;">
            <p style="margin-left:0cm;">user （不成功） Account（不成功） <span style="color:#1c7231;">正确</span></p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景三</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">required</p>
            </td>
            <td style="vertical-align:top;width:113.9pt;">
            <p style="margin-left:0cm;">not_supported</p>
            </td>
            <td style="vertical-align:top;width:123.25pt;">
            <p style="margin-left:0cm;">user （不成功） Account（成功）<span style="color:#1c7231;">正确</span></p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景四</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">required</p>
            </td>
            <td style="vertical-align:top;width:113.9pt;">
            <p style="margin-left:0cm;">required_new</p>
            </td>
            <td style="vertical-align:top;width:123.25pt;">
            <p style="margin-left:0cm;">user （不成功） Account（不成功）<span style="color:#1c7231;">正确</span></p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景五</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">required</p>

<pre><code>    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;异常移至createUser方法未尾)&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt; &lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:113.9pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;required_new&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:123.25pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;user （不成功） Account（成功）&lt;span style=&quot;color:#1c7231;&quot;&gt;正确&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:54.9pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;场景六&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:120.6pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;required&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;异常移至createUser方法未尾)&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;addAccount &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;方法称至当前类&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;）&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt; &lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:113.9pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;required_new&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:123.25pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;user （不成功） Account（不成功）&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p style=&quot;margin-left:0cm;&quot;&gt; &lt;/p&gt;</code></pre><div>
<h2 style="margin-left:0cm;"><strong>三、aop 事物底层实现原理</strong></h2>
</div>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">讲事物原理之前我们先来做一个实验，当场景五的环境改变，把addAccount 方法移至UserService 类下，其它配置和代码不变：</p>

<pre>
<code class="language-java">@Override
@Transactional
public void createUser(String name) {
    jdbcTemplate.update("INSERT INTO `user` (name) VALUES(?)", name);
    addAccount(name, 10000);
    // 人为报错
    int i = 1 / 0;
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void addAccount(String name, int initMoney) {
    String accountid = new SimpleDateFormat("yyyyMMddhhmmss").format(new Date());
    jdbcTemplate.update("insert INTO account (accountName,user,money) VALUES (?,?,?)", accountid, name, initMoney);
}
</code></pre>

<p style="margin-left:0cm;">经过演示我们发现得出的结果与场景五并不 一至，required_new 没有起到其对应的作用。原因在于spring 声明示事物使用动态代理实现，而当调用同一个类的方法时，是会不会走代理逻辑的，自然事物的配置也会失效。</p>

<p style="margin-left:0cm;">通过一个动态代理的实现来模拟这种场景</p>

<pre>
<code class="language-java">UserSerivce proxyUserSerivce = (UserSerivce) Proxy.newProxyInstance(TestTransaction.class.getClassLoader(),
        new Class[]{UserSerivce.class}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                try {
                    System.out.println("开启事物:"+method.getName());
                    return method.invoke(userSerivce, args);
                } finally {
                    System.out.println("关闭事物:"+method.getName());
                }
            }
        });
proxyUserSerivce.createUser("test");
</code></pre>

<p style="margin-left:0cm;">当我们调用createUser 方法时 仅打印了 createUser  的事物开启、关闭，并没有打印addAccount 方法的事物开启、关闭，由此可见addAccount  的事物配置是失效的。</p>

<p style="margin-left:0cm;">如果业务当中上真有这种场景该如何实现呢？在spring xml中配置 暴露proxy 对象，然后在代码中用AopContext.currentProxy() 就可以获当前代理对象</p>

<p style="margin-left:0cm;">&lt;!-- 配置暴露proxy --&gt;</p>

<p style="margin-left:0cm;">&lt;aop:aspectj-autoproxy expose-proxy="true"/&gt;</p>

<p style="margin-left:0cm;">// 基于代理对象调用创建帐户，事物的配置又生效了</p>

<p style="margin-left:0cm;">((UserSerivce) AopContext.currentProxy()).addAccount(name, 10000);</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>
</td></tr></tbody></table></td></tr></tbody></table></div>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello</title>
    <url>/2020/03/20/Hello/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Git基本概念和底层原理</title>
    <url>/2020/03/20/Git%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="GIT和SVN的主要区别"><a href="#GIT和SVN的主要区别" class="headerlink" title="GIT和SVN的主要区别"></a>GIT和SVN的主要区别</h1><ol>
<li>存储方式不一样</li>
<li>使用方式不一样</li>
<li>管理模式不一样</li>
</ol>
<p><strong>1、存储方式区别</strong><br>   GIT把内容按元数据方式存储类似k/v数据库，而SVN是按文件(新版svn已改成元数据存储)<br>       演示git 存储过程演示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .git/objects/df/</span><br><span class="line">git cat-file -p df70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'version1'</span> &gt; text.txt</span><br><span class="line">git <span class="built_in">hash</span>-object -w text.txt</span><br></pre></td></tr></table></figure>

<p><strong>2、使用方式区别</strong><br>    从本地把文件推送远程服务，SVN只需要commint 而GIT需要 add、commint、push 三个步骤<br>SVN基本使用过程<br><img src="https://img-blog.csdnimg.cn/20200207220323296.png" alt="在这里插入图片描述"><br>Git基本使用过程<br><img src="https://img-blog.csdnimg.cn/2020020722041424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQ0Njk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3、版本管理模式区别</strong><br>git 是一个分布式的版本管理系统，而要SVN是一个远程集中式的管理系统</p>
<p>集中式<br><img src="https://img-blog.csdnimg.cn/202002072204584.png" alt="在这里插入图片描述"><br>分布式<br><img src="https://img-blog.csdnimg.cn/202002072205124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQ0Njk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="二、GIT-核心命令使用"><a href="#二、GIT-核心命令使用" class="headerlink" title="二、GIT 核心命令使用"></a>二、GIT 核心命令使用</h1><p>主要内容:</p>
<ol>
<li>git 客户端安装配置</li>
<li>整体认识GIT的基本使用</li>
<li>分支管理</li>
<li>标签管理</li>
<li>远程仓库配置</li>
</ol>
<p><strong>1、安装git 客户端安装</strong><br>官方客户端： httpsd://git-scm.com/downloads<br>其它客户端：<a href="https://tortoisegit.org/download/" target="_blank" rel="external nofollow noopener noreferrer">https://tortoisegit.org/download/</a></p>
<p><strong>2、认识GIT的基本使用</strong></p>
<ol>
<li>git 项目创建与克隆</li>
<li>文件提交与推送<br>完整模拟从项目添加到push 过程<ul>
<li>创建项目 </li>
<li>初始化git仓库</li>
<li>提交文件 </li>
<li>远程关联 </li>
<li>push 至远程仓库</li>
</ul>
</li>
</ol>
<p><strong>本地初始化GIT 仓库:</strong><br>#基于远程仓库克隆至本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;remote_url&gt;</span><br></pre></td></tr></table></figure>
<p>#当前目录初始化为git 本地仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init  &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>基于mvn 模板创建项目<br>mvn archetype:generate</p>
<p>本地添加<br>#添加指定文件至暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;fileName&gt;</span><br></pre></td></tr></table></figure>
<p>#添加指定目录至暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>#添加所有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure>
<p>#将指定目录及子目录移除出暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;target&gt; -r</span><br></pre></td></tr></table></figure>
<p>#将该文件从commit后撤回到add后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm &lt;target&gt;</span><br></pre></td></tr></table></figure>
<p>#添加忽略配置文件 .gitignore</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以'#'开始的行，被视为注释.                                                                                                                          </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略掉所有文件名是 foo.txt的文件.</span></span><br><span class="line"></span><br><span class="line">foo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有生成的 html文件,</span></span><br><span class="line"></span><br><span class="line">*.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># foo.html是手工维护的，所以例外.</span></span><br><span class="line"></span><br><span class="line">!foo.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有.o和 .a文件.</span></span><br><span class="line"></span><br><span class="line">*.[oa]</span><br><span class="line">配置语法：</span><br><span class="line">以斜杠“/”开头表示目录；</span><br><span class="line">以星号“*”通配多个字符；</span><br><span class="line">以问号“?”通配单个字符</span><br><span class="line">以方括号“[]”包含单个字符的匹配列表；</span><br><span class="line">以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</span><br></pre></td></tr></table></figure>
<p>本地提交<br>#提交至本地仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit &lt;file&gt; -m <span class="string">'提交评论'</span></span><br></pre></td></tr></table></figure>
<p>#快捷提交至本地仓库 <em>新增文件不能直接用此命令</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -am <span class="string">'快添加与提交'</span></span><br></pre></td></tr></table></figure>
<p>#查看修改历史</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git blame 文件名 // 查看该文件的修改历史</span><br><span class="line">git blame -L 100,10 文件名 // 从100行开始，到110行 逐行查看文件的修改历史</span><br></pre></td></tr></table></figure>
<p>#对比工作区，暂存区，仓库的差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff // 查看变更 工作区与暂存区的差异比对</span><br><span class="line">git diff --cached // 暂存区与提交版本的差异</span><br><span class="line">git diff HEAD // 工作区与仓库中最后一次提交版本的差别</span><br><span class="line">git diff 版本哈希值 版本哈希值 // 查看这2个版本哈希之间的区别</span><br><span class="line">或者 git diff HEAD~数字 HEAD~数字</span><br><span class="line">git tag tt HEAD~4 给倒数第5次提交打一个tag tag名字是tt</span><br><span class="line">git diff tt 就是倒数第5个版本与第一个版本之间的差异</span><br><span class="line">git diff --cached tt 暂存区与倒数第5个版本之间的比对</span><br></pre></td></tr></table></figure>
<p>#回撤操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend -m <span class="string">"提交信息"</span> // 回撤上一次提交并与本次工作区一起提交</span><br><span class="line">git reset HEAD~2 --hard // 回撤2步</span><br><span class="line">git reset --files // 从仓库回撤到暂存区</span><br><span class="line">git reset HEAD // 回撤暂存区内容到工作目录</span><br><span class="line">git reset HEAD --soft 回撤提交到暂存区</span><br><span class="line">git reset HEAD --hard // 回撤提交 放弃变更 (慎用)</span><br><span class="line">git reset HEAD^  // 回撤仓库最后一次提交</span><br><span class="line">git reset --hard commitid // 回撤到该次提交id的位置</span><br><span class="line"></span><br><span class="line">git push -f -u origin 分支名 所有内容都回撤完了 将回撤后的操作强制推送到远程分支</span><br></pre></td></tr></table></figure>
<p>#标签操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag // 查看列出所有打过的标签名</span><br><span class="line">git tag -d 标签名 // 删除对应标签</span><br><span class="line">git tag 标签名字 // 在当前仓库打个标签</span><br><span class="line">git tag foo -m <span class="string">"message"</span> // 在当前提交上，打标签foo 并给message信息注释</span><br><span class="line">git tag 标签名 哈希值 -m <span class="string">"message"</span> // 在某个哈希值上打标签并且写上标签的信息</span><br><span class="line">git tag foo HEAD~4 // 在当前提交之前的第4个版本上 打标签foo</span><br><span class="line">git push origin --tags // 把所有打好的标签推送到远程仓库</span><br><span class="line">git push origin 标签名 // 把指定标签推送到远程仓库</span><br><span class="line">git stash // 把暂存区的内容 暂时放在其他中 使暂存区变空</span><br><span class="line">git stash list // 查看stash了哪些存储</span><br><span class="line">git stash pop // 将stash中的内容恢复到当前目录，将缓存堆栈中的对应stash删除</span><br><span class="line">git stash apply // 将stash中的内容恢复到当前目录，不会将缓存堆栈中的对应stash删除</span><br><span class="line">git stash clear // 删除所有缓存的stash</span><br><span class="line">git pull --tags // 把远程仓库的标签也拉取下来</span><br><span class="line">git push origin :refs/tags/远程标签名 // 删除远程仓库的标签</span><br></pre></td></tr></table></figure>
<p>#日志管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %ad | %s%d [%an]'</span> --graph --date=short</span><br><span class="line">// 获取git <span class="built_in">log</span>里的树形详细信息 包括hasg 日期 提交信息 提交人等</span><br><span class="line">git <span class="built_in">log</span> --oneline //拉出所有提交信息 q是退出</span><br><span class="line">git <span class="built_in">log</span> -5 // 查看前5次的提交记录</span><br><span class="line">git <span class="built_in">log</span> --oneline -5 // 打印出的日志里面只有哈希值和修改的内容备注</span><br><span class="line">git <span class="built_in">log</span> 文件名 // 查看该文件的提交</span><br><span class="line">git <span class="built_in">log</span> --grep // 想过滤看到的内容   过滤日志</span><br><span class="line">git <span class="built_in">log</span> -n // 查看近期提交的n条信息内容</span><br><span class="line">git <span class="built_in">log</span> -p // 查看详细提交记录</span><br><span class="line">git <span class="built_in">log</span> master..experiment  //比较两个版本的区别</span><br></pre></td></tr></table></figure>

<p><strong>3、分支管理</strong><br>#查看当前分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch [-avv]</span><br></pre></td></tr></table></figure>
<p>#基于当前分支新建分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch  &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<p>#基于提交新建分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch &lt;branch name&gt; &lt;commit id&gt;</span><br></pre></td></tr></table></figure>
<p>#把远程分支拉到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin dev（dev为远程仓库的分支名）</span><br></pre></td></tr></table></figure>

<p>#删除分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<p>#切换分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<p>#合并分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge &lt;merge target&gt;</span><br></pre></td></tr></table></figure>
<p>#解决冲突，如果因冲突导致自动合并失败，此时 status 为mergeing 状态.<br>#需要手动修改后重新提交（commit） </p>
<p><strong>4、远程仓库管理</strong><br>#查看远程配置 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote [-v]</span><br></pre></td></tr></table></figure>
<p>#添加远程地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin http:xxx.xxx</span><br></pre></td></tr></table></figure>
<p>#删除远程地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>
<p>#上传新分支至远程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin master</span><br></pre></td></tr></table></figure>
<p>#将本地分支与远程建立关联</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --track --<span class="built_in">set</span>-upstream-to=origin/<span class="built_in">test</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h1 id="三、git-底层原理"><a href="#三、git-底层原理" class="headerlink" title="三、git 底层原理"></a>三、git 底层原理</h1><ul>
<li>GIT存储对像</li>
<li>GIT树对像</li>
<li>GIT提交对像</li>
<li>GIT引用</li>
</ul>
<p><strong>1、GIT存储对像(hashMap)</strong><br>Git 是一个内容寻址文件系统，其核心部分是一个简单的键值对数据库（key-value data store），你可以向数据库中插入任意内容，它会返回一个用于取回该值的hash 键。</p>
<p>#git 键值库中插入数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'luban is good man'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">79362d07cf264f8078b489a47132afbc73f87b9a</span><br></pre></td></tr></table></figure>

<p>#基于键获取指定内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cat-file -p 79362d07cf264f8078b489a47132afbc73f87b9a</span><br></pre></td></tr></table></figure>

<p>Git基于该功能 把每个文件的版本中内容都保存在数据库中，当要进行版本回滚的时候就通过其中一个键将期取回并替换。</p>
<p>    模拟演示git 版写入与回滚过程<br>#查找所有的git 对像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find .git/objects/ -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>

<p>#写入版本1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'version1'</span> &gt; README.MF; git <span class="built_in">hash</span>-object -w README.MF;</span><br></pre></td></tr></table></figure>

<p>#写入版本2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'version2'</span> &gt; README.MF; git <span class="built_in">hash</span>-object -w README.MF;</span><br></pre></td></tr></table></figure>

<p>#写入版本3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'version3'</span> &gt; README.MF; git <span class="built_in">hash</span>-object -w README.MF;</span><br></pre></td></tr></table></figure>

<p>#回滚指定版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cat-file -p c11e96db44f7f3bc4c608aa7d7cd9ba4ab25066e &gt; </span><br><span class="line">README.MF</span><br></pre></td></tr></table></figure>

<p>所以我们平常用的 git add 其实就是把修改之后的内容 插入到键值库中。当我们执行 git add README.MF 等同于执行了 git hash-object -w README.MF 把文件写到数据库中。</p>
<p>我们解决了存储的问题，但其只能存储内容同并没有存储文件名，如果要进行回滚 怎么知道哪个内容对应哪个文件呢？接下要讲的就是树对象，它解决了文件名存储的问题 。</p>
<p><strong>2、GIT树对像</strong><br>树对像解决了文件名的问题，它的目的将多个文件名组织在一起，其内包含多个文件名称与其对应的Key和其它树对像的用引用，可以理解成操作系统当中的文件夹，一个文件夹包含多个文件和多个其它文件夹。<br><img src="https://img-blog.csdnimg.cn/20200208155735977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQ0Njk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每一个分支当中都关联了一个树对像，他存储了当前分支下所有的文件名及对应的 key.<br>通过以下命令即可查看<br>#查看分支树</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cat-file -p master^&#123;tree&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、git提交对象</strong><br>一次提交即为当前版本的一个快照，该快照就是通过提交对像保存，其存储的内容为：一个顶级树对象、上一次提交的对像啥希、提交者用户名及邮箱、提交时间戳、提交评论。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p b2395925b5f1c12bf8cb9602f05fc8d580311836</span><br><span class="line">tree 002adb8152f7cd49f400a0480ef2d4c09b060c07</span><br><span class="line">parent 8be903f5e1046b851117a21cdc3c80bdcaf97570</span><br><span class="line">author tommy &lt;tommy@tuling.com&gt; 1532959457 +0800</span><br><span class="line">committer tommy &lt;tommy@tuling.com&gt; 1532959457 +0800</span><br></pre></td></tr></table></figure>

<p>通过上面的知识，我们可以推测出从修改一个文件到提交的过程总共生成了三个对像：<br>一个内容对象 ==&gt; 存储了文件内容<br>一个树对像 ==&gt; 存储了文件名及内容对像的key<br>一个提交对像 ==&gt; 存储了树对像的key 及提交评论。 </p>
<p><strong>4、GIT引用</strong><br>当我们执行 git branch {branchName} 时创建了一个分支，其本质就是在git 基于指定提交创建了一个引用文件，保存在 .git\refs\heads\ 下。</p>
<p>    演示分支的创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch dev </span><br><span class="line">cat.git\refs\heads\dev</span><br></pre></td></tr></table></figure>

<p>git 总共 有三种类型的引用：</p>
<ol>
<li>分支引用</li>
<li>远程分支引用</li>
<li>标签引用</li>
</ol>
<p>#查询比较两个版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> master..experiment</span><br></pre></td></tr></table></figure>

<p>#版本提交历史网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %s'</span> --graph</span><br></pre></td></tr></table></figure>

<p>#查看分支树</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cat-file -p master^&#123;tree&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>java动态代理详解</title>
    <url>/2020/03/01/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<a id="more"></a>

<p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:80px;"> </p>

<p id="1.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:80px;"><a href="#1.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.基于JDK的动态代理</a></p>

<p id="2.%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:80px;"><a href="#2.%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">2.基于CGLIB的动态代理</a></p>

<hr id="hr-toc"><p id="%E7%9B%AE%E5%89%8Djava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E4%B8%BA%E4%B8%A4%E7%A7%8D">目前java动态代理的实现分为两种</p>

<p><strong>1.基于JDK的动态代理</strong></p>

<p><strong>2.基于CGILB的动态代理</strong></p>

<p>在业务中使用动态代理，一般是为了给需要实现的方法添加预处理或者添加后续操作，但是不干预实现类的正常业务，把一些基本业务和主要的业务逻辑分离。我们一般所熟知的Spring的AOP原理就是基于动态代理实现的。</p>

<h3 id="1.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><strong>1.基于JDK的动态代理</strong></h3>

<p>基于JDK的动态代理就需要知道两个类：1.InvocationHandler（接口）、2.Proxy（类）</p>

<p>还要知道JDK是基于接口的动态代理</p>

<p>下面我们实际用代码来讲解这两个类的实际作用</p>

<p>1.第一步，创建一个接口</p>

<p>public interface Subject {<br>
    void hello(String param);<br>
}<br>
2.第二步，实现接口</p>

<p>public class SubjectImpl implements Subject {<br>
    @Override<br>
    public void hello(String param) {<br>
        System.out.println("hello  " + param);<br>
    }<br>
}<br>
3.第三步，创建SubjectImpl的代理类</p>

<p>public class SubjectProxy implements InvocationHandler {<br>
    private Subject subject;</p>

<p>    public SubjectProxy(Subject subject) {<br>
        this.subject = subject;<br>
    }</p>

<p>    @Override<br>
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>
        System.out.println("--------------begin-------------");<br>
        Object invoke = method.invoke(subject, args);<br>
        System.out.println("--------------end-------------");<br>
        return invoke;<br>
    }<br>
}<br>
invoke方法的说明：</p>

<p><img alt src="https://img-blog.csdn.net/20180821150523827?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNTMyMzIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>4.编写代理类实际的调用，利用Proxy类创建代理之后的Subject类。</p>

<p>public class Main {</p>

<p>    public static void main(String[] args) {<br>
        Subject subject = new SubjectImpl();<br>
        InvocationHandler subjectProxy = new SubjectProxy(subject);<br>
        Subject proxyInstance = (Subject) Proxy.newProxyInstance(subjectProxy.getClass().getClassLoader(), subject.getClass().getInterfaces(), subjectProxy);<br>
        proxyInstance.hello("world");<br>
    }</p>

<p>}</p>

<p><img alt src="https://img-blog.csdn.net/20180821150918418?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNTMyMzIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br>
输出：</p>

<p>--------------begin-------------<br>
hello  world<br>
--------------end-------------</p>

<p>看这个结果，实际上在Subject类中只会输出一条hello world，但是在被代理之后，实际调用的方法是SubjectProxy的invoke方法，这样可以在不修改业务类的情况下对业务类增加一些日志等其他操作，甚至可以直接修改有返回值方法的返回值。</p>

<h3 id="2.%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><strong>2.基于CGLIB的动态代理</strong></h3>

<p>本文主要讲的是CGLIB的动态代理，因为基于JDK的动态代理一定要继承一个接口，而绝大部分情况是基于POJO类的动态代理，那么CGLIB就是一个很好的选择，在Hibernate框架中PO的字节码生产工作就是靠CGLIB来完成的。还是先看代码。</p>

<p>1.引入CGLIB的jar包</p>

<p>2.创建代理类</p>

<p>public class CGsubject {<br>
    public void sayHello(){<br>
        System.out.println("hello world");<br>
    }<br>
}<br>
如果直接对这个类创建对象，那么调用sayHello方法，控制台就会输出hello world，现在我们还是要对输出添加前置和后置的log输出。来打印输出前和输出后的时间。</p>

<p>3.实现MethodInterceptor接口，对方法进行拦截处理。</p>

<p>public class HelloInterceptor implements MethodInterceptor{<br>
    @Override<br>
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {<br>
        System.out.println("begin time -----&gt; "+ System.currentTimeMillis());<br>
        Object o1 = methodProxy.invokeSuper(o, objects);<br>
        System.out.println("end time -----&gt; "+ System.currentTimeMillis());<br>
        return o1;<br>
    }<br>
}</p>

<p><img alt src="https://img-blog.csdn.net/201808211529299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNTMyMzIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br>
4.创建被代理类</p>

<p>public class Main {</p>

<p>    public static void main(String[] args) {<br>
        Enhancer enhancer = new Enhancer();<br>
        enhancer.setSuperclass(CGsubject.class);<br>
        enhancer.setCallback(new HelloInterceptor());<br>
        CGsubject cGsubject = (CGsubject) enhancer.create();<br>
        cGsubject.sayHello();<br>
    }</p>

<p>}<br>
利用Enhancer来生产被代理类，这样可以拦截方法，对方法进行前置和后置log的添加。</p>

<p>输出：</p>

<p>begin time -----&gt; 1534836443741<br>
hello world<br>
end time -----&gt; 1534836443786<br>
 </p>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis源码解析(二)——动态代理实现函数调用</title>
    <url>/2020/03/01/MyBatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<a id="more"></a>

<p>如果我们要使用MyBatis进行数据库操作的话，大致要做两件事情：</p>

<ol><li>定义DAO接口<br>
    在DAO接口中定义需要进行的数据库操作。</li>
    <li>创建映射文件<br>
    当有了DAO接口后，还需要为该接口创建映射文件。映射文件中定义了一系列SQL语句，这些SQL语句和DAO接口一一对应。</li>
</ol><p>MyBatis在初始化的时候会将映射文件与DAO接口一一对应，并根据映射文件的内容为每个函数创建相应的数据库操作能力。而我们作为MyBatis使用者，只需将DAO接口注入给Service层使用即可。<br>
那么MyBatis是如何根据映射文件为每个DAO接口创建具体实现的？答案是——动态代理。<br>
下面进入正题。</p>

<hr><p>首先来回顾一项MyBatis在初始化过程中所做的事情。<br>
MyBatis在初始化过程中，首先会读取我们的配置文件流程，并使用<code>XMLConfigBuilder</code>来解析配置文件。<code>XMLConfigBuilder</code>会依次解析配置文件中的各个子节点，如：<code>&lt;settings&gt;</code>、<code>&lt;typeAliases&gt;</code>、<code>&lt;mappers&gt;</code>等。这些子节点在解析完成后都会被注册进<code>configuration</code>对象。然后<code>configuration</code>对象将作为参数，创建<code>SqlSessionFactory</code>对象。至此，初始化过程完毕！<br>
下面我们重点分析<code>&lt;mapper&gt;</code>节点解析的过程。</p>

<p>PS：MyBatis详细的初始化过程请移步至：<a href="https://www.jianshu.com/p/7bc6d3b7fb45" target="_blank" rel="external nofollow noopener noreferrer">MyBatis源码解析(一)——MyBatis初始化过程解析</a></p>

<hr><h1>&lt;mapper&gt;节点解析过程</h1>

<p> </p>

<pre>
<code>XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();
</code></pre>

<p>由上述代码可知，解析mapper节点的解析是由<code>XMLMapperBuilder</code>类的<code>parse()</code>函数来完成的，下面我们就详细看一下<code>parse()</code>函数。</p>

<p> </p>

<pre>
<code>  public void parse() {
    // 若当前Mapper.xml尚未加载，则加载
    if (!configuration.isResourceLoaded(resource)) {
      // 解析&lt;mapper&gt;节点
      configurationElement(parser.evalNode("/mapper"));
      // 将当前Mapper.xml标注为『已加载』（下回就不用再加载了）
      configuration.addLoadedResource(resource);
      // 【关键】将Mapper Class添加至Configuration中
      bindMapperForNamespace();
    }

    parsePendingResultMaps();
    parsePendingCacheRefs();
    parsePendingStatements();
  }
</code></pre>

<p>这个函数主要做了两件事：</p>

<ol><li>解析<code>&lt;mapper&gt;</code>节点，并将解析结果注册进<code>configuration</code>中；</li>
    <li>将当前映射文件所对应的DAO接口的Class对象注册进<code>configuration</code>中<br>
    这一步极为关键！是为了给DAO接口创建代理对象，下文会详细介绍。</li>
</ol><p>下面再进入<code>bindMapperForNamespace()</code>函数，看一看它做了什么：</p>

<p> </p>

<pre>
<code>  private void bindMapperForNamespace() {
    // 获取当前映射文件对应的DAO接口的全限定名
    String namespace = builderAssistant.getCurrentNamespace();
    if (namespace != null) {
      // 将全限定名解析成Class对象
      Class&lt;?&gt; boundType = null;
      try {
        boundType = Resources.classForName(namespace);
      } catch (ClassNotFoundException e) {
      }
      if (boundType != null) {
        if (!configuration.hasMapper(boundType)) {
          // 将当前Mapper.xml标注为『已加载』（下回就不用再加载了）
          configuration.addLoadedResource("namespace:" + namespace);
          // 将DAO接口的Class对象注册进configuration中
          configuration.addMapper(boundType);
        }
      }
    }
  }
</code></pre>

<p>这个函数主要做了两件事：</p>

<ol><li>将<code>&lt;mapper&gt;</code>节点上定义的<code>namespace</code>属性（即：当前映射文件所对应的DAO接口的权限定名）解析成Class对象</li>
    <li>将该Class对象存储在<code>configuration</code>对象的<code>MapperRegistry</code>容器中。</li>
</ol><p>可以看一下<code>MapperRegistry</code>：</p>

<p> </p>

<pre>
<code>public class MapperRegistry {
  private final Configuration config;
  private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();
}
</code></pre>

<p><code>MapperRegistry</code>有且仅有两个属性：<code>Configuration</code>和<code>knownMappers</code>。<br>
其中，<code>knownMappers</code>的类型为<code>Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;</code>，由此可见，它是一个Map，key为DAO接口的Class对象，而Value为该DAO接口代理对象的工厂。<br>
那么，这个代理对象工厂是何许人也？它又是如何产生的呢？我们先来看一下<code>MapperRegistry</code>的<code>addMapper()</code>函数。</p>

<p> </p>

<pre>
<code>  public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
    if (type.isInterface()) {
      if (hasMapper(type)) {
        throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
      }
      boolean loadCompleted = false;
      try {
        // 创建MapperProxyFactory对象，并put进knownMappers中
        knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }
</code></pre>

<p>从这个函数可知，<code>MapperProxyFactory</code>是在这里创建，并put进<code>knownMappers</code>中的。<br>
下面我们就来看一下<code>MapperProxyFactory</code>这个类究竟有些啥：</p>

<p> </p>

<pre>
<code>public class MapperProxyFactory&lt;T&gt; {

  private final Class&lt;T&gt; mapperInterface;
  private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;();

  public MapperProxyFactory(Class&lt;T&gt; mapperInterface) {
    this.mapperInterface = mapperInterface;
  }

  public Class&lt;T&gt; getMapperInterface() {
    return mapperInterface;
  }

  public Map&lt;Method, MapperMethod&gt; getMethodCache() {
    return methodCache;
  }

  @SuppressWarnings("unchecked")
  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
  }

  public T newInstance(SqlSession sqlSession) {
    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);
    return newInstance(mapperProxy);
  }
}
</code></pre>

<p>这个类有三个重要成员：</p>

<ol><li>mapperInterface属性<br>
    这个属性就是DAO接口的Class对象，当创建<code>MapperProxyFactory</code>对象的时候需要传入</li>
    <li>methodCache属性<br>
    这个属性用于存储当前DAO接口中所有的方法。</li>
    <li>newInstance函数<br>
    这个函数用于创建DAO接口的代理对象，它需要传入一个MapperProxy对象作为参数。而MapperProxy类实现了InvocationHandler接口，由此可知它是动态代理中的处理类，所有对目标函数的调用请求都会先被这个处理类截获，所以可以在这个处理类中添加目标函数调用前、调用后的逻辑。</li>
</ol><hr><h1>DAO函数调用过程</h1>

<p>当MyBatis初始化完毕后，<code>configuration</code>对象中存储了所有DAO接口的Class对象和相应的<code>MapperProxyFactory</code>对象（用于创建DAO接口的代理对象）。接下来，就到了使用DAO接口中函数的阶段了。</p>

<p> </p>

<pre>
<code>SqlSession sqlSession = sqlSessionFactory.openSession();
try {
    ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
    List&lt;Product&gt; productList = productMapper.selectProductList();
    for (Product product : productList) {
        System.out.printf(product.toString());
    }
} finally {
    sqlSession.close();
}
</code></pre>

<p>我们首先需要从<code>sqlSessionFactory</code>对象中创建一个<code>SqlSession</code>对象，然后调用<code>sqlSession.getMapper(ProductMapper.class)</code>来获取代理对象。</p>

<p><code>sqlSessionFactory.openSession()</code>创建<code>SqlSession</code>对象</p>

<pre>
<code class="language-java">public SqlSession openSession() {
        return this.openSessionFromDataSource(this.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)null, false);
    }</code></pre>

<p>会调用 openSessionFromDataSource 方法，其中执行器为初始化Configuration时默认的 SimpleExecutor，接下来看openSessionFromDataSource方法</p>

<pre>
<code class="language-java">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
        Transaction tx = null;

        DefaultSqlSession var8;
        try {
            Environment environment = this.configuration.getEnvironment();
            TransactionFactory transactionFactory = this.getTransactionFactoryFromEnvironment(environment);
            tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
            Executor executor = this.configuration.newExecutor(tx, execType);
            var8 = new DefaultSqlSession(this.configuration, executor, autoCommit);
        } catch (Exception var12) {
            this.closeTransaction(tx);
            throw ExceptionFactory.wrapException("Error opening session.  Cause: " + var12, var12);
        } finally {
            ErrorContext.instance().reset();
        }

        return var8;
    }</code></pre>

<p>会返回一个 DefaultSqlSession 对象，看一下其中的this.configuration.newExecutor(tx, execType);方法</p>

<pre>
<code class="language-java">public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
        executorType = executorType == null ? this.defaultExecutorType : executorType;
        executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
        Object executor;
        if (ExecutorType.BATCH == executorType) {
            executor = new BatchExecutor(this, transaction);
        } else if (ExecutorType.REUSE == executorType) {
            executor = new ReuseExecutor(this, transaction);
        } else {
            executor = new SimpleExecutor(this, transaction);
        }

        //缓存
        if (this.cacheEnabled) {
            executor = new CachingExecutor((Executor)executor);
        }
        //责任链模式拦截器 
        Executor executor = (Executor)this.interceptorChain.pluginAll(executor);
        return executor;
    }</code></pre>

<p>开启缓存这里SimpleExecutor就会被CachingExecutor替换</p>

<p><br>
我们再来看一下<code>sqlSession.getMapper()</code>是如何创建代理对象的？</p>

<p> </p>

<pre>
<code>  public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
    return configuration.&lt;T&gt;getMapper(type, this);
  }
</code></pre>

<p><code>sqlSession.getMapper()</code>调用了<code>configuration.getMapper()</code>，那我们再看一下<code>configuration.getMapper()</code>：</p>

<p> </p>

<pre>
<code>  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    return mapperRegistry.getMapper(type, sqlSession);
  }
</code></pre>

<p><code>configuration.getMapper()</code>又调用了<code>mapperRegistry.getMapper()</code>，那好，我们再深入看一下<code>mapperRegistry.getMapper()</code>：</p>

<p> </p>

<pre>
<code>  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException("Type " + type + " is not known to the MapperRegistry.");
    }
    try {
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException("Error getting mapper instance. Cause: " + e, e);
    }
  }
</code></pre>

<p>看到这里我们就恍然大悟了，原来它根据上游传递进来DAO接口的Class对象，从<code>configuration</code>中取出了该DAO接口对应的代理对象生成工厂：<code>MapperProxyFactory</code>；<br>
在有了这个工厂后，再通过<code>newInstance</code>函数创建该DAO接口的代理对象，并返回给上游。</p>

<p>OK，此时我们已经获取了代理对象，接下来就可以使用这个代理对象调用相应的函数了。</p>

<p> </p>

<pre>
<code>SqlSession sqlSession = sqlSessionFactory.openSession();
try {
    ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
    List&lt;Product&gt; productList = productMapper.selectProductList();
    for (Product product : productList) {
        System.out.printf(product.toString());
    }
} finally {
    sqlSession.close();
}
</code></pre>

<p>以上述代码为例，当我们获取到<code>ProductMapper</code>的代理对象后，我们调用了它的<code>selectProductList()</code>函数。<br>
下面我们就来分析下代理函数调用过程。</p>

<hr><p>当调用了代理对象的某一个代理函数后，这个调用请求首先会被发送给代理对象处理类<code>MapperProxy</code>的<code>invoke()</code>函数：</p>

<p> </p>

<pre>
<code>  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    // 【核心代理在这里】
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
  }
</code></pre>

<p>先来解释下invoke函数的几个参数：</p>

<ol><li><code>Object proxy</code>：代理对象</li>
    <li><code>Method method</code>：当前正在被调用的代理对象的函数对象</li>
    <li><code>Object[] args</code>：调用函数的所有入参</li>
</ol><p>然后，直接看invoke函数最核心的两行代码：</p>

<ol><li><code>cachedMapperMethod(method)</code>：从当前代理对象处理类<code>MapperProxy</code>的<code>methodCache</code>属性中获取method方法的详细信息（即：<code>MapperMethod</code>对象）。如果<code>methodCache</code>中没有就创建并加进去。</li>
    <li>有了<code>MapperMethod</code>对象后执行它的<code>execute()</code>方法，该方法就会调用JDBC执行相应的SQL语句，并将结果返回给上游调用者。至此，代理对象函数的调用过程结束！</li>
</ol><p>MapperMethod的execute方法</p>

<pre>
<code class="language-java">public Object execute(SqlSession sqlSession, Object[] args) {
        Object result;
        Object param;
        switch(this.command.getType()) {
        case INSERT:
            param = this.method.convertArgsToSqlCommandParam(args);
            result = this.rowCountResult(sqlSession.insert(this.command.getName(), param));
            break;
        case UPDATE:
            param = this.method.convertArgsToSqlCommandParam(args);
            result = this.rowCountResult(sqlSession.update(this.command.getName(), param));
            break;
        case DELETE:
            param = this.method.convertArgsToSqlCommandParam(args);
            result = this.rowCountResult(sqlSession.delete(this.command.getName(), param));
            break;
        case SELECT:
            if (this.method.returnsVoid() &amp;&amp; this.method.hasResultHandler()) {
                this.executeWithResultHandler(sqlSession, args);
                result = null;
            } else if (this.method.returnsMany()) {
                result = this.executeForMany(sqlSession, args);
            } else if (this.method.returnsMap()) {
                result = this.executeForMap(sqlSession, args);
            } else if (this.method.returnsCursor()) {
                result = this.executeForCursor(sqlSession, args);
            } else {
                param = this.method.convertArgsToSqlCommandParam(args);
                result = sqlSession.selectOne(this.command.getName(), param);
                if (this.method.returnsOptional() &amp;&amp; (result == null || !this.method.getReturnType().equals(result.getClass()))) {
                    result = Optional.ofNullable(result);
                }
            }
            break;
        case FLUSH:
            result = sqlSession.flushStatements();
            break;
        default:
            throw new BindingException("Unknown execution method for: " + this.command.getName());
        }

        if (result == null &amp;&amp; this.method.getReturnType().isPrimitive() &amp;&amp; !this.method.returnsVoid()) {
            throw new BindingException("Mapper method '" + this.command.getName() + " attempted to return null from a method with a primitive return type (" + this.method.getReturnType() + ").");
        } else {
            return result;
        }
    }</code></pre>

<p>可以看出是sqlsession通过xml中的sql id和参数在做CRUD操作，再看 result = this.executeForMany(sqlSession, args);方法</p>

<pre>
<code class="language-java">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
        Object param = this.method.convertArgsToSqlCommandParam(args);
        List result;
        if (this.method.hasRowBounds()) {
            RowBounds rowBounds = this.method.extractRowBounds(args);
            result = sqlSession.selectList(this.command.getName(), param, rowBounds);
        } else {
            result = sqlSession.selectList(this.command.getName(), param);
        }

        if (!this.method.getReturnType().isAssignableFrom(result.getClass())) {
            return this.method.getReturnType().isArray() ? this.convertToArray(result) : this.convertToDeclaredCollection(sqlSession.getConfiguration(), result);
        } else {
            return result;
        }
    }</code></pre>

<p>进入 sqlSession.selectList(this.command.getName(), param, rowBounds);方法</p>

<pre>
<code class="language-java">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
        List var5;
        try {
            MappedStatement ms = this.configuration.getMappedStatement(statement);
            var5 = this.executor.query(ms, this.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
        } catch (Exception var9) {
            throw ExceptionFactory.wrapException("Error querying database.  Cause: " + var9, var9);
        } finally {
            ErrorContext.instance().reset();
        }

        return var5;
    }</code></pre>

<p>继续看 this.executor.query 方法</p>

<pre>
<code class="language-java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
        BoundSql boundSql = ms.getBoundSql(parameterObject);
        CacheKey key = this.createCacheKey(ms, parameterObject, rowBounds, boundSql);
        return this.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }</code></pre>

<p>这里的cacheKey是通过 id +sql+limit+offsetxxx 等等参数确定一个缓存的key</p>

<p>接着看query方法：</p>

<pre>
<code class="language-java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        // 获取二级缓存
        Cache cache = ms.getCache();
        if (cache != null) {
            // 根据ms来决定是否刷新缓存
            this.flushCacheIfRequired(ms);
            if (ms.isUseCache() &amp;&amp; resultHandler == null) {
                this.ensureNoOutParams(ms, boundSql);
                List&lt;E&gt; list = (List)this.tcm.getObject(cache, key);
                if (list == null) {
                    list = this.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
                    // 放入二级缓存
                    this.tcm.putObject(cache, key, list);
                }

                return list;
            }
        }

        return this.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }</code></pre>

<p>有缓存就从缓存中取，无缓存就调用初始化CachingExecutor时传入的SimpleExecutor的query方法，继续看 this.delegate.query 方法：</p>

<pre>
<code class="language-java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        ErrorContext.instance().resource(ms.getResource()).activity("executing a query").object(ms.getId());
        if (this.closed) {
            throw new ExecutorException("Executor was closed.");
        } else {
            // 上一个查询执行完成 并且 &lt;select&gt;标签增加了flushCache="true" 刷新一级缓存
            if (this.queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
                this.clearLocalCache();
            }

            List list;
            try {
                ++this.queryStack;
                // 对于指定了resultHandler的查询，不走缓存。否则从缓存中查询。
                list = resultHandler == null ? (List)this.localCache.getObject(key) : null;
                if (list != null) {
                    // 如果存在缓存参数值，取出来覆盖当前参数值，只针对Callable
                    this.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
                } else {
                    // 缓存中没有，从数据库中查询放入缓存
                    list = this.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
                }
            } finally {
                --this.queryStack;
            }

            if (this.queryStack == 0) {
                Iterator var8 = this.deferredLoads.iterator();

                while(var8.hasNext()) {
                    BaseExecutor.DeferredLoad deferredLoad = (BaseExecutor.DeferredLoad)var8.next();
                    deferredLoad.load();
                }

                this.deferredLoads.clear();
                // 如果cacheScope配置了statement，查询完后清除缓存
                if (this.configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
                    this.clearLocalCache();
                }
            }

            return list;
        }
    }</code></pre>

<p>再看 queryFromDatabase 方法：</p>

<pre>
<code class="language-java">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        // 放入一个初始值
        this.localCache.putObject(key, ExecutionPlaceholder.EXECUTION_PLACEHOLDER);

        List list;
        try {
            list = this.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
        } finally {
            this.localCache.removeObject(key);
        }
        // 放入一级缓存
        this.localCache.putObject(key, list);
        if (ms.getStatementType() == StatementType.CALLABLE) {
            this.localOutputParameterCache.putObject(key, parameter);
        }

        return list;
    }</code></pre>

<p>可以看到上面的查询方法先是看&lt;select&gt;有没有flushCache=”true”，有就刷新一级缓存，没有的话先去从一级缓存取数据，如果一级缓存里没有结果，调用<code>queryFromDatabase</code>方法，从数据库查询结果并返回。</p>

<p>一级缓存的范围有 <code>SESSION</code> 和 <code>STATEMENT</code> 两种，默认是 <code>SESSION</code> ，如果我们不需要使用一级缓存，那么我们可以把一级缓存的范围指定为STATEMENT，这样每次执行完一个Mapper语句后都会将一级缓存清除。如果需要更改一级缓存的范围，请在Mybatis的配置文件中，在&lt;settings&gt;下通过localCacheScope指定。</p>

<p>至此，一次完整的Mybatis执行过程到此结束。</p>

<p> </p>

<p>需要注意的是与spring整合之后，mybatis的一级缓存就失效了</p>

<p>1.mybatis的一级缓存生效的范围是sqlsession，是为了在sqlsession没有关闭时，业务需要重复查询相同数据使用的。一旦sqlsession关闭，则由这个sqlsession缓存的数据将会被清空。</p>

<p>2.spring对mybatis的sqlsession的使用是由template控制的，sqlSessionTemplate又被spring当作resource放在当前线程的上下文里（threadlocal),spring通过mybatis调用数据库的过程如下：</p>

<blockquote>
<ol><li>我们需要访问数据</li>
    <li>spring检查到了这种需求，于是去申请一个mybatis的sqlsession（资源池），并将申请到的sqlsession与当前线程绑定，放入threadlocal里面</li>
    <li>sqlSessionTemplate从threadlocal获取到sqlsession，去执行查询</li>
    <li>查询结束，清空threadlocal中与当前线程绑定的sqlsession，释放资源</li>
    <li>我们又需要访问数据</li>
    <li>返回到步骤2</li>
</ol><p>通过以上步骤后发现，同一线程里面两次查询同一数据所使用的sqlsession是不相同的，所以，给人的印象就是结合spring后，mybatis的一级缓存失效了。</p>
</blockquote>

<p>对于spring开启事务时，getSqlSession方法里面维护了个SqlSessionHolder，关联了事务与session，如果存在则直接取出，否则则新建个session，所以在有事务的里，每个session都是同一个，故能用上缓存了。</p>

<p> </p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis源码解析(一)——MyBatis初始化过程解析</title>
    <url>/2020/03/01/MyBatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)%E2%80%94%E2%80%94MyBatis%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<a id="more"></a>

<h1>1. 准备工作</h1>

<p>为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示：</p>

<p> </p>

<p><img alt src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yOTk0NjA0LTk0Y2EzOTk4YmVlMGFiYjcucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMjk0L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"></p>

<h2>1.1 Product 产品实体类</h2>

<p> </p>

<pre>
<code>public class Product {
    private long id;
    private String productName;
    private String productContent;
    private String price;
    private int sort;
    private int falseSales;
    private long category_id;
    private byte type;
    private byte state;
    // PS：省略setter、getter函数
}
</code></pre>

<h2>1.2 ProductMapper 产品持久化接口</h2>

<p> </p>

<pre>
<code>public interface ProductMapper {
    /**
     * 查询所有的产品
     * @return
     */
    List&lt;Product&gt; selectProductList();
}
</code></pre>

<h2>1.3 ProductMapper.xml 产品映射文件</h2>

<p> </p>

<pre>
<code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;

&lt;mapper namespace="team.njupt.mapper.ProductMapper"&gt;
    &lt;select id="selectProductList" resultType="team.njupt.entity.Product"&gt;
        select * from product
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>

<h2>1.4 db.properties 数据库配置文件</h2>

<p> </p>

<pre>
<code>driver=com.mysql.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;characterEncoding=utf8
username=root
password=xxxxxx
</code></pre>

<h2>1.5 mybatis.xml MyBatis的配置文件</h2>

<p> </p>

<pre>
<code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;properties resource="db.properties"&gt;
        &lt;!--&lt;property name="username" value="dev_user"/&gt;--&gt;
        &lt;!--&lt;property name="password" value="F2Fa3!33TYyg"/&gt;--&gt;
    &lt;/properties&gt;

    &lt;environments default="development"&gt;
        &lt;environment id="development"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="${driver}"/&gt;
                &lt;property name="url" value="${url}"/&gt;
                &lt;property name="username" value="${username}"/&gt;
                &lt;property name="password" value="${password}"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource="team/njupt/mapper/ProductMapper.xml"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>

<h2>1.6 Main 主函数</h2>

<p> </p>

<pre>
<code>public class Main {
    public static void main(String[] args) throws IOException {

        String resource = "mybatis.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        SqlSession sqlSession = sqlSessionFactory.openSession();
        try {
            ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
            List&lt;Product&gt; productList = productMapper.selectProductList();
            for (Product product : productList) {
                System.out.printf(product.toString());
            }
        } finally {
            sqlSession.close();
        }
    }
}
</code></pre>

<hr><h1>2. MyBatis初始化过程</h1>

<h2>2.1 获取配置文件</h2>

<p>当系统初始化时，首先会读取配置文件，并将其解析成InputStream</p>

<p> </p>

<pre>
<code>String resource = "mybatis.xml";
InputStream inputStream = Resources.getResourceAsStream(resource);
</code></pre>

<h2>2.2 创建SqlSessionFactoryBuilder对象</h2>

<p>从<code>SqlSessionFactoryBuilder</code>的名字中可以看出，<code>SqlSessionFactoryBuilder</code>是用来创建<code>SqlSessionFactory</code>对象的。<br>
来看一下SqlSessionFactoryBuilder源码：</p>

<p><img alt src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yOTk0NjA0LWIwZjNlOTk1YWM1NmYyMGEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMzQ5L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"></p>

<p><br>
SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。</p>

<p> </p>

<h2>2.3 SqlSessionFactory创建过程</h2>

<p>下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。</p>

<p> </p>

<pre>
<code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException("Error building SqlSession.", e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}
</code></pre>

<p>2.3.1 构造XMLConfigBuilder对象</p>

<p>build函数首先会构造一个<code>XMLConfigBuilder</code>对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下<code>XMLConfigBuilder</code>的体系结构。</p>

<p><img alt src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yOTk0NjA0LTM5OThmOTcyYTZhNGUyNTEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNzQ4L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"></p>

<p> </p>

<ul><li>
    <p><code>XMLxxxBuilder</code>是用来解析XML配置文件的，不同类型<code>XMLxxxBuilder</code>用来解析MyBatis配置文件的不同部位。比如：<code>XMLConfigBuilder</code>用来解析MyBatis的配置文件，<code>XMLMapperBuilder</code>用来解析MyBatis中的映射文件（如上文提到的<code>ProductMapper.xml</code>），<code>XMLStatementBuilder</code>用来解析映射文件中的SQL语句。</p>
    </li>
    <li>
    <p>这些<code>XMLxxxBuilder</code>都有一个共同的父类——<code>BaseBuilder</code>。这个父类维护了一个全局的<code>Configuration</code>对象，MyBatis的配置文件解析后就以<code>Configuration</code>对象的形式存储。</p>
    </li>
    <li>
    <p>当创建<code>XMLConfigBuilder</code>对象时，就会初始化<code>Configuration</code>对象，并且在初始化<code>Configuration</code>对象的时候，一些别名会被注册到<code>Configuration</code>的<code>typeAliasRegistry</code>容器中。</p>

<pre><code>&lt;pre&gt;</code></pre><p><code>private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {<br>super(new Configuration());<br>ErrorContext.instance().resource("SQL Mapper Configuration");<br>this.configuration.setVariables(props);<br>this.parsed = false;<br>this.environment = environment;<br>this.parser = parser;<br>}<br></code></p>
<pre><code>&lt;pre&gt;</code></pre><p><code>public Configuration() {<br>typeAliasRegistry.registerAlias("JDBC", JdbcTransactionFactory.class);<br>typeAliasRegistry.registerAlias("MANAGED", ManagedTransactionFactory.class);</code></p>
<p>typeAliasRegistry.registerAlias("JNDI", JndiDataSourceFactory.class);<br>typeAliasRegistry.registerAlias("POOLED", PooledDataSourceFactory.class);<br>typeAliasRegistry.registerAlias("UNPOOLED", UnpooledDataSourceFactory.class);</p>
<p>typeAliasRegistry.registerAlias("PERPETUAL", PerpetualCache.class);<br>typeAliasRegistry.registerAlias("FIFO", FifoCache.class);<br>typeAliasRegistry.registerAlias("LRU", LruCache.class);<br>typeAliasRegistry.registerAlias("SOFT", SoftCache.class);<br>typeAliasRegistry.registerAlias("WEAK", WeakCache.class);<br>……<br>}<br><br>    </p></li><p></p>
</ul><h3>2.3.2 解析配置文件</h3>

<p>当有了<code>XMLConfigBuilder</code>对象之后，接下来就可以用它来解析配置文件了。</p>

<p> </p>

<pre>
<code>  private void parseConfiguration(XNode root) {
  try {
    // 解析&lt;properties&gt;节点
    propertiesElement(root.evalNode("properties"));
    // 解析&lt;settings&gt;节点
    Properties settings = settingsAsProperties(root.evalNode("settings"));
    loadCustomVfs(settings);
    // 解析&lt;typeAliases&gt;节点
    typeAliasesElement(root.evalNode("typeAliases"));
    // 解析&lt;plugins&gt;节点
    pluginElement(root.evalNode("plugins"));
    // 解析&lt;objectFactory&gt;节点
    objectFactoryElement(root.evalNode("objectFactory"));
    objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
    // 解析&lt;reflectorFactory&gt;节点
    reflectorFactoryElement(root.evalNode("reflectorFactory"));
    settingsElement(settings);
    // 解析&lt;environments&gt;节点
    environmentsElement(root.evalNode("environments"));
    databaseIdProviderElement(root.evalNode("databaseIdProvider"));
    typeHandlerElement(root.evalNode("typeHandlers"));
    // 解析&lt;mappers&gt;节点
    mapperElement(root.evalNode("mappers"));
  } catch (Exception e) {
    throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
  }
}
</code></pre>

<p>从上述代码中可以看到，<code>XMLConfigBuilder</code>会依次解析配置文件中的<code>&lt;properties&gt;</code>、<code>&lt; settings &gt;</code>、<code>&lt; environments&gt;</code>、<code>&lt; typeAliases &gt;</code>、<code>&lt; plugins &gt;</code>、<code>&lt; mappers &gt;</code>等属性。下面介绍下几个重要属性的解析过程。</p>

<p>2.3.2.1 &lt;properties&gt;节点的解析过程</p>

<ul><li>
    <p>&lt;properties&gt;节点的定义如下：</p>

<pre><code>&lt;pre&gt;</code></pre><p><code class="language-java">&lt;properties resource="org/mybatis/example/config.properties"&gt;<br>  &lt;property name="username" value="dev_user"/&gt;<br>  &lt;property name="password" value="F2Fa3!33TYyg"/&gt;<br>&lt;/properties&gt;<br></code><br>    </p></li><p></p>
</ul><p> </p>

<ul><li>
    <p>&lt;properties&gt;节点的解析过程：</p>

<pre><code>&lt;pre&gt;</code></pre><p><code>/**</code></p>
<ul>
<li><p>@Param context &lt;properties&gt;节点</p>
</li>
<li><p>/<br>private void propertiesElement(XNode context) throws Exception {<br>if (context != null) {<br> // 获取&lt;properties&gt;节点的所有子节点<br> Properties defaults = context.getChildrenAsProperties();<br> // 获取&lt;properties&gt;节点上的resource属性<br> String resource = context.getStringAttribute("resource");<br> // 获取&lt;properties&gt;节点上的url属性<br> String url = context.getStringAttribute("url");<br> // resource和url不能同时存在<br> if (resource != null &amp;&amp; url != null) {<br>   throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.");<br> }<br> if (resource != null) {<br>   // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中<br>   defaults.putAll(Resources.getResourceAsProperties(resource));<br> } else if (url != null) {<br>   // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中<br>   defaults.putAll(Resources.getUrlAsProperties(url));<br> }<br> // 获取configuration中原本的属性，并添加至defaults容器中<br> Properties vars = configuration.getVariables();<br> if (vars != null) {<br>   defaults.putAll(vars);<br> }<br> parser.setVariables(defaults);<br> // 将defaults容器添加至configuration中<br> configuration.setVariables(defaults);<br>}<br>}<br></p>
 <p>如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载：</p>
 </li>
 <li>在 properties 元素体内指定的属性首先被读取。</li>
 <li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。</li>
</ul><p>因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。</p>

</li>
</ul>
<ul><li>最终，携带所有属性的<code>Properties</code>对象会被存储在<code>Configuration</code>对象中。</li>
</ul><p>2.3.2.2 &lt;settings&gt;节点的解析过程</p>

<ul><li>&lt;settings&gt;节点的定义如下：
    <pre>
<code>&lt;settings&gt;
  &lt;setting name="cacheEnabled" value="true"/&gt;
  &lt;setting name="lazyLoadingEnabled" value="true"/&gt;
  &lt;setting name="multipleResultSetsEnabled" value="true"/&gt;
&lt;/settings&gt;
</code></pre>
    </li>
    <li>&lt;settings&gt;节点的解析过程：<br><code>&lt;settings&gt;</code>属性的解析过程和 <code>&lt;properties&gt;</code>属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在<code>Configuration</code>对象中。</li>
</ul><p>2.3.2.3 &lt;typeAliases&gt;属性的解析过程</p>

<p><code>&lt;typeAliases&gt;</code>属性的定义方式有如下两种：</p>

<ul><li>方式1：
    <pre>
<code>&lt;typeAliases&gt;
  &lt;typeAlias alias="Author" type="domain.blog.Author"/&gt;
  &lt;typeAlias alias="Blog" type="domain.blog.Blog"/&gt;
&lt;/typeAliases&gt;
</code></pre>
    </li>
    <li>方式2：
    <pre>
<code>&lt;typeAliases&gt;
  &lt;package name="domain.blog"/&gt;
&lt;/typeAliases&gt;
</code></pre>
    采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。</li>
</ul><p><code>&lt;typeAliases&gt;</code>节点的解析过程如下：</p>

<p> </p>

<pre>
<code>  private void typeAliasesElement(XNode parent) {
  if (parent != null) {
    // 遍历&lt;typeAliases&gt;下的所有子节点
    for (XNode child : parent.getChildren()) {
      // 若当前结点为&lt;package&gt;
      if ("package".equals(child.getName())) {
        // 获取&lt;package&gt;上的name属性（包名）
        String typeAliasPackage = child.getStringAttribute("name");
        // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中          
        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
      } 
      // 如果当前结点为&lt; typeAlias &gt;
      else {
        // 获取alias和type属性
        String alias = child.getStringAttribute("alias");
        String type = child.getStringAttribute("type");
        // 注册进configuration的typeAliasRegistry中
        try {
          Class&lt;?&gt; clazz = Resources.classForName(type);
          if (alias == null) {
            typeAliasRegistry.registerAlias(clazz);
          } else {
            typeAliasRegistry.registerAlias(alias, clazz);
          }
        } catch (ClassNotFoundException e) {
          throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e);
        }
      }
    }
  }
}
</code></pre>

<ul><li>如果<code>&lt;typeAliases&gt;</code>节点下定义了<code>&lt;package&gt;</code>节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名）</li>
    <li>如果<code>&lt;typeAliases&gt;</code>节点下定义了<code>&lt;typeAlias&gt;</code>节点，那么MyBatis就会给指定的类起指定的别名。</li>
    <li>这些别名都会被存入<code>configuration</code>的<code>typeAliasRegistry</code>容器中。</li>
</ul><p>2.3.2.4 &lt;mappers&gt;节点的解析过程</p>

<p><code>&lt;mappers&gt;</code>节点的定义方式有如下四种：</p>

<ul><li>方式1：</li>
</ul><p> </p>

<pre>
<code>&lt;mappers&gt;
  &lt;package name="org.mybatis.builder"/&gt;
&lt;/mappers&gt;
</code></pre>

<ul><li>方式2：</li>
</ul><p> </p>

<pre>
<code>&lt;mappers&gt;
  &lt;mapper resource="org/mybatis/builder/AuthorMapper.xml"/&gt;
&lt;/mappers&gt;
</code></pre>

<ul><li>方式3：</li>
</ul><p> </p>

<pre>
<code>&lt;mappers&gt;
  &lt;mapper url="file:///var/mappers/AuthorMapper.xml"/&gt;
&lt;/mappers&gt;
</code></pre>

<ul><li>方式4：</li>
</ul><p> </p>

<pre>
<code>&lt;mappers&gt;
  &lt;mapper class="org.mybatis.builder.AuthorMapper"/&gt;
&lt;/mappers&gt;
</code></pre>

<p><code>&lt;mappers&gt;</code>节点的解析过程如下：</p>

<p> </p>

<pre>
<code>  private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    // 遍历&lt;mappers&gt;下所有子节点
    for (XNode child : parent.getChildren()) {
      // 如果当前节点为&lt;package&gt;
      if ("package".equals(child.getName())) {
        // 获取&lt;package&gt;的name属性（该属性值为mapper class所在的包名）
        String mapperPackage = child.getStringAttribute("name");
        // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中
        configuration.addMappers(mapperPackage);
      } 
      // 如果当前节点为&lt;mapper&gt;
      else {
        // 依次获取resource、url、class属性
        String resource = child.getStringAttribute("resource");
        String url = child.getStringAttribute("url");
        String mapperClass = child.getStringAttribute("class");
        // 解析resource属性（Mapper.xml文件的路径）
        if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {
          ErrorContext.instance().resource(resource);
          // 将Mapper.xml文件解析成输入流
          InputStream inputStream = Resources.getResourceAsStream(resource);
          // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析url属性（Mapper.xml文件的路径）
        else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {
          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析class属性（Mapper Class的全限定名）
        else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {
          // 将Mapper Class的权限定名转化成Class对象
          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);
          // 注册进configuration对象的mapperRegistry容器中
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException("A mapper element may only specify a url, resource or class, but not more than one.");
        }
      }
    }
  }
}
</code></pre>

<ul><li>MyBatis会遍历<code>&lt;mappers&gt;</code>下所有的子节点，如果当前遍历到的节点是<code>&lt;package&gt;</code>，则MyBatis会将该包下的所有Mapper Class注册到<code>configuration</code>的<code>mapperRegistry</code>容器中。</li>
    <li>如果当前节点为<code>&lt;mapper&gt;</code>，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到<code>configuration</code>的<code>mapperRegistry</code>容器中。</li>
</ul><p>其中，<code>&lt;mapper&gt;</code>节点的解析过程如下：</p>

<p> </p>

<pre>
<code>XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();
</code></pre>

<ul><li>
    <p>在解析前，首先需要创建<code>XMLMapperBuilder</code>，创建过程如下：</p>

<pre><code>&lt;pre&gt;</code></pre><p><code>private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&lt;String, XNode&gt; sqlFragments) {<br>  // 将configuration赋给BaseBuilder<br>  super(configuration);<br>  // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者）<br>  this.builderAssistant = new  MapperBuilderAssistant(configuration, resource);<br>  this.parser = parser;<br>  this.sqlFragments = sqlFragments;<br>  this.resource = resource;<br>}<br></code></p>
<pre><code>&lt;ul&gt;&lt;li&gt;首先会初始化父类&lt;code&gt;BaseBuilder&lt;/code&gt;，并将&lt;code&gt;configuration&lt;/code&gt;赋给BaseBuilder；&lt;/li&gt;
    &lt;li&gt;然后创建&lt;code&gt;MapperBuilderAssistant&lt;/code&gt;对象，该对象为&lt;code&gt;XMLMapperBuilder&lt;/code&gt;的协助者，用来协助&lt;code&gt;XMLMapperBuilder&lt;/code&gt;完成一些解析映射文件的动作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当有了&lt;code&gt;XMLMapperBuilder&lt;/code&gt;后，便可进入解析&lt;code&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;的过程：&lt;/p&gt;

&lt;pre&gt;</code></pre><p><code>public void parse() {<br>  // 若当前的Mapper.xml尚未被解析，则开始解析<br>  // PS：若&lt;mappers&gt;节点下有相同的&lt;mapper&gt;节点，那么就无需再次解析了<br>  if (!configuration.isResourceLoaded(resource)) {<br>    // 解析&lt;mapper&gt;节点<br>    configurationElement(parser.evalNode("/mapper"));<br>    // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析<br>    configuration.addLoadedResource(resource);<br>    // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中<br>    bindMapperForNamespace();<br>  }</code></p>
<p>  parsePendingResultMaps();<br>  parsePendingCacheRefs();<br>  parsePendingStatements();<br>}<br><br>    </p></li><br>    <li><br>    <p><code>configurationElement</code>函数</p><p></p>
<pre><code>&lt;pre&gt;</code></pre><p><code>private void configurationElement(XNode context) {<br>try {<br>  // 获取&lt;mapper&gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁<br>  String namespace = context.getStringAttribute("namespace");<br>  if (namespace == null || namespace.equals("")) {<br>    throw new BuilderException("Mapper's namespace cannot be empty");<br>  }<br>  // 将namespace属性值赋给builderAssistant<br>  builderAssistant.setCurrentNamespace(namespace);<br>  // 解析&lt;cache-ref&gt;节点<br>  cacheRefElement(context.evalNode("cache-ref"));<br>  // 解析&lt;cache&gt;节点<br>  cacheElement(context.evalNode("cache"));<br>  // 解析&lt;parameterMap&gt;节点<br>  parameterMapElement(context.evalNodes("/mapper/parameterMap"));<br>  // 解析&lt;resultMap&gt;节点<br>  resultMapElements(context.evalNodes("/mapper/resultMap"));<br>  // 解析&lt;sql&gt;节点<br>  sqlElement(context.evalNodes("/mapper/sql"));<br>  // 解析sql语句<br>  buildStatementFromContext(context.evalNodes("select|insert|update|delete"));<br>} catch (Exception e) {<br>  throw new BuilderException("Error parsing Mapper XML. Cause: " + e, e);<br>}<br>}<br></code><br>    </p></li><br>    <li><br>    <p><code>resultMapElements</code>函数<br><br>    该函数用于解析映射文件中所有的<code>&lt;resultMap&gt;</code>节点，这些节点会被解析成<code>ResultMap</code>对象，存储在<code>Configuration</code>对象的<code>resultMaps</code>容器中。</p><p></p>
<pre><code>&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点定义如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;</code></pre><p><code> &lt;resultMap id="userResultMap" type="User"&gt;<br>  &lt;constructor&gt;<br>     &lt;idArg column="id" javaType="int"/&gt;<br>     &lt;arg column="username" javaType="String"/&gt;<br>  &lt;/constructor&gt;<br>  &lt;result property="username" column="user_name"/&gt;<br>  &lt;result property="password" column="hashed_password"/&gt;<br>&lt;/resultMap&gt;<br></code></p>
<pre><code>&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点的解析过程：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;</code></pre><p><code>private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception {<br>  ErrorContext.instance().activity("processing " + resultMapNode.getValueBasedIdentifier());<br>  // 获取&lt;ResultMap&gt;上的id属性<br>  String id = resultMapNode.getStringAttribute("id",<br>    resultMapNode.getValueBasedIdentifier());<br>  // 获取&lt;ResultMap&gt;上的type属性（即resultMap的返回值类型）<br>  String type = resultMapNode.getStringAttribute("type",<br>    resultMapNode.getStringAttribute("ofType",<br>        resultMapNode.getStringAttribute("resultType",<br>            resultMapNode.getStringAttribute("javaType"))));<br>  // 获取extends属性<br>  String extend = resultMapNode.getStringAttribute("extends");<br>  // 获取autoMapping属性<br>  Boolean autoMapping = resultMapNode.getBooleanAttribute("autoMapping");<br>  // 将resultMap的返回值类型转换成Class对象<br>  Class&lt;?&gt; typeClass = resolveClass(type);<br>  Discriminator discriminator = null;<br>  // resultMappings用于存储&lt;resultMap&gt;下所有的子节点<br>  List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;ResultMapping&gt;();<br>  resultMappings.addAll(additionalResultMappings);<br>  // 获取并遍历&lt;resultMap&gt;下所有的子节点<br>  List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();<br>  for (XNode resultChild : resultChildren) {<br>    // 若当前节点为&lt;constructor&gt;，则将它的子节点们添加到resultMappings中去<br>    if ("constructor".equals(resultChild.getName())) {<br>      processConstructorElement(resultChild, typeClass, resultMappings);<br>    }<br>    // 若当前节点为&lt;discriminator&gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去<br>    else if ("discriminator".equals(resultChild.getName())) {<br>      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);<br>    }<br>    // 若当前节点为&lt;result&gt;、&lt;association&gt;、&lt;collection&gt;，则将其添加到resultMappings中去<br>    else {<br>      // PS:flags仅用于区分当前节点是否是&lt;id&gt;或&lt;idArg&gt;，因为这两个节点的属性名为name，而其他节点的属性名为property<br>      List&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;();<br>      if ("id".equals(resultChild.getName())) {<br>        flags.add(ResultFlag.ID);<br>      }<br>      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));<br>    }<br>  }<br>  // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下）<br>  ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);<br>  try {<br>    return resultMapResolver.resolve();<br>  } catch (IncompleteElementException  e) {<br>    configuration.addIncompleteResultMap(resultMapResolver);<br>    throw e;<br>  }<br>}<br></code></p>
<pre><code>&lt;p&gt;&lt;code&gt;ResultMapResolver&lt;/code&gt;这个类很纯粹，有且仅有一个函数&lt;code&gt;resolve&lt;/code&gt;，用于构造&lt;code&gt;ResultMap&lt;/code&gt;对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于&lt;code&gt;MapperBuilderAssistant.addResultMap&lt;/code&gt;完成的。&lt;/p&gt;

&lt;pre&gt;</code></pre><p><code>public ResultMap resolve() {<br>  return assistant.addResultMap(this.id, this.type, this.extend,  this.discriminator, this.resultMappings, this.autoMapping);<br>}<br></code><br>    </p></li><br>    <li><br>    <p><code>sqlElement</code>函数<br><br>    该函数用于解析映射文件中所有的<code>&lt;sql&gt;</code>节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。</p><p></p>
<pre><code>&lt;pre&gt;</code></pre><p><code>&lt;sql id="userColumns"&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt;<br></code><br>    </p></li><p></p>
</ul><ul><li><code>buildStatementFromContext</code>函数<br>
    该函数会将映射文件中的sql语句解析成<code>MappedStatement</code>对象，并存在<code>configuration</code>的<code>mappedStatements</code>。</li>
</ul><h3>2.3.3 创建SqlSessionFactory对象</h3>

<p> </p>

<pre>
<code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException("Error building SqlSession.", e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}
</code></pre>

<p>回过头来再看一下<code>SqlSessionFactory</code>的<code>build</code>函数，刚才说了半天，介绍了<code>XMLConfigBuilder</code>解析映射文件的过程，解析完成之后<code>parser.parse()</code>函数会返回一个包含了映射文件解析结果的<code>configuration</code>对象，紧接着，这个对象将作为参数传递给另一个build函数，如下：</p>

<p> </p>

<pre>
<code>  public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
  }
</code></pre>

<p>这个函数将<code>configuration</code>作为参数，创建了<code>DefaultSqlSessionFactory</code>对象。<br><code>DefaultSqlSessionFactory</code>是接口<code>SqlSessionFactory</code>的一个实现类，<code>SqlSessionFactory</code>的体系结构如下图所示：</p>

<p><img alt src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yOTk0NjA0LWRhMmRiZDhmMWYyYWM4NDQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNDM2L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"></p>

<p> </p>

<p>此时，<code>SqlSessionFactory</code>创建完毕！</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Java通过序列化实现深度复制</title>
    <url>/2019/11/05/Java%E9%80%9A%E8%BF%87%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<a id="more"></a>

<pre class="has">
<code class="language-java">package beanCopy;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

public class SerializeTest {

    public static void main(String[] args) throws IOException, ClassNotFoundException {

        Son son=new Son("qwer", "15");
        List sons=new ArrayList&lt;Son&gt;();
        sons.add(son);
        Person p1=new Person("zs", "30",sons);

        ByteArrayOutputStream bos=new ByteArrayOutputStream();
        ObjectOutputStream oos=new ObjectOutputStream(bos);

        oos.writeObject(p1);

        ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois=new ObjectInputStream(bis);

        Person p2=(Person) ois.readObject();

        System.out.println(p1);
        System.out.println(p2);


    }

}


class Person implements Serializable{

    private String name;

    private String age;

    private List&lt;Son&gt; sons;


    /*@Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + ", sons=" + sons + "]";
    }*/



    public Person(String name, String age, List&lt;Son&gt; sons) {
        super();
        this.name = name;
        this.age = age;
        this.sons = sons;
    }



    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }



}


class Son implements Serializable{
    private String name;

    private String age;



    /*@Override
    public String toString() {
        return "Son [name=" + name + ", age=" + age + "]";
    }*/

    public Son(String name, String age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }


}</code></pre>

<p>输出</p>

<p><img alt class="has" height="74" src="https://img-blog.csdnimg.cn/20191105233038132.png" width="378"></p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>（Linux）远程挂载网络磁盘详解---nfs共享</title>
    <url>/2019/06/11/%EF%BC%88Linux%EF%BC%89%E8%BF%9C%E7%A8%8B%E6%8C%82%E8%BD%BD%E7%BD%91%E7%BB%9C%E7%A3%81%E7%9B%98%E8%AF%A6%E8%A7%A3---nfs%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<a id="more"></a>

<h1><strong>前言</strong></h1>

<hr><p>在Linux或Windows乃至其他的系统，我们经常会需要进行磁盘的挂载。通常从挂载的方式的上分为本地挂载和远程挂载。Linux的本地挂载就不介绍了，这篇文章介绍的是远程挂载网络磁盘。</p>

<hr><h1> </h1>

<h1><strong>远程挂载网络磁盘</strong></h1>

<hr><p>实际上，这个操作与使用nfs共享一个文件的方法是相同的。思路是服务端将一块磁盘空间本地挂载到一个目录，然后通过网络使用nfs将这个目录进行共享，客户端最后将服务端共享的目录挂载到自己本地的一个目录，这样就使客户端拥有了一块网络磁盘。</p>

<p>优点是:服务端的同一块磁盘可以挂载到不同的客户端，实现文件的共享；可以扩充客户端的存储空间。<br>
缺点是：依赖网络，当网络联通失败，客户端挂载的网络磁盘会无法使用。</p>

<p>做网络挂载，服务端与客户端网络要联通，最好是在同一局域网内，还要注意防火墙的设置。<br>
 </p>

<hr><h2><strong>NFS简介</strong></h2>

<ul><li>
    <p>Sun公司于1984年发布。</p>
    </li>
    <li>
    <p>NFS 是一种可分散式的网络文件系统。</p>
    </li>
    <li>
    <p>可以通过网络使不同的机器、不同的操作系统，能够分享资料，使客户端能通过网络访问并分享文件到位于服务端的磁盘中。</p>
    </li>
    <li>NFS在文件传送或信息传送过程中依赖于RPC协议。RPC负责负责信息的传输。</li>
</ul><hr><h2> </h2>

<h2><strong>服务端操作</strong></h2>

<hr><p>【1】安装NFS程序</p>

<p>yum -y install nfs*</p>

<p>rpcbind,在centos6以前自带的yum源中为portmap。<br>
使用yum安装nfs时会下载依赖，因此只要下载nfs即可，无需再下载rpcbind.</p>

<p>【2】查看是否安装了nfs与rpcbind</p>

<p>rpm -qa |grep nfs<br>
rpm -qa |grep rpcbind<br><img alt="è¿éåå¾çæè¿°" class="has" src="https://img-blog.csdn.net/20180915190249681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dYXzFfMTFfcmVhbA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>【3】创建共享的目录并共享</p>

<p>如要共享的目录已存在请跳过创建</p>

<p>&lt;1&gt;mkdir /mnt/nfs01</p>

<p>&lt;2&gt;vim /etc/exports<br>
/mnt/nfs01 10.10.10.0/24 (rw,no_root_squash,no_all_squash,sync)<br>
 </p>

<pre class="has">
<code class="language-bash">
配置


/mnt/nfs01      10.10.10.0/24    (rw,no_root_squash,no_all_squash,sync)

要共享的目录     要分享给的客户端   客户端对此共享目录的权限

----------


客户端指定


192.168.1.125           指定特定的的IP可以共享nfs目录

*                       指定所有网段及ip都可以共享nfs目录

192.168.1.0/24          指定子网中的所有主机都可以共享nfs目录

2018fs.wxyonghe.com     指定域名的主机可以共享nfs目录

----------


权限


rw                      可读可写     

ro                      只读(还与文件系统的rwx有关)

sync　　                 数据同步写入到内存与硬盘中

async                   数据先暂存于内存当中，不会直接写入硬盘

wdelay                  当有写操作，就会检查是否有相关的写操作，并在一起执行(默认设置)

no_wdelay               当有写操作就立即执行，通常要与sync配合使用

root_squash             当客户端登陆NFS的身份为root用户时，将客户端的root用户及所属组都映射为匿名用户或用户组（默认设置） 

no_root_squash　　       使客户端可以使用root身份及权限来操作共享的目录

all_squash              无论客户端登陆NFS的身份为何，都将映射为匿名用户

no_all_squash           无论客户端登陆NFS的身份为何，都将映射为root用户（默认设置）

anonuid                 将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户

anongid                 将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户

secure                  使客户端只能从小于1024的tcp/ip端口连接服务端(默认设置)

insecure                允许客户端从大于1024的tcp/ip端口连接服务端

subtree                 当共享的目录是一个子目录，服务端会检查其父目录的权限(默认设置)

no_subtree              当共享的目录是一个子目录，服务端不检查其父目录的权限
</code></pre>

<p>【4】启动nfs,rpcbind,并设为开机自启</p>

<p>(centos7)<br>
systemctl start nfs<br>
systemctl start rpcbind<br>
systemctl enable nfs<br>
systemclt enable rpcbind</p>

<p>(centos6)<br>
service nfs start<br>
service rpcbind start</p>

<p>【5】查看是否共享成功</p>

<p>showmount -e localhost<br><img alt="è¿éåå¾çæè¿°" class="has" src="https://img-blog.csdn.net/2018091520415162?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dYXzFfMTFfcmVhbA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>可看到共享的目录及客户端，即为成功</p>

<hr><p> </p>

<h2><strong>客户端操作</strong></h2>

<hr><p>【1】安装NFS程序</p>

<p>yum -y install nfs*</p>

<p>【2】启动nfs</p>

<p>(centos7)<br>
systemctl start nfs<br>
systemctl start rpcbind<br>
systemctl enable nfs<br>
systemctl enable rpcbind</p>

<p>(centos6)<br>
service nfs start<br>
service rpcbind start<br>
chkconfig nfs on<br>
chkconfig rpcbind on</p>

<p>【3】创建挂载目录</p>

<p>mkdir /data/nfsone</p>

<p>【4】查看是否共享成功</p>

<p>showmount -e nfs服务端IP</p>

<p>showmount -e 10.10.20.212<br><img alt="è¿éåå¾çæè¿°" class="has" src="https://img-blog.csdn.net/20180915205422918?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dYXzFfMTFfcmVhbA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>【5】网络挂载</p>

<p>mount -t nfs -o nolock 服务端IP:共享目录绝对路径 本地挂载目录<br>
mount -t nfs -o nolock 10.10.20.212:/mnt/nfs01 /data/nfsone</p>

<p>centos7的nfs默认使用的是nfs4,所以mount -t 无需指定nfs4也可以</p>

<p>【6】查看是否成功</p>

<p>df -Th<br><img alt="è¿éåå¾çæè¿°" class="has" src="https://img-blog.csdn.net/20180915211531532?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dYXzFfMTFfcmVhbA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>【7】卸载网络磁盘</p>

<p>与卸载本地挂载相同</p>

<p>umount /data/nfsone<br>
或<br>
umount 10.10.20.212:/mnt/nfs01</p>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Java导出CSV格式文件</title>
    <url>/2019/03/19/Java%E5%AF%BC%E5%87%BACSV%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<a id="more"></a>

<p>导出csv格式文件的本质是导出以逗号为分隔的文本数据</p>

<pre class="has">
<code>import java.io.BufferedWriter;  
import java.io.File;  
import java.io.FileInputStream;  
import java.io.FileNotFoundException;  
import java.io.FileOutputStream;  
import java.io.IOException;  
import java.io.InputStream;  
import java.io.OutputStream;  
import java.io.OutputStreamWriter;  
import java.net.URLEncoder;  
import java.util.ArrayList;  
import java.util.Iterator;  
import java.util.LinkedHashMap;  
import java.util.List;  
import java.util.Map;  

import javax.servlet.http.HttpServletResponse;  

import com.alibaba.druid.util.StringUtils;



/** 
 * 文件操作 
 */  
public class CSVUtils {  


    /**
    * 功能说明：获取UTF-8编码文本文件开头的BOM签名。
    * BOM(Byte Order Mark)，是UTF编码方案里用于标识编码的标准标记。例：接收者收到以EF BB BF开头的字节流，就知道是UTF-8编码。
    * @return UTF-8编码文本文件开头的BOM签名
    */
    public static String getBOM() {

         byte b[] = {(byte)0xEF, (byte)0xBB, (byte)0xBF};
         return new String(b);
    }


  /** 
   * 生成CVS文件
   * @param exportData 
   *       源数据List 
   * @param map 
   *       csv文件的列表头map 
   * @param outPutPath 
   *       文件路径 
   * @param fileName 
   *       文件名称 
   * @return 
      */  
    @SuppressWarnings("rawtypes")  
    public static File createCSVFile(List exportData, LinkedHashMap map, String outPutPath,  
                   String fileName) {  

    File csvFile = null;  
    BufferedWriter csvFileOutputStream = null;  
    try {  
      File file = new File(outPutPath);  
      if (!file.exists()) {  
        file.mkdirs();  
      }  
      //定义文件名格式并创建  
      csvFile =new File(outPutPath+fileName+".csv");
      file.createNewFile();  
      // UTF-8使正确读取分隔符","  
      //如果生产文件乱码，windows下用gbk，linux用UTF-8
      csvFileOutputStream = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(  
        csvFile), "UTF-8"), 1024);  

      //写入前段字节流，防止乱码
      csvFileOutputStream.write(getBOM());
      // 写入文件头部
      for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator.hasNext();) {  
        java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator.next();  
        csvFileOutputStream.write((String) propertyEntry.getValue() != null ? (String) propertyEntry.getValue() : "" );  
        if (propertyIterator.hasNext()) {  
          csvFileOutputStream.write(",");  
        }  
      }  
      csvFileOutputStream.newLine();  
      // 写入文件内容  
      for (Iterator iterator = exportData.iterator(); iterator.hasNext();) {  
          Object row = (Object) iterator.next();
        for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator  
          .hasNext();) {  
          java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator  
            .next();  
          String str=row!=null?((String)((Map)row).get( propertyEntry.getKey())):"";

          if(StringUtils.isEmpty(str)){
              str="";
          }else{
              str=str.replaceAll("\"","\"\"");
              if(str.indexOf(",")&gt;=0){
                  str="\""+str+"\"";
              }
          }
          csvFileOutputStream.write(str);  
          if (propertyIterator.hasNext()) {  
            csvFileOutputStream.write(",");  
          }  
        }  
        if (iterator.hasNext()) {  
          csvFileOutputStream.newLine();  
        }  
      }  
      csvFileOutputStream.flush();  
    } catch (Exception e) {  
      e.printStackTrace();  
    } finally {  
      try {  
        csvFileOutputStream.close();  
      } catch (IOException e) {  
        e.printStackTrace();  
      }  
    }  
    return csvFile;  
  }  

  /**
   *     生成并下载csv文件
   * @param response
   * @param exportData
   * @param map
   * @param outPutPath
   * @param fileName
   * @throws IOException
      */
    @SuppressWarnings("rawtypes")
    public static void exportDataFile(HttpServletResponse response,List exportData, LinkedHashMap map, String outPutPath,String fileName) throws IOException{
      File csvFile = null;  
        BufferedWriter csvFileOutputStream = null;  
        try {  
          File file = new File(outPutPath);  
          if (!file.exists()) {  
            file.mkdirs();  
          }  
          //定义文件名格式并创建  
          csvFile =new File(outPutPath+fileName+".csv");
          if(csvFile.exists()){
             csvFile.delete(); 
          }
          csvFile.createNewFile();  
          // UTF-8使正确读取分隔符","  
          //如果生产文件乱码，windows下用gbk，linux用UTF-8
          csvFileOutputStream = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(csvFile), "UTF-8"), 1024);  
          //写入前段字节流，防止乱码
          csvFileOutputStream.write(getBOM());
          // 写入文件头部  
          for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator.hasNext();) {  
            java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator.next();  
            csvFileOutputStream.write((String) propertyEntry.getValue() != null ? (String) propertyEntry.getValue() : "" );  
            if (propertyIterator.hasNext()) {  
              csvFileOutputStream.write(",");  
            }  
          }  
          csvFileOutputStream.newLine();  
          // 写入文件内容  
          for (Iterator iterator = exportData.iterator(); iterator.hasNext();) {  
            Object row = (Object) iterator.next();  
            for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator  
              .hasNext();) {  
              java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator  
                .next();  
              String str=row!=null?((String)((Map)row).get( propertyEntry.getKey())):"";
              if(StringUtils.isEmpty(str)){
                  str="";
              }else{
                  str=str.replaceAll("\"","\"\"");
                  if(str.indexOf(",")&gt;=0){
                      str="\""+str+"\"";
                  }
              }
              csvFileOutputStream.write(str);  
              if (propertyIterator.hasNext()) {  
                csvFileOutputStream.write(",");  
              }  
            }  
            if (iterator.hasNext()) {  
              csvFileOutputStream.newLine();  
            }  
          }  
          csvFileOutputStream.flush();  
        } catch (Exception e) {  
          e.printStackTrace();  
        } finally {  
          try {  
            csvFileOutputStream.close();  
          } catch (IOException e) {  
            e.printStackTrace();  
          }  
        }  




        InputStream in = null;  
        try {  
          in = new FileInputStream(outPutPath+fileName+".csv");  
          int len = 0;  
          byte[] buffer = new byte[1024];  

          OutputStream out = response.getOutputStream(); 
          response.reset(); 

          response.setContentType("application/csv;charset=UTF-8");  
          response.setHeader("Content-Disposition","attachment; filename=" + URLEncoder.encode(fileName+".csv", "UTF-8"));  
          response.setCharacterEncoding("UTF-8"); 
          while ((len = in.read(buffer)) &gt; 0) {  
            out.write(new byte[] { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF });  
            out.write(buffer, 0, len);  
          }
          out.close();
        } catch (FileNotFoundException e) {  
        } finally {  
          if (in != null) {  
            try {  
              in.close();  
            } catch (Exception e) {  
              throw new RuntimeException(e);  
            }  
          }  
        }


  }

  /** 
   * 删除该目录filePath下的所有文件 
   * @param filePath 
   *      文件目录路径 
      */  
    public static void deleteFiles(String filePath) {  

    File file = new File(filePath);  
    if (file.exists()) {  
      File[] files = file.listFiles();  
      for (int i = 0; i &lt; files.length; i++) {  
        if (files[i].isFile()) {  
          files[i].delete();  
        }  
      }  
    }  
  }  

  /** 
   * 删除单个文件 
   * @param filePath 
   *     文件目录路径 
   * @param fileName 
   *     文件名称 
      */  
    public static void deleteFile(String filePath, String fileName) {  

    File file = new File(filePath);  
    if (file.exists()) {  
      File[] files = file.listFiles();  
      for (int i = 0; i &lt; files.length; i++) {  
        if (files[i].isFile()) {  
          if (files[i].getName().equals(fileName)) {  
            files[i].delete();  
            return;  
          }  
        }  
      }  
    }  
  }  

  /** 
   * 测试数据 
   * @param args 
      */  
    @SuppressWarnings({ "rawtypes", "unchecked" })  
    public static void main(String[] args) {  

    List exportData = new ArrayList&lt;Map&gt;();  
    Map row1 = new LinkedHashMap&lt;String, String&gt;();  
    row1.put("1", "11");  
    row1.put("2", "12");  
    row1.put("3", "13");  
    row1.put("4", "14");  
    exportData.add(row1);  
    row1 = new LinkedHashMap&lt;String, String&gt;();  
    row1.put("1", "21");  
    row1.put("2", "22");  
    row1.put("3", "23");  
    row1.put("4", "24");  
    exportData.add(row1);  
    LinkedHashMap map = new LinkedHashMap();  

    //设置列名
    map.put("1", "第一列名称");  
    map.put("2", "第二列名称");  
    map.put("3", "第三列名称");  
    map.put("4", "第四列名称");  
    //这个文件上传到路径，可以配置在数据库从数据库读取，这样方便一些！
    String path = "E:/";  

   //文件名=生产的文件名称+时间戳
    String fileName = "文件导出";  
    File file = CSVUtils.createCSVFile(exportData, map, path, fileName);  
    String fileName2 = file.getName();  
    System.out.println("文件名称：" + fileName2);  
  }  
}</code></pre>

<p><img alt class="has" src="https://images2018.cnblogs.com/blog/1443172/201808/1443172-20180813231232388-1283590677.png"></p>

<p>转自<a href="https://www.cnblogs.com/hanfengyeqiao/p/9471694.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/hanfengyeqiao/p/9471694.html</a></p>

<p> </p>

<p>需要注意的是生成的csv其中的数字若过长，csv中查看没有问题，但是用excel打开数字就会变成科学计数法 </p>

<p>解决方法是在生成csv的时候,在数字的前面或后面加上"\t"制表符，再用excel打开问题解决！如 “1234567890\ t”,“\ t1213212312”</p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Redis笔记</title>
    <url>/2018/11/22/Redis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<a id="more"></a>

<h2>在分布式数据库中CAP原理CAP+BASE:</h2>

<p>传统的ACID分别是什么：A（Atomicity）原子性  C(Consistency)一致性  I（Isolation）隔离性  D（Durability）持久性<br>
CAP:  C（Consistency）强一致性   A（Availability）可用性    P（Partition tolerance）分区容错性<br>
CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个要求；<br>
CA-单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大（RDBMS）<br>
CP-满足一致性，分区容错性的系统，通常性能不是特别高(MongoDB，HBase,redis)<br>
AP-满足可用性，分区容错性的系统，通常可能对一致性要求低一些,大多数网站架构的选择(CouchDB CASSANDRA)<br>
BASE:基本可用（basically available）<br>
软状态 （soft state）<br>
最终一致性（eventually consistent）<br>
它的思想是通过让系统轻松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统旺旺由于地域分布和级高性能的要求，不可能采用分布式失误来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是来解决这个问题的办法<br>
 </p>

<p><strong>分布式和集群介绍</strong>：</p>

<p>分布式：不同的多态服务器上面部署不同的服务器块，他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作<br>
集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问</p>

<p> </p>

<h3>Redis介绍</h3>

<p>Redis：Remote Dictionary Server（远程字典服务器），是完全开源免费的，用C语言编写的，遵守BSD协议。是一个高性能的（key/value）分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，也被人们称为数据结构服务器。</p>

<p>Redis及其他key/value缓存产品有以下三个特点：</p>

<p>       1.Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用；</p>

<p>       2.Redis不仅仅支持简单的key-value类型的数据，同时还支持list、set、zset、hash等数据结构的存储。</p>

<p>       3.Redis支持数据的备份，及master-slave模式的数据备份。</p>

<p>功能：</p>

<p>      内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务</p>

<p>      取最新N个数据的操作：如：将最新10条评论的ID放入Redis的list集合中</p>

<p>      模拟类似于HttpSession这种需要设定过期时间的功能</p>

<p>      发布、订阅消息系统</p>

<p>       定时器、计数器</p>

<p><strong>基础命令</strong></p>

<p>Key：</p>

<p>       keys * ：列出当前库所有key</p>

<p>       exists key的名字：判断某个key是否存在</p>

<p>       move key db ：当前库没有，被移除</p>

<p>       exire key 秒钟 ：为给定key设置过期时间</p>

<p>       ttl key：查看还有多少秒过期，-1永不过期，-2表示已过期即移除内存</p>

<p>       type key：查看key的类型</p>

<p> </p>

<p>String：</p>

<p>          set/get：set  k1  qwer, get  k1     set k2  123</p>

<p>          del:del  k1</p>

<p>          append: append k1 123      (qwer123)</p>

<p>          incr、decr、incrby、decrby  ： incrby  k2  2  一定要是数字才能加减</p>

<p>          getrange、setrange ： getrange k1 0 -1 (qwer)   getrange 0 2 (qwe)    setrange k1 0 xx （xxer）</p>

<p>          setex：设置过期时间  setex k3 10 v3</p>

<p>          setnx：不存在就set成功  存在就返回0  不会覆盖之前的  setnx  k1  zxcvv  返回0</p>

<p>          mset、mget、msetnx：mset k1 v1 k2 v2 k3 v3    mget k1 k2 k3     msetnx有一个存在就会set失败</p>

<p>List：</p>

<p>        rpush  mylist  1 2 3 4 5      rpush  list   123</p>

<p>        lpush、rpush、lrange   ：l先进后出 r先进先出</p>

<p>        lpop、rpop：出栈  同上   </p>

<p>        lindex：按下标获取元素   lindex  mylist  1   （2）</p>

<p>        llen：长度</p>

<p>        lrem key  n  val ：删除n个val</p>

<p>        ltrim  key  start  end  截取指定范围的值赋给key</p>

<p>        rpoplpush   源列表  目的列表   rpoplpush  mylist  list   （5123）</p>

<p>        lset  key  index   value    覆盖列表中下标位置的值</p>

<p>        linsert  key  before/after  val1  val2  在val1前/后插入val2</p>

<p>Set：</p>

<p>      sadd、smembers、sismember    sadd set1 1 1 2 2 3 3 （1 2 3） 、  smembers  set1（1 2 3） </p>

<p>      scard：获取集合元素个数</p>

<p>      srem  key  val  ：删除集合中某个元素</p>

<p>      srandmember  key  n  随机列出n个元素</p>

<p>      spop  key：随机出栈</p>

<p>      smove  k1  k2   在k1中的某个值 ：将k1中某个值移除赋给k2</p>

<p>      sdiff  k1   k2  ：在k1中不在k2中的元素</p>

<p>      sinter  k1  k2  ：k1  k2  的交集</p>

<p>      sunion k1  k2 ：并集</p>

<p><strong>Hash</strong>：kv模式不变  v为键值对</p>

<p>            hset  user name  zs  、  hget  user  name</p>

<p>            hmset   customer  id 1  name  zz  age  20  、hmget  customer  id  name  age</p>

<p>            hgetall   customer   (id 1 name zz age 20)</p>

<p>            hdel  user  name</p>

<p>            hlen  长度</p>

<p>            hexists  key  在key中某个值的key  ：  hexists  customer  id</p>

<p>            hkeys、hvals ：hkeys  customer  （id name age）</p>

<p>            hincrby、hincrbyfloat</p>

<p>            hsetnx</p>

<p>Zset（sorted set）：</p>

<p>            zadd  zset01  60 v1  70  v2  80  v3  、zrange  zset01   0  -1 (withscores) （v1  v2  v3）</p>

<p>            zrangebyscore  key  score1   score2  （limit  index1  index2 ）：  “（score”表示不包含 </p>

<p>            zrem  key   val   删除</p>

<p>            zcard  key  统计</p>

<p>            zcount  key  val1  val2   统计分数段中的个数</p>

<p>            zrank   key  val   返回val的下标</p>

<p>            zscore  key  val  返回val对应的score</p>

<p>            zrevrank  key  val   逆序获得下标</p>

<p>            zrevrange  key  0  -1   逆序获得 （v3  v2  v1）</p>

<p>            zrevrangebyscore  key  score1   score2   结束分数到开始分数</p>

<p>           </p>

<p><strong>Maxmemory-policy</strong></p>

<p>     1.volatile-lru：使用LRU算法移除key，只对设置了过期时间的key</p>

<p>     2.allkeys-lru：使用LRU算法移除key</p>

<p>     3.volatile-random：在过期集合中移除随机的key，只对设置了过期时间的key</p>

<p>     4.allkeys-random：移除随机的key</p>

<p>     5.volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</p>

<p>     6.noeviction：不进行移除，针对写操作，只是返回错误信息</p>

<p>       </p>

<h3><strong>Redis的持久化机制</strong></h3>

<p><strong>RDB</strong></p>

<p>          RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p>

<p>手动触发分别对应save和bgsave命令。</p>

<p>save：阻塞当前redis服务器，直到RDB过程完成为止。对于内存较大的实例会产生长时间的阻塞，线上环境不建议使用。</p>

<p>bgsave：redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束，阻塞只发生在fork阶段，时间很短。所以一般使用bgsave。</p>

<p>自动触发机制场景：</p>

<p>     1 ) 使用save相关配置，如‘save m n’表示m秒之内数据集存在n次修改时，自动触发bgsave。<br>
     2）如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点。<br>
     3）执行debug reload命令重新加载Redis时，也会自动触发save操作。<br>
     4）默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</p>

<p>RDB优点：RDB是一个紧凑压缩的二进制文件，代表Redis在某一个时间点上的数据快照。非常适合用于备份，全量复制等场景。<br>
                  Redis加载RDB恢复数据远远快于AOF方式。</p>

<p>      缺点：RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操  作，频繁执行成本过高。<br>
RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</p>

<p><strong>AOF</strong></p>

<p>      AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p>

<p>     开启AOF功能需要设置配置：appendonly yes,默认不开启。AOF文件通过appendfilename 配置设置，默认文件名是appendonly.aof。保存路径同RDB持久化方式一致。通过dir配置指定。AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）。</p>

<p>    流程如下：<br>
         1） 所有的写入命令会追加到aof_buf（缓冲区）中。<br>
         2） AOF缓冲区根据对应的策略向硬盘做同步操作。<br>
         3） 随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。<br>
         4） 当Redis服务重启时，可以加载AOF文件进行数据恢复。</p>

<p>   AOF为什么把命令追加到aof_buf中？</p>

<p>       Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</p>

<p> </p>

<p>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制</p>

<p>     write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。<br>
      fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回，保证了数据持久化。</p>

<p>       默认配置为everysec，做到兼顾性能和数据安全性，理论上只有在系统突然宕机的情况下丢失1s的数据。</p>

<p> </p>

<p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。<br>
重写后的AOF文件为什么可以变小？有如下原因：<br>
1） 进程内已经超时的数据不再写文件。<br>
2）旧的AOF文件含有无效命令，如del key1、 hdel key2、srem keys、set a 111、set a 222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。<br>
3) 多条写命令可以合并为一个，如lpush list a、lpush list b、 lpush list c 可以转化为：lpush list a b c。为了防止但挑明了过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型曹组，以64个元素为界拆分为多条。 <br>
AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。<br>
AOF重写过程可以手动触发和自动触发：</p>

<p>手动触发：直接调用bgrewriteaof命令</p>

<p>自动触发：更具auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p>

<p>AOF和RDB文件都可以用于服务器重启时的数据恢复。<br>
1） AOF持久化开启且存在AOF文件时，优先加载AOF文件<br>
2） AOF关闭或者AOF文件不存在时，加载RDB文件<br>
3） 加载AOF/RDB文件完成后，Redis启动成功。<br>
4） AOF/RDB文件存在错误时，Redis启动失败并打印错误信息</p>

<p><strong>Redis的事务</strong></p>

<p><strong>    </strong>  可以一次执行多个命令，本质是一组命令的集合，一个事务中的所有命令都会被序列化，按顺序的串行化执行而不会被其他命令插入，不许加塞。</p>

<p>multi：开启事务</p>

<p>exec：执行</p>

<p>discard：放弃事务</p>

<p>watch：监视一个或多个key，如果在事务执行之前这个key被其他命令所改动，那么事务将被打断。</p>

<p>unwatch：取消watch命令对所有key的监控</p>

<p>redis的事务是部分支持，比如出现set  key这样严重错误的语句时，会直接报error，但还是可以继续往队列里添加命令，只是执行的时候所有命令都不会成功执行；但是出现incr key（其中key所对应的value不为数字时），不会报错，执行时只有这条命令不能成功执行。</p>

<p>watch监控：</p>

<p>悲观锁：每次拿数据都认为别人会修改，所以每次拿数据都会上锁。</p>

<p>乐观锁：每次拿数据的时候认为别人不会修改，所以不会上锁，就是在更新的时候会判断在此期间别人有没有修改数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p>

<p>乐观锁策略：提交版本必须大于当前记录版本才能更新。</p>

<p>一旦执行exec之前的监控锁都会被取消。</p>

<p>watch命令类似于乐观锁，事务提交时，如果key的值被别的客户端改变，整个事务队列都不会被执行，通过watch命令在事务执行之前监控了多个keys，倘若在watch之后有任何key的值发生了变化，exec执行的事务都将被放弃。</p>

<p><strong>Redis的发布订阅</strong></p>

<p>subscribe：订阅</p>

<p>publish：发布</p>

<p>mset  k1 v1 k2 v2 k3 v3</p>

<p>subscribe k1 k2 k3</p>

<p>publish k1 qwer</p>

<h3><strong>Redis主从复制</strong></h3>

<p>1.配从（库）不配主（库）</p>

<p>2.从库配置：slaveof  主库ip  主库端口     每次与master断开连接后，都需要重新连接，除非配置进redis.conf文件</p>

<p>3.修改配置文件细节操作</p>

<p>      拷贝多个redis.conf文件、开启daemonize   yes、pid文件名、指定端口、log文件名字、dump.rdb文件名</p>

<p>4.常用</p>

<p>一主二仆</p>

<p>一个master，两个slave，slave只要一连接就会把master所有数据（包括未连接时的数据）都记录下来。</p>

<p>读写分离：只有master可以读写操作，slave只能读不能写。</p>

<p>master挂掉后，slave保留了之前的数据，角色仍是slave，master重新连接后可继续正常工作。</p>

<p>slave挂掉后，重新连接后角色为master，也就没有了之前的数据，需要重新连接，除非配置进redis.conf。</p>

<p> </p>

<p>薪火相传</p>

<p>上一个slave可以是下一个slave的master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master，可以有效减轻master的压力。中途变更转向：会清楚之前的数据，重新建立拷贝最新的。</p>

<p> </p>

<p>反客为主</p>

<p>slaveof no one 使当前数据库停止与其他数据库的同步，角色转为master，会保留之前的数据。</p>

<p> </p>

<p>复制原理</p>

<p>slave启动成功连接到master会发送一个sync命令<br>
Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完成之后，master将传动整个数据文件到slave，以完成一次完全同步操作。<br>
全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。<br>
增量复制：master继续将新的所有收集到的修改命令依次传给slave，完成同步<br>
但是只要是重新连接master，依次完全同步（全量复制）将被自动执行。</p>

<p> </p>

<p><strong>哨兵模式</strong>（反客为主自动版）<br>
反客为主不够智能，需手动将slave转为master并手动将其他slave连接过来，哨兵模式解决了这些问题。</p>

<p>在redis安装目录下新建sentinel.conf文件，添加内容：sentinel  monitor  redis-6379（自己起的数据库名）  127.0.0.1  6379  1。</p>

<p>1表示得票大于一的当master。</p>

<p>运行redis-sentinel   ./redis/sentinel.conf命令    </p>

<p>哨兵会监控6379端口的master，如果这个master挂了，会自动在剩下的slave选出一个转为master并将其他slave连接到新的master，如果挂掉的master重新连接回来，哨兵会将其转为slave连接到新的master。</p>

<p>一组sentinel可以同时监控多个master</p>

<p> </p>

<p>复制的缺点</p>

<p>由于所有的写操作都是现在master上操作，然后同步更新到slave上，所以从master同步到slave上有一定的延迟，当系统繁忙的时候，延迟问题会更加严重，slave机器数量的增加也会使这个问题更加严重。</p>

<p> </p>

<p>Java连接redis</p>

<p>１.修改redis.conf配置文件，将绑定的ip地址端口号给注释</p>

<p>２.由于Linux上的redis处于安全保护模式，这就让你无法从虚拟机外部去轻松建立连接，这里就有两种解决方法，一种是在redis.conf中设置保护模式为no</p>

<p>3.另外一种方式是加上安全认证，即redis默认是没有密码的可以直接登录，修改requirepass添加密码。用jedis的auth方法输入密码。</p>

<p>  Connect  time  out ：systemctl stop firewalld.service    </p>

<p> </p>

<p>   单台机器伪分布式集群：<a href="https://blog.csdn.net/baidu_38558076/article/details/90707045" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/baidu_38558076/article/details/90707045</a></p>

<p>    多机部署redis5.0集群：<a href="https://www.cnblogs.com/Dev0ps/p/10206604.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/Dev0ps/p/10206604.html</a></p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
