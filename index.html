<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="folyjzSrNTxM-gzANuN149Z3GWMMc4Go2VluVGIRh48">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yyguy123.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="yyguy123的个人博客">
<meta property="og:url" content="http://yyguy123.github.io/index.html">
<meta property="og:site_name" content="yyguy123的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yyguy123">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yyguy123.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>yyguy123的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yyguy123的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">若无闲事挂心头，便是人间好时节</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Docker/" class="post-title-link" itemprop="url">Docker</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 19:42:41" itemprop="dateCreated datePublished" datetime="2022-06-25T19:42:41+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-26 19:25:23" itemprop="dateModified" datetime="2021-12-26T19:25:23+08:00">2021-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>Docker是一个开源应用容器引擎，基于Go语言并遵从Apache2.0协议开源。可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux机器上，也可以实现虚拟化。</p>
<h3 id="虚拟化技术和容器技术"><a href="#虚拟化技术和容器技术" class="headerlink" title="虚拟化技术和容器技术"></a>虚拟化技术和容器技术</h3><p>虚拟化技术特点：1、资源占用多 2、冗余步骤多 3、启动慢<br>容器化技术：容器化技术不是模拟的一个完整的操作系统<br>比较Docker和虚拟机的不同：</p>
<ol>
<li><p>传统虚拟机，虚拟出硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</p>
</li>
<li><p>Docker容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟硬件。</p>
</li>
<li><p>每个容器都是互相隔离的，每个容器都有属于自己的文件系统，互不影响。</p>
<p>Docker比虚拟机更少的抽象层，docker利用宿主机的内核，VM需要的是GuestOS，Docker新建一个容器的时候不需要像虚拟机一样重新加载一个操作系统内核。</p>
</li>
</ol>
<h3 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h3><h5 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h5><p>docker镜像好比是一个模板，可以通过这个模板创建容器服务，tomcat镜像 ==&gt;run ==&gt; tomcat01容器（提供服务），通过这个镜像可创建多个容器。</p>
<h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建，目前可以将容器视为一个简单的linux系统</p>
<h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><p>仓库就是存放镜像的地方，分为公有仓库和私有仓库。</p>
<h3 id="Docker容器运行流程"><a href="#Docker容器运行流程" class="headerlink" title="Docker容器运行流程"></a>Docker容器运行流程</h3><p>启动一个容器，run 运行流程：Docker会首先在本地寻找镜像，判断本机是否有这个镜像，有就用这个镜像运行，没有就去DockerHub下载；如果DockerHub找不到此镜像会返回错误，若DockerHub有此镜像就会下载到本地运行。</p>
<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机，通过Socker从客户端访问，Docker Server接收到Docker client指令就会执行这个命令。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>docker images  查看本地主机所有镜像</p>
<p>docker search 搜索镜像</p>
<p>docker pull 镜像名[:tag] 下载镜像</p>
<p>docker rmi -f 镜像id    删除镜像</p>
<p>docker rmi -f $(docker images -aq)</p>
<h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line">--name="名字"    指定容器名字</span><br><span class="line">-d                        后台方式运行</span><br><span class="line">-it                        使用交互方式运行，进入容器内查看内容</span><br><span class="line">-p                        指定容器端口</span><br><span class="line">（-p ip:主机端口:容器端口 配置主机端口映射到容器端口</span><br><span class="line">   -p  主机端口:容器端口</span><br><span class="line">   -p   容器端口）</span><br><span class="line">-P                        随机指定端口</span><br><span class="line"><span class="meta">#</span><span class="bash">docker run -it centos /bin/bash  进入容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">exit</span> 停止并退出容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Ctrl+P+Q   不停止容器退出</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker ps   列出运行过的容器</span></span><br><span class="line">删除容器</span><br><span class="line">docker rm  容器id</span><br><span class="line">docker rm  -f $(docker ps -aq)</span><br><span class="line">docker ps -aq | xargs docker rm</span><br><span class="line">启动和停止容器</span><br><span class="line">docker start 容器id</span><br><span class="line">docker restart 容器id</span><br><span class="line">docker stop  容器id</span><br><span class="line">docker kill 容器id</span><br><span class="line">查看日志</span><br><span class="line">docker logs -tf --tail 10 容器id</span><br><span class="line">docker top  容器id  查看容器中进程信息</span><br><span class="line">docker inspect 容器id 查看容器中元数据</span><br><span class="line">进入当前正在运行的容器</span><br><span class="line">docker exec -it 容器id /bin/bash  进入容器后会开启一个新的终端可以在里面操作</span><br><span class="line">docker attach 容器id           进入容器正在执行的终端，不会启动新进程</span><br><span class="line">拷贝操作</span><br><span class="line">docker cp 容器id:容器内部路径  目的主机路径</span><br><span class="line">docker cp  目的主机路径  容器id:容器内部路径</span><br><span class="line"></span><br><span class="line">Docker容器后台运行(后台运行必须有前台进程)</span><br><span class="line">docker run -dit --name mytomcat tomcat /bin/bash   （-t提供一个伪终端，类似前台进程）</span><br><span class="line"></span><br><span class="line">commit镜像</span><br><span class="line">docker commit -m="提交的描述信息" -a="作者" 容器id 目标镜像名:[tag]</span><br></pre></td></tr></table></figure>

<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>Docker镜像实际上由一层一层的文件系统组成，这种层级的文件系统是UnionFS联合文件系统。</p>
<p>所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新内容时，就会在当前镜像层之上，创建新的镜像层。Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层就是容器层，容器层之下的都叫镜像层。</p>
<h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>容器的持久化和同步操作及荣期间的数据共享。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录</span><br></pre></td></tr></table></figure>

<p>匿名挂载和具名挂载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-v 容器内路径    #匿名挂载</span><br><span class="line">-v 卷名：容器内路径  #具名挂载</span><br><span class="line">-v /宿主机路径：容器内路径  #指定路径挂载</span><br><span class="line"><span class="meta">#</span><span class="bash">匿名挂载</span></span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有volume情况</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta">#</span><span class="bash">具名挂载</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">拓展  ro说明这个路径只能通过宿主机来操作，容器内无法操作   默认rw读写权限</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> --volumes-from 共享数据卷  删除docker01容器不会影响docker02中的数据 （使用inspect查看就会发现文件挂载在宿主机，但是删除docker01数据卷中的文件，宿主机及docker02中都会删除）</span></span><br><span class="line">docker run -it --name docker02 --volumes-from docker01 centos</span><br></pre></td></tr></table></figure>

<p>所有的docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxxx/_data<br>通过具名挂载可以方便的找到我们的卷，大多数情况使用具名挂载</p>
<h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>DockerFile就是用来构建docker镜像的构建文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM              #基础镜像 一切从这里开始构建</span><br><span class="line">MAINTAINER        #镜像是谁写的   姓名+邮箱</span><br><span class="line">RUN               #镜像构建时需要运行的命令</span><br><span class="line">ADD               #添加内容 COPY文件 例如添加tomcat压缩包，会自动解压</span><br><span class="line">WORKDIR           #镜像的工作目录</span><br><span class="line">VOLUME            #挂载的目录</span><br><span class="line">EXPOSE            #指定对外端口</span><br><span class="line">CMD               #指定容器启动的时候要运行的命令   只有最后一个会生效</span><br><span class="line">ENTRYPOINT        #指定容器启动的时候要运行的命令   可以追加命令</span><br><span class="line">ONBUILD           #是一个特殊的指令 它后面跟的是其它命令RUN、COPY等，这些指令在当前镜像被构建时并不会执行，只有以当前镜像为基础镜像去构建下一级镜像时才会被执行</span><br><span class="line">COPY              #类似ADD  将文件拷贝到镜像中</span><br><span class="line">ENV               #构建的时候配置环境变量</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">示例</span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER dh&lt;bean_d@126.com&gt;</span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line">ADD jdk-8u11-linux-x64.tar.gz /usr/local</span><br><span class="line">ADD apache-tomcat-9.0.22.tar.gz /usr/local</span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_11</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINE_HOME /usr/local/apache-tomcat-9.0.22</span><br><span class="line">ENV CATALINE_BASE /usr/local/apache-tomcat-9.0.22</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINE_HOME/lib:$CATALINE_HOME/bin</span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo "---end---"</span><br><span class="line">CMD /bin/bash    #最后一个CMD命令会覆盖之前的CMD</span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh &amp;&amp; tail -f /usr/local/apache-tomcat-9.0.22/bin/logs/catalina.out</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过DockerFile构建镜像  -f指定dockerfile（若文件名为Dockerfile可不加-f指定） -t指定镜像名和标记  .表示根据当前目录下的dockerfile文件生成镜像 --rm表示构建成功后删除中间环节的容器</span></span><br><span class="line">docker build -t /test/demo:latest --rm .  </span><br><span class="line">docker build -f dockerfile文件路径 -t 镜像名:[tag] .</span><br><span class="line"><span class="meta">#</span><span class="bash">docker <span class="built_in">history</span> 镜像id  查看镜像生成过程命令</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">CMD和ENTRYPOINT区别</span></span><br><span class="line">FROM centos</span><br><span class="line">CMD ["ls","-a"]</span><br><span class="line"><span class="meta">#</span><span class="bash">docker run 镜像id -l  追加一个-l 命令会报错  CMD情况下-l替换了CMD [<span class="string">"ls"</span>,<span class="string">"-a"</span>]命令</span></span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT ["ls","-a"]</span><br><span class="line"><span class="meta">#</span><span class="bash">docker run 镜像id -l  追加一个-l  ENTRYPOINT情况下不会报错  相当于ls -al</span></span><br></pre></td></tr></table></figure>

<h5 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login -u 用户名</span><br><span class="line">docker push mytomcat:1.0</span><br></pre></td></tr></table></figure>

<h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><p>我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docekr0桥接模式，使用的技术是veth-pair技术。veth-pair就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连，正因为有这个特性，veth-pair充当一个桥梁，连接各种虚拟设备。容器与容器间是可以互ping通的，所有容器间不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP。只要容器删除，对应网桥就没了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使tomcat03到tomcat02的网络连通（tomcat02到tomcat03是不通的）</span></span><br><span class="line">docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash">--link就是在hosts中添加了配置 现在已经不建议使用这种方式</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker0问题：不支持容器名连接访问</span></span><br></pre></td></tr></table></figure>

<p>自定义网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker network ls   查看所有的docker网络</span></span><br><span class="line">网络模式</span><br><span class="line">bridge：桥接  docker默认</span><br><span class="line">none：不配置网络</span><br><span class="line">host：和宿主机共享网络</span><br><span class="line">container：容器网络连通（用的少）</span><br><span class="line"><span class="meta">#</span><span class="bash">docker run -d -P --name tomcat01 --net bridge tomcat</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet           自定义网络</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker run -d -P --name tomcat-net-01 --net mynet tomcat</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker run -d -P --name tomcat-net-02 --net mynet tomcat</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tomcat-net-01和tomcat-net-02之间可以用ip或容器名访问</span></span><br></pre></td></tr></table></figure>

<p>网络连通</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">示例  打通tomcat01（默认docker0的网络） 到 mynet的网络 (tomcat02还是不通的)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker network connect mynet tomcat01</span></span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Kubernetes/" class="post-title-link" itemprop="url">Kubernetes</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 19:39:18" itemprop="dateCreated datePublished" datetime="2022-06-25T19:39:18+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-31 17:02:53" itemprop="dateModified" datetime="2021-12-31T17:02:53+08:00">2021-12-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><p>高可用集群副本数据最好是 &gt;=3 基数个  方便选举</p>
<p>在K8S中，由Master控制节点和Worker节点共同构成一个集群。</p>
<blockquote>
<p><strong>Master节点</strong>：</p>
<p>API Server：所有服务访问的统一入口，以restful风格进行操作，同时交给etcd存储（是唯一能访问etcd的组件），提供认证、授权、访问控制、API注册与发现等机制，可通过kubectl命令行工具、dashboard可视化面板访问。<br>Controller Manager：维持副本期望数目；处理集群中常规后台任务，一个资源对应一个控制器，同时监控集群状态，确保实际状态和最终状态一致。<br>Scheduler：节点的调度，选择合适的节点进行分配任务<br>etcd：键值对数据库，储存K8S集群所有重要信息（持久化）</p>
<p><strong>Worker节点</strong></p>
<p>Kubelet：直接跟容器引擎交互实现容器的生命周期管理；相当于Master节点派到node节点的代表，管理本机容器，上报数据到API Server。<br>Kube-proxy：负责写入规则至 IPTABLES、IPVS 实现服务映射访问；实现服务（service）抽象组件，屏蔽PodIP变化和负载均衡。<br>Container Runtime：容器运行时。K8S支持多个容器运行环境：Docker、Containerd、CRI-O、Rktlet以及任何实现Kubernetes CRI（容器运行环境接口）的软件。</p>
</blockquote>
<p>CoreDNS：可以为集群中的SVC创建一个域名IP的对应关系解析<br>Dashboard：给K8S集群提供一个B/S结构访问体系<br>Ingress Controller：官方只能实现四层代理，INGRESS可以实现七层代理<br>Federation：提供一个可以跨集群中心多K8S统一管理功能<br>Promethues：提供K8S集群的监控能力<br>ELK：提供K8S集群日志统一分析介入平台</p>
<p><strong>流程样例</strong></p>
<ol>
<li>通过kubectl命令行工具向API Server发送一个请求：创建ReplicaSet（用来确保容器应用的副本数始终保持在用户定义的副本数，支持集合式的selector；虽然ReplicaSet可独立使用，但还是建议使用Deployment来自动管理ReplicaSet，这样无需担心与其他机制不兼容问题，例如ReplicaSet不支持rolling-update但Deployment支持），API Server会将此请求存储在etcd中</li>
<li>Controller Manager会接收到一个通知</li>
<li>Controller Manager发现现在的集群状态和预期状态不一致，因此需要创建Pod，此信息会通知到Scheduler</li>
<li>Scheduler会选择空闲的Worker节点，然后通过API Server更新Pod定义</li>
<li>API Server会通知到Worker节点上的kubelet</li>
<li>kubelet指示当前节点上的Container Runtime运行对应的容器</li>
<li>Container Runtime下载镜像并启动容器</li>
</ol>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>Pod</strong></p>
<ul>
<li>Pod是最小调度单元</li>
<li>Pod里面会包含一个或多个容器（Container）</li>
<li>Pod内的容器共享存储及网络，可通过localhost通信</li>
</ul>
<p><strong>Deployment</strong></p>
<p>Deployment是在Pod这个抽象上更为上层的一个抽象，它可以定义一组Pod的副本数目以及这个Pod的版本。一般大家用Deployment这个抽象来做应用的真正的管理，而Pod是组成Deployment最小的单元</p>
<ul>
<li>定义一组Pod的副本数量、版本等</li>
<li>通过控制器维护Pod数目</li>
<li>自动恢复失败的Pod</li>
<li>通过控制器以指定的策略控制版本</li>
</ul>
<p><strong>Service</strong></p>
<p>Pod是不稳定的，IP是会变化的，所以需要一层抽象来屏蔽这种变化，这层抽象叫做Service</p>
<ul>
<li>提供访问一个或者多个Pod实例稳定的访问地址</li>
<li>支持多种访问方式<ul>
<li>ClusterIP（对集群内部访问）</li>
<li>NodePort（对集群外部访问）</li>
<li>LoadBalancer（集群外部负载均衡）</li>
</ul>
</li>
</ul>
<p><strong>Volume</strong></p>
<p>Volume就是存储卷，在Pod中可以声明卷来访问文件系统，同时Volume也是一个抽象层，其具体的后端存储可以是本地存储、NFS网络存储、云存储、分布式存储</p>
<ul>
<li>声明在Pod中容器可以访问的文件系统</li>
<li>可以被挂载在Pod中一个或多个容器的指定路径下</li>
<li>支持多种后端储存</li>
</ul>
<p><strong>Namespace</strong></p>
<p>Namespace（命名空间）是用来做资源的逻辑隔离的，比如上面的Pod、Deployment、Service都属于资源，不同Namespace下资源可以重名。同一Namespace下资源名需唯一</p>
<ul>
<li>一个集群内部的逻辑隔离机制</li>
<li>每个资源都属于一个NameSpace</li>
<li>同一个Namespace中资源命名唯一</li>
<li>不同Namespace中资源可重名</li>
</ul>
<p><strong>kubectl命令行工具</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl api-resources 显示K8S支持的资源类型</span></span><br><span class="line">NAME                   SHORTNAMES</span><br><span class="line">namespace               ns</span><br><span class="line">nodes                   no</span><br><span class="line">persistentvolumeclaims  pvc</span><br><span class="line">persistentvolumes       pv</span><br><span class="line">pods                    po</span><br><span class="line">statefulsets            sts</span><br><span class="line">services                svc</span><br><span class="line">deployments             deploy</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get pods  等价于   kubectl get po</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl create deployment web --image=nginx:1.14</span></span><br><span class="line">这句话表示创建一个deployment资源，取名叫web，指定镜像为nginx的1.14版本。一般不这么部署应用，不好复用，一般通过yaml文件来部署，如下</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl create deployment web --image=nginx:1.14 --dry-run -o yaml &gt; web.yaml</span></span><br><span class="line">  --dry-run 表示试运行</span><br><span class="line">  -o yaml 表示以yaml格式输出</span><br><span class="line"><span class="meta">  &gt;</span><span class="bash"> web.yaml 表示将输出的内容重定向到web.yaml文件中</span></span><br><span class="line">用下面命令应用web.yaml，web.yaml声明了一个deployment和一个pod</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f web.yaml   默认replicas=1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get deploy,po -o wide  查看Deployment和Pod</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl scale deploy web --replicas=10   扩容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl scale deploy web --replicas=1    缩容</span></span><br></pre></td></tr></table></figure>

<p><strong>节点污点</strong></p>
<p>Taint污点：节点不做普通分配调度，是节点属性，属性值有三个</p>
<ul>
<li>NoSchedule：一定不被调度</li>
<li>PreferNoSchedule：尽量不被调度（有被调度的几率）</li>
<li>NoExecute：不会调度，并且还会驱逐Node已有Pod</li>
</ul>
<p>也就是说，给节点打上污点，那么调度的时候就会根据上面的属性来调度，一般来说Master节点的污点值是NoSchedule</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl describe node my-master | grep Taints  查看my-master污点值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl taint node my-master node-role.kubernetes.io/master:NoSchedule-  去掉my-master节点的NoSchedule污点</span></span><br></pre></td></tr></table></figure>

<p><strong>Pod调度策略</strong></p>
<p>Pod调度策略会影响到Pod最终被调度到哪个节点上，Pod调度策略有三类</p>
<ul>
<li>Pod声明的<em>requests</em>和<em>limits</em>，前者就是Pod需要多少资源，后者表示Pod最多用多少资源（CPU内存等）</li>
<li>节点标签选择器，会选择符合标签的节点进行调度</li>
<li>节点亲和性，分为硬亲和和软亲和，前者必须满足，后者尝试满足，不强制</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl delete deploy web  删除之前部署的deploy</span></span><br></pre></td></tr></table></figure>

<p>web.yaml新增resources声明</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">	<span class="attr">selector:</span></span><br><span class="line">		<span class="attr">matchLabels:</span></span><br><span class="line">			<span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">	<span class="attr">strategy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">	<span class="attr">template:</span></span><br><span class="line">		<span class="attr">metadata:</span></span><br><span class="line">			<span class="attr">labels:</span></span><br><span class="line">				<span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">		<span class="attr">spec:</span></span><br><span class="line">			<span class="attr">containers:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">			<span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">			<span class="comment"># 方式一：secret挂载到容器</span></span><br><span class="line">			<span class="attr">volumeMounts:</span></span><br><span class="line">				<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">				 <span class="attr">mountPath:</span> <span class="string">/etc/secret-volume</span></span><br><span class="line">			<span class="attr">volumes:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">			  <span class="attr">secret:</span></span><br><span class="line">			  	<span class="attr">secretName:</span> <span class="string">test-secret</span></span><br><span class="line">			<span class="comment"># 方式二：环境变量声明secret</span></span><br><span class="line">			<span class="attr">env:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SECRET_USERNAME</span></span><br><span class="line">				<span class="attr">valueFrom:</span></span><br><span class="line">					<span class="attr">secretKeyRef:</span></span><br><span class="line">						<span class="attr">name:</span> <span class="string">test-secret</span></span><br><span class="line">						<span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">			<span class="comment">#requests和limits</span></span><br><span class="line">			<span class="attr">resources:</span></span><br><span class="line">				<span class="attr">requests:</span></span><br><span class="line">					<span class="attr">memory:</span> <span class="string">"3Gi"</span></span><br><span class="line">				<span class="attr">limits:</span></span><br><span class="line">					<span class="attr">memory:</span> <span class="string">"4Gi"</span></span><br><span class="line">			<span class="comment"># nodeSelector</span></span><br><span class="line">			<span class="attr">nodeSelector:</span></span><br><span class="line">				<span class="attr">test123_env:</span> <span class="string">prod</span></span><br><span class="line">			<span class="comment"># 节点亲和性</span></span><br><span class="line">			<span class="attr">affinity:</span></span><br><span class="line">				<span class="attr">nodeAffinity:</span></span><br><span class="line">					<span class="attr">requiredDuringSchedulingIgnoredDuringException:</span></span><br><span class="line">						<span class="attr">nodeSelectorTerms:</span></span><br><span class="line">							<span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">							<span class="bullet">-</span> <span class="attr">key:</span> <span class="string">test123_env</span></span><br><span class="line">							<span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">							<span class="attr">values:</span></span><br><span class="line">							<span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line">							<span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">					<span class="attr">preferreDuringSchedulingIgnoredDuringException:</span></span><br><span class="line">					<span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">					<span class="attr">preference:</span></span><br><span class="line">					<span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">						<span class="bullet">-</span> <span class="attr">key:</span> <span class="string">group</span></span><br><span class="line">						<span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">						<span class="attr">values:</span></span><br><span class="line">						<span class="bullet">-</span> <span class="string">ttttest</span></span><br><span class="line"><span class="attr">status:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f web.yaml  这里虚拟机内存如果就2G，Pod会在挂起状态，因为资源不满足</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除deploy并给master节点打上标签test123_env=prod，标签就是键值对，随便起名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl delete deploy web </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl label node my-master test123_env=prod</span></span><br><span class="line">最后执行理论上所有Pod都应该被调度到master节点，但是发现所有Pod都被挂起了，因为master节点默认污点值是NoSchedule：节点污点值的优先级是高于节点标签的！</span><br><span class="line"><span class="meta">#</span><span class="bash"> requiredDuringSchedulingIgnoredDuringException: 硬亲和，test123_env等于dev或者<span class="built_in">test</span>，必须满足</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> preferreDuringSchedulingIgnoredDuringException: 软亲和，group等于ttttest，非必须满足</span></span><br></pre></td></tr></table></figure>

<h3 id="Secret和配置管理"><a href="#Secret和配置管理" class="headerlink" title="Secret和配置管理"></a>Secret和配置管理</h3><p><strong>Secret</strong></p>
<p>Secret在K8S中表示一个存储在etcd中的配置，这个配置是秘密、安全的，通常用Base64编码，此配置可通过挂载卷或者环境变量的方式供Pod访问。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先将明文转成base64编码</span></span><br><span class="line">echo -n 'root' | base64    结果是cm9vdA==</span><br><span class="line">echo -n '123456' | base64   结果是MTIzNDU2</span><br><span class="line">通过下面secret.yaml声明创建一个Secret</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">	name: test-secret</span><br><span class="line">data:</span><br><span class="line">	username: cm9vdA==</span><br><span class="line">	password: MTIzNDU2</span><br></pre></td></tr></table></figure>

<p>既然是Base64的编码方式（不是加密方式），为什么说Secret是安全的呢？此处的安全是K8S提供的，主要是以下几点：</p>
<ul>
<li>传输安全（K8S中与API Server的交互都是HTTPS的）</li>
<li>存储安全（Secret被挂载到容器时存储在tmpfs中，只存在于内存中而不是磁盘中，Pod销毁Secret随之消失）</li>
<li>访问安全（Pod间的Secret是隔离的，一个Pod不能访问另一个Pod的Secret）</li>
</ul>
<h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>ConfigMap可以看做是不需要加密，不需要安全属性的Secret，也是和配置相关的，创建ConfigMap的过程如下，首先创建一个配置文件例如redis.properties，包含以下内容</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis.port</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">redis.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>以下命令从文件redis.properties创建了一个名为redis-config的ConfigMap</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap redis-config --from-file=redis.properties</span><br></pre></td></tr></table></figure>

<h3 id="存储编排"><a href="#存储编排" class="headerlink" title="存储编排"></a>存储编排</h3><p>PV： PersistentVolume，持久化卷<br>PVC：PersistentVolumeClaim，持久化卷声明</p>
<p>PV说白了就是一层存储的抽象，底层的存储可以是本地磁盘，也可以是网络磁盘比如NFS、Ceph之类。<br>PVC其实在Pod和PV之前又增加了一层抽象，这样做的目的在于将Pod的存储行为与具体的存储设备解耦，试想一下如果哪天NFS网络存储的IP地址变化了，若没有PVC就需要每个Pod改一下IP的声明。</p>
<p><strong>本地存储</strong></p>
<p>本地存储即对应K8S中的hostPath</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 19:39:18" itemprop="dateCreated datePublished" datetime="2022-06-25T19:39:18+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-25 19:38:35" itemprop="dateModified" datetime="2022-06-25T19:38:35+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Spring中bean的生命周期"><a href="#Spring中bean的生命周期" class="headerlink" title="Spring中bean的生命周期"></a>Spring中bean的生命周期</h2><ol>
<li>解析类得到BeanDefinition</li>
<li>如果有多个构造方法，推断构造方法，进而实例化对象</li>
<li>对对象中加了@Autowired注解的属性进行填充</li>
<li>回调Aware方法，例如BeanNameAware（可在运行时获取beanName），BeanFactoryAware（可在运行时获取BeanFactory实例）</li>
<li>调用BeanPostProcessor的初始化前方法</li>
<li>调用初始化方法</li>
<li>调用BeanPostProcessor初始化后的方法，这里会进行AOP</li>
<li>如果当前创建的bean是单例的则会吧bean放入单例池</li>
<li>使用bean</li>
<li>Spring容器关闭时调用DispossableBean中的destory方法</li>
</ol>
<h2 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h2><p>循环依赖在Spring容器中注入依赖的对象，有两种情况：</p>
<p>​    1、构造器方式注入依赖 （无法解决  例如new ServiceA(new ServiceB(new ServiceA(new …)))）</p>
<p>​    2、以set方式注入依赖 ( <font color="red"> spring内部通过3级缓存来解决循环依赖</font>)</p>
<p><font color="red">默认的单例（singleton）的场景是支持循环依赖的，不报错；原型（Prototype）的场景是不支持循环依赖的，会报错</font></p>
<h5 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span></span>&#123;</span><br><span class="line">    <span class="comment">//一级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">//二级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//三级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化：内存中申请一块内存空间</p>
<p>初始化：完成属性的各种赋值</p>
<p>一级缓存singletonObjects：存放的是已经初始化好的bean</p>
<p>二级缓存earlySingletonObjects：存放早期暴露出来的bean对象，已实例化未初始化的bean</p>
<p>三级缓存Map&lt;String,ObjectFactory&lt;&gt;?&gt; singletonFactories，存放可以生成bean的工厂，存放的是FactoryBean，假如A类实现了FactoryBean，那么依赖注入的时候不是A类，而是A类产生的Bean，若要取A类的实例,getBean(“&amp;A的bean id”)</p>
<blockquote>
<p>FactoryBean和BeanFactory区别</p>
<p>BeanFactory是个spring容器中一个顶级接口 ，是IOC容器或者对象工厂，在spring中所有bean都是由BeanFactory管理的，spring容器给了很多实现ClasspathXmlApplicationContext等</p>
<p>FactoryBean是个接口  是一种工厂bean，可以产生bean的bean</p>
</blockquote>
<h4 id="A-B对象在三级缓存中的迁移说明"><a href="#A-B对象在三级缓存中的迁移说明" class="headerlink" title="A/B对象在三级缓存中的迁移说明"></a>A/B对象在三级缓存中的迁移说明</h4><ol>
<li>A创建过程中需要B，于是A将自己放到三级缓存中，去实例化B</li>
<li>B实例化的时候发现需要A，于是B先查一级缓存，没有再查二级缓存，还是没有再查三级缓存，找到A然后把三级缓存中的A放到二级缓存，并删除三级缓存中的A</li>
<li>B顺利初始化完毕，将自己放到一级缓存中（此时B里面的A依然是创建中的状态），然后接着回来创建A，此时B已经创建结束，直接从一级缓存里拿到B，然后完成创建，并将A自己放到一级缓存中。</li>
</ol>
<h3 id="为什么要三级缓存？"><a href="#为什么要三级缓存？" class="headerlink" title="为什么要三级缓存？"></a>为什么要三级缓存？</h3><p>一级、二级缓存用于IOC，三级缓存用于AOP</p>
<h5 id="一级缓存singletonObjects"><a href="#一级缓存singletonObjects" class="headerlink" title="一级缓存singletonObjects"></a>一级缓存singletonObjects</h5><p>实际上，一级缓存已经可以解决循环依赖问题，bean被实例化后即使没有初始化也不影响对象间引用持有；一级缓存关键点在于bean实例化与初始化的分离。</p>
<h5 id="三级缓存-singletonFactories"><a href="#三级缓存-singletonFactories" class="headerlink" title="三级缓存 singletonFactories"></a>三级缓存 singletonFactories</h5><p>仅使用一级缓存根本问题就是我们拿到的是bean的原始引用，如果需要的是bean的代理对象怎么办，spring中充斥着大量动态代理模式的架构，所以，spring在bean实例化后，将原始bean放入三级缓存中，三级缓存中实际存入的是ObjectFactory接口签名的回调实现，如果有动态代理需求，里面可以埋点进行处理，将原始bean包装后返回。通过三级缓存我们可以拿到可能经过包装的对象，解决对象代理封装的问题。</p>
<h5 id="二级缓存earlySingletonObjects"><a href="#二级缓存earlySingletonObjects" class="headerlink" title="二级缓存earlySingletonObjects"></a>二级缓存earlySingletonObjects</h5><p>从软件设计角度考虑，三个缓存代表三种不同职责，根据单一职责原理，从设计角度就需要分离三种职责的缓存。</p>
<p>一级缓存是完整的bean，可以被外界任意使用，不会有歧义。</p>
<p>二级缓存是不完整的bean，没有完成初始化，它与一级缓存的分离主要是职责的分离及边界的划分，可以试想一个Map缓存中既有完整可用的bean，也有不完整的只能持有引用的bean，在复杂度很高的架构中，很容易出现歧义，并带来一些不可预知的错误。</p>
<p>三级缓存其职责就是包装一个bean，有回调逻辑，所以它的作用非常清晰，并且只能处于第三层。</p>
<p>整个使用过程中，要获取一个bean，从一级缓存一直查找到三级缓存，缓存bean的时候是从三级缓存到一级缓存顺序保存，且在缓存过程中，三个缓存是互斥的，只会保持bean在一个缓存中，而且最终都会在一级缓存中。</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>createBean()中的resolveBeforeInstantiation()方法在bean还没实例化前执行，提供bean后置处理器一个返回代理的机会，判断是否需要创建代理，不需要就直接创建bean，否则创建的是代理对象</p>
<p>resolveBeforeInstantiation(beanName,bdbToUse)方法里调用InstantiationAwareBeanPostProcessor这个bean的后置处理器方法，从类名字上看是拦截bean实例化阶段，通过调用postProcessBeforeInstantiation方法生成对象。</p>
<p>我们先来看一般怎么使用Spring AOP的：写一个@Aspect注解的切面类并使用@EnableAspectJAutoProxy注解启用代理，点进去发现它导入了一个AspectJAutoProxyRegistrar到Spring容器中，该类是一个ImportBeanDefinitionRegistrar类，会在解析配置类的时候调用registerBeanDefinitions方法，该方法会向容器中注入一个AnnotationAwareAspectJAutoProxyCreator类的bean定义，AnnotationAwareAspectJAutoProxyCreator是一个InstantiationAwareBeanPostProcessor。</p>
<p>这里就跟上面吻合了，实例化bean时先执行InstantiationAwareBeanPostProcessor，若有返回对象则使用该对象，否则才会去创建实例。所以@EnableAspectJAutoProxy注解的作用就是向容器中添加一个InstantiationAwareBeanPostProcessor类，拦截bean的创建并生成代理对象。postProcessBeforeInstantiation中的createProxy方法点进去可以发现动态代理创建有两种方式，如果该类是接口，则使用jdk动态代理，否则使用cglib动态代理。</p>
<h5 id="为什么JDK动态代理只能代理接口？"><a href="#为什么JDK动态代理只能代理接口？" class="headerlink" title="为什么JDK动态代理只能代理接口？"></a>为什么JDK动态代理只能代理接口？</h5><p>JDK动态代理在创建代理对象时，默认让代理对象继承了Proxy类，java不支持多继承，所以JDK只能通过接口实现动态代理。cglib实现动态代理的逻辑是用子类继承被代理类，没有单继承的限制了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">一些问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 19:10:37" itemprop="dateCreated datePublished" datetime="2022-06-25T19:10:37+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-25 19:09:35" itemprop="dateModified" datetime="2022-06-25T19:09:35+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>同步和异步、阻塞和非阻塞<br>    同步和异步关注的是消息通信机制，<br>    所谓同步，就是在发出调用时没得到结果前该调用就不返回，一旦调用返回就得到返回值<br>    异步：调用发出后就直接返回，没有返回结果；一个异步调用发出后，调用者不会立刻得到结果，被调用者通过状态、通知来通知调用者或者通过回调函数处理这个调用</p>
<pre><code>阻塞和非阻塞关注的是程序在等待调用结果时的状态
阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回
非阻塞调用是指在不能立刻得到结果之前，该调用不会阻塞当前线程
这里阻塞非阻塞和是否同步异步无关</code></pre><p>​<br>NIO由原来的阻塞读写变成了单线程轮询事件，找到可读写的网络描述符进行读写，除了事件轮询是阻塞的，剩余都是纯cpu操作，没必要开启多线程，解决了线程切换问题<br>​    事件分发器，单线程选择就绪事件<br>​    IO处理器，conect\read\write等纯CPU操作，一般开启cpu核心个线程数<br>​    业务线程<br>​    </p>
<p>反射：通过类限定名获取到字节码，将字节码中方法、变量、构造函数映射为对应的Method\Filed\Constructor等类<br>    getMethods获取public的方法（包括父类）<br>    getDeclaredMethods获取当前类声明的所有方法<br>    getDeclaredMethods从缓存或JVM中获取该class声明的方法列表，searchMethods方法从返回的方法列表找到一个匹配名称和参数的方法对象，找到就copy一份返回，每次调用getDeclaredMethods返回的都是新对象；先从reflectionDate中获取declaredMethods，为空就到JVM获取并赋值给reflectionDate</p>
<pre><code>Class.forName 会初始化static块
ClassLoader.loadClass不会执行静态块

JDK动态代理Porxy  InvocationHandler  接口、实现类、代理类    代理类中有实现类的引用 </code></pre><p>cglib动态代理基于asm框架 无反射机制 不需要接口  空间换时间</p>
<p>常见线程池参数：<br>    corePoolSize：核心线程数         corePoolSize = tasks/taskTime<br>    queueCapacity:任务队列容量         queueCapacity = corePoolSize/taskTime  *  respTime<br>    maxPoolSize：最大线程数<br>    keepAliveTIme：线程空闲时间<br>    allowCoreThreadTimeout:是否允许核心线程空闲退出  默认false</p>
<p>常见tomcat参数：<br>内存：<br>    -server  :服务器模式<br>    -Xms    ：java虚拟机初始化最小内存<br>    -Xmx    ：java虚拟机可用最大内存<br>    -Xss    ：每个java线程堆栈大小<br>    -XX:NewSize    :堆区域新生代内存默认大小<br>    -XX:MaxNewSize    :堆区域新生代内存最大可分配大小<br>    -XX:PermSize    :内存永久保留区域<br>    -XX:MaxPermSize    :内存最大永久保留区域<br>    -XX:+UseParNewGC    :对新生代采用多线程并行回收<br>    -XX:BiasedLocking    ：优化线程</p>
<p>并发：<br>    minSpareThreads:初始化时创建的socket连接数<br>    maxSpareThreads:最大空闲socket连接数<br>    maxThreads：客户请求最大线程数<br>    acceptAccount：监听端口队列最大数<br>    enableLookups：是否反查域名  设为false<br>    disableUploadTimeout：是否使用上传超时机制<br>    connectionUploadTimeout：上传超时时间<br>    keepAliveTimeout: 长连接最大保持时间<br>    URIEncoding：指定tomcat容器URL编码格式<br>    connectionTimeout：网络连接超时</p>
<p>工厂模式、策略模式、代理模式、单例模式、装饰类模式</p>
<p>代理：<br>    代理类和目标类实现同一接口，代理类持有目标类引用<br>策略：<br>    配置类配置多种策略类，策略类实现同一接口，context环境类取策略类处理<br>装饰类：<br>    装饰类持有目标类引用，目标类作为参数传入装饰类得到增强<br>单例：<br>    实例化bean后，只暴露一个获取bean的方法<br>工厂：<br>    大量产品需要创建且具有共同接口时使用，一般使用静态工厂</p>
<p>Spring的IOC、AOP<br>IOC：控制反转，将创建对象的控制权交给IOC容器，由主动创建变为被动接收；<br>DI：依赖注入，外部容器动态将依赖对象注入到组件中<br>    注入方式：构造、set、接口注入</p>
<p>bean实例化的几种方式：有参构造、无参构造、静态工厂、实例工厂<br>bean的生命周期：spring容器创建对象、执行init方法、调用自己方法、spring容器关闭时执行destory方法<br>spring加载流程：listener加载配置文件，读取信息到context，context按需动态创建、注入bean,</p>
<p>Spring事务传播机制：<br>    required（默认）：当前无事务就新建一个事务，有就加入那个事务<br>    supports：支持当前事务，若当前无事务就以非事务运行<br>    mandatory：使用当前事务，没有事务抛出异常<br>    requires_new：新建事务，若当前存在事务，把当前事务挂起<br>    not_supported：以非事务运行，存在事务则把当前事务挂起<br>    never：以非事务运行，存在事务则抛异常<br>    nested：存在事务就嵌套在事务内运行，没有则跟required一样</p>
<p>实验：ServiceA中调用serviceB中的方法，在不同传播机制下的表现（以下异常都为插入后进行by/zero运算）<br>                    ServiceA                    ServiceB                            场景<br>Transaction            required                    required                            A、B共用一个事务，有一个异常全部回滚<br>                    required                    requires_new                        B异常AB都回滚，A异常A回滚B提交<br>                    required                    supports                            AB异常都全部回滚<br>                    required                    mandatory                            AB异常都全部回滚<br>                    required                    not_supported                        AB异常都会导致A回滚、B提交<br>                    required                    never                                运行时会抛出存在事务异常<br>                    required                    nested                                AB异常都全部回滚</p>
<pre><code>never/not_supported            required/requires_new/nested        A异常AB都提交，B异常A提交B回滚</code></pre><p>nested和required的区别：required是合并为一个事务，B抛异常就算被A捕获也都会回滚；nested嵌套事务，B异常被A捕获A可以插入B回滚    </p>
<p>spring的事务超时=事务开始时到最后一个statement创建时间 + 最后一个statement执行超时时间<br>isolation事务隔离级别<br>数据库事务隔离级别：Oracle只支持已提交读和串行化，MySQL支持四种：未提交读，已提交读，可重复读，串行化。<br>若spring+oracle，配置隔离级别为Read UnCommited/Repeatable，不起效果。</p>
<p>系统之间交互时事务超时问题：可以不使用事务包裹交互时的操作，将交互前后的数据库操作拆成两个事务<br>并发时事务问题：使用Synchronized修饰的方法也被@Transactional修饰时，可能出现代码执行完了锁被释放但事务正要提交时其他线程进入读取到数据库的数据然后操作，<br>但是之后前一个线程操作提交了，当前线程的操作都是基于旧数据会有问题。</p>
<p>SpringMVC工作流程：<br>    1、用户发送请求到前端控制器DispatcherServlet<br>    2、DispatcherServlet收到请求调用HandlerMapping处理器映射器<br>    3、处理器映射器找到具体处理器（根据xml配置、注解等方式），生成处理器对象及处理器拦截器（如果有则生成）返回给DispatcherServlet<br>    4、DispatcherServlet调用HandlerAdapter处理器适配器<br>    5、HandlerAdapter经过适配调用具体处理器（Controller）<br>    6、Controller执行完返回ModelAndView<br>    7、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet<br>    8、DispatcherServlet将ModelAndView传给ViewResolver视图解析器<br>    9、ViewResolver解析后返回具体view<br>    10、DispatcherServlet根据view进行渲染视图（将模型数据填充至视图）<br>    11、DispatcherServlet响应用户</p>
<p>Java8新特性<br>    1、Lambda表达式，增加函数式接口概念（），在可以使用Lambda表达式的地方，方法声明时必须包含一个函数式接口，任何函数式接口都可被Lambda表达式替换。如Comparator<br>    2、新的日期API，原API非线程安全、时区处理麻烦；新的java.time包涵盖了所有处理日期的操作<br>    3、optional，不用显式进行空值检测<br>    4、构造器和方法引用<br>    5、接口新增默认方法<br>    6、Stream流式操作</p>
<p>​    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Zookeeper/" class="post-title-link" itemprop="url">Zookeeper</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 19:10:37" itemprop="dateCreated datePublished" datetime="2022-06-25T19:10:37+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-25 19:26:19" itemprop="dateModified" datetime="2022-06-25T19:26:19+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Zookeeper=文件系统+监听通知机制</p>
<p>文件系统： 节点可以存储数据  1M<br>监听通知机制： 客户端注册监听节点，节点发生变化（节点数据改变、被删除、子目录节点增加和删除）时，Zookeeper会通知客户端</p>
<p>zookeeper四种数据节点</p>
<p>persistent–持久化节点<br>  客户端与zookeeper断开连接后 该节点依然存在<br>persitent_sequential 持久有序节点<br>  客户端与zookeeper断开连接后，该节点依旧存在，只是zookeeper给该节点名称进行顺序编号<br>ephemeral–临时节点<br>  客户端与zookeeper断开连接后 该节点被删除<br>ephemeral_sequential 临时有序节点<br>  客户端与zookeeper断开连接后 该节点被删除 只是zookeeper给该节点名称进行顺序编号</p>
<p>利用临时节点即可实现分布式锁   独占锁<br>开始–&gt;创建临时节点/lock –&gt; 创建失败则监听/lock节点并等待;创建成功则获取锁，执行完逻辑然后删除/lock，释放锁，此事件就会被监听到并再次尝试创建临时节点;<br>上面的操作删除节点的同时会通知所有客户端<br>可使用临时有序节点优化：   时序锁<br>开始–&gt;在/locks下创建临时有序节点–&gt;获取/locks下所有子节点–&gt;将子节点按序由小到大排序–&gt;当前节点序号是否最小？<br>不是则阻塞，监听比自己序号小1的节点的删除事件;是则获取锁，执行完逻辑后删除节点释放锁，此事件就会被监听到并重复“获取/locks下所有子节点。。。”等系列操作；</p>
<p>zookeeper作为分布式锁的优缺点：<br>  优点：不依靠超时时间释放锁，可靠性高<br>  缺点：性能略低  因为要频繁创建删除节点</p>
<h5 id="Zookeeper选举投票机制"><a href="#Zookeeper选举投票机制" class="headerlink" title="Zookeeper选举投票机制"></a>Zookeeper选举投票机制</h5><ol>
<li>只有启动了的zk节点才能参与投票</li>
<li>每个zk服务启动时，接受一轮对自己的投票</li>
<li>leader角色决策条件，当启动后，如果自身接受投票数超过zk集群节点个数的一半，立刻变为leader</li>
<li>投票操作需要竞争，myid编号-权重</li>
</ol>
<p>流程：</p>
<ol>
<li>启动zk21：接受投票，集群中只有zk21，有1票投给自己</li>
<li>启动zk22：接受投票，自己投给自己，zk21投给自己，通过myid竞争得1票，共2票</li>
<li>启动zk23：自己投自己，通过myid竞争 zk21，zk22投给zk23，共3票，票数过半晋升为leader</li>
<li>启动zk24：已存在leader 只能为follower</li>
<li>启动zk25：已存在leader 只能为follower</li>
</ol>
<p>决定最终leader因素： myid权重 + 启动顺序</p>
<p>重新选举：先比较zxid（事务ID）再比较myid，票数过半及晋升为leader</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/xxl-job/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/xxl-job/" class="post-title-link" itemprop="url">xxl-job</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 19:10:37" itemprop="dateCreated datePublished" datetime="2022-06-25T19:10:37+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-25 19:27:13" itemprop="dateModified" datetime="2022-06-25T19:27:13+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原生定时任务框架先天缺陷：<br> 1、不支持分片任务：处理有序数据时，多机器分片执行任务处理不同数据<br> 2、不支持生命周期统一管理：不重启服务情况下关闭、启动任务<br> 3、不支持集群：存在任务重复执行问题<br> 4、不支持失败重试：出现异常后任务终结、不能根据任务状态控制任务重新执行<br> 5、不支持动态调整：不重启服务的情况下修改任务参数<br> 6、无报警机制：任务失败后没有报警机制<br> 7、任务数据统计难以统计：任务数据量大时，对于任务执行情况无法高效的统计执行情况</p>
<p>xxl-job<br>   调度器、触发器、通讯<br>   执行器、通讯</p>
<p>运行模式一般选bean模式  其他GLUE是直接使用当前调度器作为执行器解析输入的源代码去执行</p>
<p>分片任务：<br>   路由策略选分片广播，输入参数，代码获取参数识别自己要从哪执行</p>
<p>执行器自动注册会有心跳保活，手动录入不会有心跳保活了；手动录入要慎重选择路由策略，例如路由策略为 第一个 时，手动录入的第一台机器挂了任务会执行失败</p>
<p>appName相同为同一个执行器组</p>
<p>为避免多个服务器同时调度任务，通过mysql悲观锁实现分布式锁（for update语句）<br>admin启动：<br>    查询自动注册的执行器，移除90s内没注册的，每30s检查一次<br>    失败任务监测，根据对应设置进行告警、重试操作</p>
<p>XxljobDynamicScheduler初始化时：<br>  JobRegistryMonitor.getInstance.start();//调度中心注册守护线程  维持和执行器间的心跳<br>  JobFaileMonitorHelper.getInstance.start();//任务失败处理的守护线程<br>  NetComServerFactory.putService(Admin.class,XxljobDynamicScheduler.adminBiz);//初始化本地调度中心服务<br>  NetComServerFactory.setAccessToken(accessToken);<br>  initI18n();//国际化</p>
<p>1、JobRegistryMonitor.getInstance.start();<br>   开启一个单独线程，每30s轮训数据库，如果某个执行器的注册信号在近90s没有写入数据库表xxl_job_qrtz_trigger_registry，那么调度中心认为该执行器已死，<br>会更新数据库表xxl_job_qrtz_trigger_group，使每个执行器组只保留活着的执行器，这里的执行器按调度中心来区分的。每个执行器组都有一个唯一的appName，<br>执行器向调度中心注册时就是通过这个appName标志来区分属于哪个执行器组</p>
<p>2、JobFaileMonitorHelper.getInstance.start();<br>   每隔10s执行一下逻辑。数据库表xxl_job_qrtz_trigger_log里存着每个任务每次的执行记录，这里面记录着任务执行状态，若某条任务状态码为500，<br>那么这条执行记录是以失败告终的。那么失败守护线程就会根据这个任务的executorFailRetryCount（失败重试次数，前端新增任务时配置）是否大于0，若大于0，<br>会尝试再执行下这个任务，并相应的在数据库该条执行日志将executorFailRetryCount值减一，最后发出失败告警。</p>
<p>3、初始化本地调度中心的服务Map一级accessToken值，调度中心实例用HashMap对象存了起来。<br>4、国际化，支持中英文</p>
<p>如何触发：<br>timewheel时间轮 本质是Map&lt;Integer,List&gt;<br>触发算法：<br>JobScheduleHelper<br> scheduleThread死循环 首先利用for update进行获取任务的资格锁定 再拿到距now 5s内的任务列表数据：scheduleList 分三中情况处理：<br> for循环遍历scheduleList集合<br> 1、当前任务触发时间超时5s以上（任务下一次触发时间+5s &lt; now）：直接跳过不执行，重置trigger_next_time<br> 2、（任务下一次触发时间&lt; now &lt;= 下一次触发时间+5s）：线程执行触发逻辑，若任务下一次触发时间在5s内，<br> 则放到时间轮内（Map&lt;Integer,List&gt;秒数(0-59)=&gt;任务id列表），再重置trigger_next_time<br> 3、（now &lt;= 任务下一次触发时间）：对触发时间秒数进行60取模直接放到时间轮内，重置trigger_next_time</p>
<p> ringData的处理逻辑在第二个守护线程ringThread中<br>  ringThread死循环 取当前秒数刻度和前一个刻度，在ringData中获取要执行的任务</p>
<p>不管是scheduleThread还是ringThread，最后完成任务调度的都是JobTriggerPoolHelper，此类有两个线程池fastTriggerPool和slowTriggerPool<br>调度线程池隔离，拆分为fast和slow，1分钟窗口期内任务耗时达500ms超过10次，该窗口期内判定为慢任务，慢任务自动降级进入slow线程池，避免耗尽调度线程，提高系统稳定性<br>triggerPool.execute{<br>  …<br>  XxlJobTrigger.trigger —-&gt; processTrigger—&gt; runExecutor –&gt; XxljobScheduler.getExecutorBiz这里的executorBiz是XxlRpcReference.getObject()获取到的代理类<br>  executorBiz.run 此处执行的就是XxlRpcReference的invoke方法 发起远程调用<br>  …<br>  }</p>
<p>执行器：<br>    XxlJobExecutorApplication –&gt; XxlJobSpringExecutor(其中adminAddress为调度中心地址) 实现了ApplicationContextAware保存上下文信息–&gt; start<br>–&gt; 调用本类私有方法取出JobHandler实现类，再调用registJobHandler(name,handler)进行注册  维护了一个Map –&gt;调用父类start方法 大部分业务逻辑在此处理<br>–&gt; 日志处理器初始化、向adminBizList字段中放入XxlRpcReferenceBean返回的代理类、任务日志清除、任务结果回调处理线程、启动XxlRpcProviderFactory</p>
<p>XxlRpcProviderFactory 可以返回Rpc调用服务提供端的工厂类，启动了一个以netty作为通讯模型，hessian作为序列化方式的，ExecutorServiceRegistry作为注册逻辑<br>实现类的服务提供端，接着我们向其添加一个服务ExecutorBiz，处理请求的实现类为ExecutorBizImpl 调用start完成执行器端的服务暴露， ExecutorServiceRegistry<br>调用其start 以30s的间隔和调度中心进行心跳通知，然后调用server的start方法 此时server为NettyHttpServer<br>整个代码结构就是用netty启动了个服务， ChannelHandler，NettyHttpServerHandler 调用私有方法process 这里调用了xxlRpcProviderFactory的invokeService方法完成<br>服务实现的反射调用</p>
<p>ExecutorBizImpl<br>XxlJobExecutor内部会有个以jobId为key，执行这个任务的线程为value的字段jobThreadRepository，我们首先去尝试获取当前正在执行这个任务的线程，<br>如果有就根据任务设置的运行模式进行处理，如果没有正在执行此任务的线程，就调用XxlJobExecutor.registJobThread启动一个线程，最后将任务数据推送给这个可能<br>是从jobThreadRepository获取到的也可能是新创建的线程  JobThread的run方法会从triggerQueue里poll出任务，然后用之前设置的handler进行execute方法调用并利用<br>idleTimes字段进行无任务空转的次数控制，至此执行器完成了启动，暴露ExecutorBiz服务，接收任务调度数据TriggerParam并在JobThread线程中完成任务配置的业务<br>handler的执行</p>
<p>轮询：不能按机器性能充分利用资源<br>权重：可按机器性能分配任务<br>一致性hash：整个空间按顺时针方向组织，圆环上的点从0到2的32次方，将各个服务器使用hash进行哈希，具体可选服务器IP或主机名，确定服务器在哈希环的位置，将<br>数据key使用相同的hash计算出哈希值，从此位置顺时针第一台遇到的服务器就是其该定位到的服务器。使用虚拟节点避免数据倾斜问题。<br>实际应用通常将虚拟节点数设为32甚至更大。  TreeMap<br>LRU：最近最少使用，淘汰最长时间未被使用的    看最后一次被使用到发生调度的时间长短<br>LFU：最少访问算法，淘汰一定时间内访问次数最少的  看一定时间段内被使用的频率</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Sql%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Sql%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Sql优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-21 11:21:56" itemprop="dateModified" datetime="2020-12-21T11:21:56+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数据库sql优化：<br>    1、避免全表扫描，应考虑在where和order by后的字段建立索引<br>    2、尽量避免在where子句中对字段进行null值判断，否则会放弃索引使用全表扫描<br>    3、尽量避免在where子句使用！= 或 &lt;&gt; 否则会放弃索引使用全表扫描<br>    4、尽量避免在where子句使用or来连接，否则会放弃索引使用全表扫描，可使用union all<br>    5、in和not in要慎用，否则会放弃索引使用全表扫描，连续的值推荐使用between<br>    6、通配符（%）不要放在索引字段词首，否则会放弃索引使用全表扫描<br>    7、尽量避免在where子句对字段进行函数操作。否则会放弃索引使用全表扫描<br>    8、尽量避免在where子句对字段进行表达式操作，否则会放弃索引使用全表扫描<br>    9、不要在where子句“=”左边进行函数或其他运算，否则可能会导致系统无法正确使用索引<br>    10、若使用索引字段为条件，且该索引为复合索引，那么必须使用到该索引中第一个字段作为索引条件时才能保证系统使用该索引，并应尽可能让字段顺序与索引顺序一致<br>    11、并非所有索引都对查询有效，当索引列有大量数据重复时，sql可能不会去利用索引<br>    12、索引不是越多越好，提高select效率，降低了insert、update效率，因为insert/update可能会重建索引，一个表索引最好不超过6个<br>    13、一般char比varchar2效率高，但varchar2更节省空间，在节省很多空间情况下varchar2效率更高；含中文字符用nchar/nvarchar2,纯英文和数字用char/varchar2<br>    14、尽可能使用varchar代替char，节省空间<br>    15、不要使用select * from  t，解析时会将<em>转化为列名，降低效率<br>    16、避免频繁创建删除临时表<br>    17、避免大事务操作<br>    18、尽量避免向客户端返回大数据量<br>    19、新建临时表数据量量很大时采用select into代替create table 避免大量log<br>    20、多表查询时数据量少的表放在后面，因为oracle解析器按照从右到左的顺序处理from后的表名<br>    21、一般count（一个索引字段）&gt;count（</em>）&gt;count（一个非索引字段）<br>    22、IN和EXISTS<br>        IN：子查询先产生结果集  select * form tableA where x in (select y from tableB); 适合tableB记录少，tableA记录多且有索引的情况<br>        EXISTS：先主查询    select * from tableA where exists(select * from tableB b where b.id=a.id) 适合tableA记录少，tableB记录多且有索引的情况<br>    23、decode：避免重复扫描相同记录<br>        decode(k ,v1, v2 ,v3): 当k值为v1时返回v2 否则返回v3<br>        decode(k,v1,v2,v3,v4): 当k值为v1时返回v2，为v3时返回v4<br>    24、高效删除重复记录： delete from emp e where e.rowid &gt; (select min(m.rowid) from emp m where m.emp_no=e.emp_no);</p>
<pre><code>explain plan for &lt;sql&gt;

ID：序号，不是执行先后顺序，执行先后根据缩进判断
operation：操作内容
rows：估计当前操作返回的结果集
cost：sql执行代价
time：估计当前操作时间
Access：通过某种方式定位了需要的数据，表示这个谓词条件的值将会影响数据访问路径
filter：把所有数据访问了，过滤不需要的，表示谓词条件的值不会影响数据访问路径</code></pre><p>truncate和delete<br>truncate table 表名 速度快效率高；功能上与不带where的deete相同，truncate不能带条件<br>对于有外键的表不能用truncate而应使用delete，truncate不能用于参与了索引视图的表<br>若有rollback，delete会被撤销truncate不会。</p>
<p>数据库范式<br>    第一范式：1、列不可再分 2、同一列中不可有多个值 3、不可有重复的列<br>    第二范式：1、满足第一范式 2、没有部分函数依赖<br>    第三范式：1、满足第二范式 2、没有传递依赖</p>
<p>尽量不要用外键，极大影响性能；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Sharding-Sphere/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Sharding-Sphere/" class="post-title-link" itemprop="url">Sharding-Sphere</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-01 17:44:19" itemprop="dateModified" datetime="2021-01-01T17:44:19+08:00">2021-01-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么要分库分表：<br>    业务越开越大，单表数据超出数据库支持的容量；持久化磁盘IO，传统的数据库性能瓶颈<br>    1、换数据库（缓存）<br>    2、Sql、索引、字段优化<br>    3、读写分离（业务有关优化）<br>    4、分库分表（业务）<br>    5、分区<br>读写分离：我们应用程序访问数据库无非是CRUD   分开 –&gt;分库  前提条件： master -&gt;slave 主从同步架构  一般用于读多写少</p>
<p>分库分表方式： 垂直/水平<br>垂直：<br>    通俗说法叫大表拆小表，拆分是基于关系型数据库中的列（字段）进行的<br>    特点：1、每个库（表）的结构都不一样<br>          2、每个库（表）的数据至少有一列一样<br>          3、每个库（表）的并集是全量数据<br>    优点：拆分后业务逻辑清晰（专库专用按业务拆分）<br>          实现动静分离、冷热数据分离设计体现  冷库：发布说说信息  热库：说说点赞和评论信息<br>          数据维护简单，按业务不同业务放到不同机器<br>    缺点：如果单表数据量大，读写压力大<br>          受某种业务来决定或限制，一个业务往往会影响到数据库瓶颈<br>          部分业务无法关联join，只能通过java程序，提高了开发复杂度</p>
<p>水平：<br>    以某个字段按照一定规律（取模）将一个表的数据分到多个库中<br>    特点：1、每个库（表）的结构都一样<br>          2、每个库（表）的数据都不一样<br>          3、每个库（表）的并集是全量数据<br>    优点：单库（表）的数据保持在一定量，有助于性能提高<br>          提高了系统的稳定性和负载能力<br>          切分的表的结构相同，程序改造较少<br>    缺点：数据的扩容很有难度维护量大<br>          拆分规则很难抽象出来<br>          分片事务的一致性问题部分业务无法关联join，只能通过java程序</p>
<p>读写分离：主从同步、数据一致性、网络延迟的问题<br>分库分表：增加维护成本、分布式事务（跨库事务）、跨库join、分布式全局唯一id等问题</p>
<p>分库分表算法：<br>    取模（Hash）：通过userid进行123%3=xxx 数据分散均衡 但是扩容时间复杂度为O(N)<br>            一致性Hash：假设某个哈希函数H的值空间为0-2^32 -1，整个空间按顺时针方向组织，0和2^32 -1在零点方向重合，下一步将各个服务器使用Hash，具体可<br>            选择服务器ip或主机名，确定其在哈希环上的位置，将数据key使用相同的函数hash计算出哈希值，从此位置顺时针行走，第一台遇到的服务器就是其应该<br>            定位到的服务器。<br>            一致性哈希算法对于节点的增减都只需重定位环空间中一小部分数据，具有较好的容错性和扩展性。<br>            另外，一致性哈希算法在节点过少时，容易因节点分布不均导致数据倾斜问题，为解决这种问题，一致性哈希算法引入虚拟节点机制，对每一个节点计算多<br>            个hash，每个计算结果位置都放置一个此服务节点。 实际应用中通常将虚拟节点数设为32甚至更大。<br>    范围区分（range）：例如 按月、按省     会有热点数据问题<br>    预定义（list）：预计数据量，先设计好分多少库  （100W-1亿数据  10库）</p>
<p>常见中间件：sharding-sphere、atlas<br>Proxy代理：mycat（重）、mysql-proxy、atlas、sharding-proxy（sharding-sphere）<br>        连接请求发给代理，由代理选择连接数据库<br>JDBC直连：TDDL（淘宝  半开源）、sharding-jdbc（sharding-sphere）<br>        在应用层选择连接的数据库</p>
<p>Sharding-Sphere：<br>    LogicTable逻辑表：数据分片的逻辑表，对于水平拆分的数据（库）表，同一类表的总称  例如t_order_0、t_order_1逻辑表为t_order<br>    ActualTable真实表：在分片的数据库中真实存在的物理表，如t_order_0、t_order_1<br>    DataNode数据节点表：数据分片的最小单元，由数据源名称和数据表组成。例：ds_1.t_order_0，配置时默认各个分片数据库的表结构均相同，<br>        直接配置逻辑表和真实表对应关系即可，如果各数据库表结构不同，可使用ds.actual_table配置<br>    BindingTable绑定表：指在任何场景下分片规则均一致的主表和字表。例如订单表和订单项表。BindingTable关系的多表关联查询不会出现笛卡尔积关联，<br>        关联查询效率大大提升<br>    ShardingColumn分片字段：用于将数据库（表）水平拆分的关键字段，例如订单表订单ID取模分片，则订单ID为分片字段，SQL中若无分片字段将执行全路由，性能较差<br>        Sharding-JDBC支持多分片字段<br>    BroadcastTable广播表：指所有分片数据源中都存在的表，表结构和表中数据在每个数据库中完全一致，适用于数据量不大但需要与海量数据表关联查询的场景，<br>        例如字典表<br>    LogicIndex逻辑索引：某些数据库（如PostgreSQL）不允许同一个库存在名称相同的索引，某些数据库（如Mysql）则允许只要同一个表中不存在名称相同的索引即可。<br>        逻辑索引用于同一个库不允许出现相同索引名称的分表场景，需要将同库不同表的索引名称改写为索引名+表名，改写之前的索引名称为逻辑索引</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-21 11:21:56" itemprop="dateModified" datetime="2020-12-21T11:21:56+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis：<br>    数据结构：<br>        String:<br>            set k1 qwer ,   get k1<br>            del k1<br>            append k1 123 (qwer123)<br>            incr/decr/incrby/decrby  必须是数字<br>            getrange/setrange   getrange k1 0 2 (qwe)<br>            setex 设置过期时间 setex k2 10 v2<br>            setnx    不存在就set成功，存在就返回0<br>            mset/mget/msetnx</p>
<pre><code>    List:
        rpush mylist 1 2 3 4 5          rpush list 1 2 3
        lpush rpush lpop rpop
        lrem key n val 删除n个val
        ltrim key start end 截取指定范围值赋给key
        rpoplpush mylist list   (5123)
        lset key index value  
        linsert key before/after v1 v2 在v1前/后 插入v2

    Set：
        sadd、smembers、sismember
        scard 获取元素个数
        srem key val 
        srandmember key n 随机列出n个元素
        spop key 随机出栈
        smove k1 k2 v1 将k1的值v1给k2
        sdiff k1 k2 在k1不在k2的元素
        sinter k1 k2 : k1 k2的交集
        sunion k1 k2 : 并集

    Hash：
        kv模式不变 v为键值对
        hmset customer id 1 name zz age 20、 hmget customer id name age
        hgetall customer
        hdel 
        hlen
        hexists customer id
        hkeys、hvals
        hsetnx

    Zset
        zadd zset01 60 v1 70 v2 80 v3
        zscore key val 
        zrank key val
        zrevrank key val


Maxmemory-policy：
    volatile-lru：使用LRU算法移除key 只对设置了过期时间的key
    allkeys-lru：使用LRU算法移除key
    volatile-random：在过期集合中移除随机的key
    allkeys-random：移除随机的key
    volatile-ttl：移除ttl值最小的key，即最近要过期的key
    noeviction：不进行移除，针对写操作，只返回错误信息


持久化机制：
    RDB：
        手动触发：    
            save:阻塞当前redis服务器直到RDB过程完成，线上环境一般不使用
            bgsave：redis进程执行fork操作创建子进程，持久化由子进程负责，阻塞只发生在fork阶段，一般使用bgsave
        自动触发：
            1、使用save相关配置   save m n 表示m秒内数据集存在n次修改时，自动触发bgsave
            2、从节点执行全量复制操作时主节点自动执行bgsave生成RDB文件发送给从节点
            3、执行debug reload重新加载redis时也会触发save操作
            4、默认执行shutdown时，若没开启AOF则自动执行bgsave
        优点：是一个紧凑的二进制文件，代表redis在某一个时间点上的数据快照，非常适合用于备份、全量复制等，redis加载RDB文件远远快于AOF方式
        缺点：RDB没法做到秒级持久化，因为bgsave每次运行需要fork创建子进程，属于重量级操作；redis演进过程中有多个格式的RDB版本

    AOF：
        以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令；目前是redis主流持久化方式
        开启AOF需设置 appendonly yes   默认不开启 AOF文件通过appendfilename配置设置  默认文件名为appendonly.aof 保存路径与RDB持久化方式一致 通过dir配置
    流程：
        1、命令写入缓冲区
        2、缓冲区根据对应策略向硬盘做同步操作
        3、随着AOF文件变大，需定期重写AOF文件  达到压缩的目的
        4、当redis重启时 加载AOF文件恢复数据

    为什么命令追加到缓冲区？
    reids使用单线程响应，若每次写AOF文件命令都直接追加到硬盘，性能就取决于硬盘负载，先写入缓冲区，reids可提供多种缓冲区同步硬盘策略

    随着命令不断写入，AOF文件越来越大，为解决这个问题redis引入AOF重写机制压缩文件
    1、进程内已超时的文件不会再写文件
    2、旧的AOF文件包含无效命令，如del k1 ,set a 111 ,set a 222等
    3、多条命令合并  如 lpush list a,lpush list b,  lpush list a b

    AOF持久化开启且存在AOF文件时优先加载AOF，否则加载RDB；加载完成后redis启动成功，AOF/RDB存在错误 redis启动失败

Redis事务：
    可一次执行多个命令，本质是一组命令的集合，一个事务中命令被序列化
    multi：开启事务
    exec：执行
    discard：放弃事务
    watch：监视一个或多个key  此key被改动事务被打断   （类似乐观锁）
    unwatch：取消watch对所有key的监控

    redis的事务是部分支持；出现set key这样严重错误时会直接报error但还是可以继续往队列添加命令，只是所有命令都不会成功执行，但是出现incr key（其中key所对应value不为数字时），不会报错，执行时只有这条命令不会成功执行


Redis主从复制：
    1、配从不配主
    2、从库配置：slaveof 主库ip 主库端口  每次与master断开连接后都需重新连接，除非配置进redis.conf文件

    常用：
        一主二仆：一个master两个slave  slave只要一连接就会把master所有数据都记录
                读写分离：只有master能读写，slave只能读不能写
                master挂掉后slave保留之前数据，角色仍是slave，master重新连接后可继续正常工作
                slave挂掉后重新连接后角色为master，也就没有之前的数据了，需重新连接，除非配置进redis.conf文件

        薪火相传：上一个slave可以是下一个slave的master，slave同样可以接受其他slave的连接和同步请求，那么该slave作为链条中下一个的master可有效减轻master的压力；中途变更转向：会清除之前数据，重新拷贝最新的

        反客为主：slaveof no one 使当前数据库停止与其他数据库的同步，角色转为master保留之前的数据


    哨兵模式：
        反客为主需手动将slave转为master  在 sentinel.conf添加 sentinel monitor redis-6379(自己起的数据库名) 127.0.0.1 6379 1
        会监控6379端口的master，master挂了会在剩下slave自动选出一个转为master并将其他slave连接到新的master，若挂掉的master重新连接会被转为slave连接到新的master</code></pre><p>一些常见问题</p>
<pre><code>缓存雪崩：高并发下某一时间同时生成很多缓存并且过期时间在同一时刻
    解决：将缓存失效的时间分散开，在原有失效时间上增加随机值

缓存穿透：查询一个一定不存在的数据导致一直请求DB
    解决：1、若查询一个key不存在则以空结果进行缓存，设置过期时间短一点（几分钟）
          2、布隆过滤器(可看成一个bit数组，映射一个值到布隆过滤器需要使用多个不同的hash函数生成多个hash值，检查某个值对应的多个bit位上的值均为1只能说明可能存在而不是一定存在)

缓存击穿：一个存在的key在过期的同一刻有大量请求
    解决：访问key之前采用setnx设置一个短期key锁住当前key的访问

缓存并发：一个缓存若失效可能多个进程同时查DB同时设置缓存
    解决：对缓存查询加锁，key不存在就加锁，然后查DB入缓存 解锁

热点key：缓存中某些key存储在集群中同一台机器，所有流量涌向同一台机器
    解决：将热点key缓存到本地并设置失效时间，每次请求先检查key是否在本地，不存在再访问缓存机器

Redis是单线程还是多线程？
    Redis中IO多路复用器模块是单线程执行，时间处理器也是单线程执行，两个线程不一样，依靠队列保证顺序；不会上下文切换
    单线程只是针对redis中的模块来说，比如接收请求和响应是单线程，处理事件也是单线程，但是不是同一个。</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Nginx/" class="post-title-link" itemprop="url">Nginx</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-21 11:21:56" itemprop="dateModified" datetime="2020-12-21T11:21:56+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Nginx：<br>    负载均衡算法：<br>        1、Random随机算法：最简单的随机算法；缺点：数量足够大时才能保证均匀分配<br>        2、Round Robin轮询算法：依次转发；缺点：集群中服务器硬件配置不同无法区别对待<br>        3、随机轮询：随机选择一个节点开始依次轮询<br>        4、加权轮询：为了解决简单轮询的不足。（Nginx默认负载均衡算法）<br>            一般算法可能为：<br>                1、轮询所有节点找到最大权重节点<br>                2、选中节点权重减1<br>                3、直到减到0，恢复节点原始权重，继续轮询<br>            Nginx加权轮询：<br>                weight：约定权重， effectiveWeight：有效权重 初始为weight 调用成功+1  异常-1   currentWeight：当前权重 初始为0<br>                1、轮询所有节点，计算当前所有节点effectiveWeight之和totalWeight<br>                2、currentWeight = currentWeight + effectiveWeight 选中所有节点中currentWeight最大的节点<br>                3、选中节点的 currentWeight = currentWeight - totalWeight<br>        5、加权随机：按权重随机选取服务器<br>        6、最少连接：记录每台服务器正在处理的连接数，将新来请求转发到连接最少的那台<br>        7、Latebcy-Aware：动态选择最低延迟的节点处理当前请求<br>        8、源地址散列：根据源ip进行hash</p>
<p>正向代理（客户端对于服务端来说不可见）：<br>    客户端向代理服务器发送请求并指定目标服务器，代理向目标服务器转交并将获得内容返回给客户端</p>
<p>反向代理（服务端对客户端不可见）：<br>    客户端向反向代理发送请求，反向代理内部自动根据访问内容进行跳转和返回</p>
<p>负载均衡：<br>http {<br>    //负载均衡<br>    upstream  test.com{<br>        server 192.168.196.10:80 weight=10;<br>        server 192.168.196.11:80 weight=5;<br>    }</p>
<pre><code>upstream  platform-login{
    ip_hash;
    server 192.168.196.12:80;
    server 192.168.196.13:80;
}

server { 
    listen 80;
    server_name 192.168.10.112
    location / {
        xxx
    }
    //反向代理
    location /platform-login/ {
        proxy_pass http://platform-login;
    }

    location /test.com/ {
        proxy_pass http://test.com;
    }
}</code></pre><p>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yyguy123" src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">yyguy123</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yyguy123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yyguy123" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yyguy123@gmail.com" title="E-Mail → mailto:yyguy123@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yyguy123</span>
</div>
  
  <div>
      <span>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
