<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="folyjzSrNTxM-gzANuN149Z3GWMMc4Go2VluVGIRh48">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yyguy123.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="yyguy123的个人博客">
<meta property="og:url" content="http://yyguy123.github.io/index.html">
<meta property="og:site_name" content="yyguy123的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yyguy123">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yyguy123.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>yyguy123的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yyguy123的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">若无闲事挂心头，便是人间好时节</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Sql%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Sql%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Sql优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-21 11:21:56" itemprop="dateModified" datetime="2020-12-21T11:21:56+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数据库sql优化：<br>    1、避免全表扫描，应考虑在where和order by后的字段建立索引<br>    2、尽量避免在where子句中对字段进行null值判断，否则会放弃索引使用全表扫描<br>    3、尽量避免在where子句使用！= 或 &lt;&gt; 否则会放弃索引使用全表扫描<br>    4、尽量避免在where子句使用or来连接，否则会放弃索引使用全表扫描，可使用union all<br>    5、in和not in要慎用，否则会放弃索引使用全表扫描，连续的值推荐使用between<br>    6、通配符（%）不要放在索引字段词首，否则会放弃索引使用全表扫描<br>    7、尽量避免在where子句对字段进行函数操作。否则会放弃索引使用全表扫描<br>    8、尽量避免在where子句对字段进行表达式操作，否则会放弃索引使用全表扫描<br>    9、不要在where子句“=”左边进行函数或其他运算，否则可能会导致系统无法正确使用索引<br>    10、若使用索引字段为条件，且该索引为复合索引，那么必须使用到该索引中第一个字段作为索引条件时才能保证系统使用该索引，并应尽可能让字段顺序与索引顺序一致<br>    11、并非所有索引都对查询有效，当索引列有大量数据重复时，sql可能不会去利用索引<br>    12、索引不是越多越好，提高select效率，降低了insert、update效率，因为insert/update可能会重建索引，一个表索引最好不超过6个<br>    13、一般char比varchar2效率高，但varchar2更节省空间，在节省很多空间情况下varchar2效率更高；含中文字符用nchar/nvarchar2,纯英文和数字用char/varchar2<br>    14、尽可能使用varchar代替char，节省空间<br>    15、不要使用select * from  t，解析时会将<em>转化为列名，降低效率<br>    16、避免频繁创建删除临时表<br>    17、避免大事务操作<br>    18、尽量避免向客户端返回大数据量<br>    19、新建临时表数据量量很大时采用select into代替create table 避免大量log<br>    20、多表查询时数据量少的表放在后面，因为oracle解析器按照从右到左的顺序处理from后的表名<br>    21、一般count（一个索引字段）&gt;count（</em>）&gt;count（一个非索引字段）<br>    22、IN和EXISTS<br>        IN：子查询先产生结果集  select * form tableA where x in (select y from tableB); 适合tableB记录少，tableA记录多且有索引的情况<br>        EXISTS：先主查询    select * from tableA where exists(select * from tableB b where b.id=a.id) 适合tableA记录少，tableB记录多且有索引的情况<br>    23、decode：避免重复扫描相同记录<br>        decode(k ,v1, v2 ,v3): 当k值为v1时返回v2 否则返回v3<br>        decode(k,v1,v2,v3,v4): 当k值为v1时返回v2，为v3时返回v4<br>    24、高效删除重复记录： delete from emp e where e.rowid &gt; (select min(m.rowid) from emp m where m.emp_no=e.emp_no);</p>
<pre><code>explain plan for &lt;sql&gt;

ID：序号，不是执行先后顺序，执行先后根据缩进判断
operation：操作内容
rows：估计当前操作返回的结果集
cost：sql执行代价
time：估计当前操作时间
Access：通过某种方式定位了需要的数据，表示这个谓词条件的值将会影响数据访问路径
filter：把所有数据访问了，过滤不需要的，表示谓词条件的值不会影响数据访问路径</code></pre><p>truncate和delete<br>truncate table 表名 速度快效率高；功能上与不带where的deete相同，truncate不能带条件<br>对于有外键的表不能用truncate而应使用delete，truncate不能用于参与了索引视图的表<br>若有rollback，delete会被撤销truncate不会。</p>
<p>数据库范式<br>    第一范式：1、列不可再分 2、同一列中不可有多个值 3、不可有重复的列<br>    第二范式：1、满足第一范式 2、没有部分函数依赖<br>    第三范式：1、满足第二范式 2、没有传递依赖</p>
<p>尽量不要用外键，极大影响性能；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Sharding-Sphere/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Sharding-Sphere/" class="post-title-link" itemprop="url">Sharding-Sphere</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-01 17:44:19" itemprop="dateModified" datetime="2021-01-01T17:44:19+08:00">2021-01-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么要分库分表：<br>    业务越开越大，单表数据超出数据库支持的容量；持久化磁盘IO，传统的数据库性能瓶颈<br>    1、换数据库（缓存）<br>    2、Sql、索引、字段优化<br>    3、读写分离（业务有关优化）<br>    4、分库分表（业务）<br>    5、分区<br>读写分离：我们应用程序访问数据库无非是CRUD   分开 –&gt;分库  前提条件： master -&gt;slave 主从同步架构  一般用于读多写少</p>
<p>分库分表方式： 垂直/水平<br>垂直：<br>    通俗说法叫大表拆小表，拆分是基于关系型数据库中的列（字段）进行的<br>    特点：1、每个库（表）的结构都不一样<br>          2、每个库（表）的数据至少有一列一样<br>          3、每个库（表）的并集是全量数据<br>    优点：拆分后业务逻辑清晰（专库专用按业务拆分）<br>          实现动静分离、冷热数据分离设计体现  冷库：发布说说信息  热库：说说点赞和评论信息<br>          数据维护简单，按业务不同业务放到不同机器<br>    缺点：如果单表数据量大，读写压力大<br>          受某种业务来决定或限制，一个业务往往会影响到数据库瓶颈<br>          部分业务无法关联join，只能通过java程序，提高了开发复杂度</p>
<p>水平：<br>    以某个字段按照一定规律（取模）将一个表的数据分到多个库中<br>    特点：1、每个库（表）的结构都一样<br>          2、每个库（表）的数据都不一样<br>          3、每个库（表）的并集是全量数据<br>    优点：单库（表）的数据保持在一定量，有助于性能提高<br>          提高了系统的稳定性和负载能力<br>          切分的表的结构相同，程序改造较少<br>    缺点：数据的扩容很有难度维护量大<br>          拆分规则很难抽象出来<br>          分片事务的一致性问题部分业务无法关联join，只能通过java程序</p>
<p>读写分离：主从同步、数据一致性、网络延迟的问题<br>分库分表：增加维护成本、分布式事务（跨库事务）、跨库join、分布式全局唯一id等问题</p>
<p>分库分表算法：<br>    取模（Hash）：通过userid进行123%3=xxx 数据分散均衡 但是扩容时间复杂度为O(N)<br>            一致性Hash：假设某个哈希函数H的值空间为0-2^32 -1，整个空间按顺时针方向组织，0和2^32 -1在零点方向重合，下一步将各个服务器使用Hash，具体可<br>            选择服务器ip或主机名，确定其在哈希环上的位置，将数据key使用相同的函数hash计算出哈希值，从此位置顺时针行走，第一台遇到的服务器就是其应该<br>            定位到的服务器。<br>            一致性哈希算法对于节点的增减都只需重定位环空间中一小部分数据，具有较好的容错性和扩展性。<br>            另外，一致性哈希算法在节点过少时，容易因节点分布不均导致数据倾斜问题，为解决这种问题，一致性哈希算法引入虚拟节点机制，对每一个节点计算多<br>            个hash，每个计算结果位置都放置一个此服务节点。 实际应用中通常将虚拟节点数设为32甚至更大。<br>    范围区分（range）：例如 按月、按省     会有热点数据问题<br>    预定义（list）：预计数据量，先设计好分多少库  （100W-1亿数据  10库）</p>
<p>常见中间件：sharding-sphere、atlas<br>Proxy代理：mycat（重）、mysql-proxy、atlas、sharding-proxy（sharding-sphere）<br>        连接请求发给代理，由代理选择连接数据库<br>JDBC直连：TDDL（淘宝  半开源）、sharding-jdbc（sharding-sphere）<br>        在应用层选择连接的数据库</p>
<p>Sharding-Sphere：<br>    LogicTable逻辑表：数据分片的逻辑表，对于水平拆分的数据（库）表，同一类表的总称  例如t_order_0、t_order_1逻辑表为t_order<br>    ActualTable真实表：在分片的数据库中真实存在的物理表，如t_order_0、t_order_1<br>    DataNode数据节点表：数据分片的最小单元，由数据源名称和数据表组成。例：ds_1.t_order_0，配置时默认各个分片数据库的表结构均相同，<br>        直接配置逻辑表和真实表对应关系即可，如果各数据库表结构不同，可使用ds.actual_table配置<br>    BindingTable绑定表：指在任何场景下分片规则均一致的主表和字表。例如订单表和订单项表。BindingTable关系的多表关联查询不会出现笛卡尔积关联，<br>        关联查询效率大大提升<br>    ShardingColumn分片字段：用于将数据库（表）水平拆分的关键字段，例如订单表订单ID取模分片，则订单ID为分片字段，SQL中若无分片字段将执行全路由，性能较差<br>        Sharding-JDBC支持多分片字段<br>    BroadcastTable广播表：指所有分片数据源中都存在的表，表结构和表中数据在每个数据库中完全一致，适用于数据量不大但需要与海量数据表关联查询的场景，<br>        例如字典表<br>    LogicIndex逻辑索引：某些数据库（如PostgreSQL）不允许同一个库存在名称相同的索引，某些数据库（如Mysql）则允许只要同一个表中不存在名称相同的索引即可。<br>        逻辑索引用于同一个库不允许出现相同索引名称的分表场景，需要将同库不同表的索引名称改写为索引名+表名，改写之前的索引名称为逻辑索引</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-21 11:21:56" itemprop="dateModified" datetime="2020-12-21T11:21:56+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis：<br>    数据结构：<br>        String:<br>            set k1 qwer ,   get k1<br>            del k1<br>            append k1 123 (qwer123)<br>            incr/decr/incrby/decrby  必须是数字<br>            getrange/setrange   getrange k1 0 2 (qwe)<br>            setex 设置过期时间 setex k2 10 v2<br>            setnx    不存在就set成功，存在就返回0<br>            mset/mget/msetnx</p>
<pre><code>    List:
        rpush mylist 1 2 3 4 5          rpush list 1 2 3
        lpush rpush lpop rpop
        lrem key n val 删除n个val
        ltrim key start end 截取指定范围值赋给key
        rpoplpush mylist list   (5123)
        lset key index value  
        linsert key before/after v1 v2 在v1前/后 插入v2

    Set：
        sadd、smembers、sismember
        scard 获取元素个数
        srem key val 
        srandmember key n 随机列出n个元素
        spop key 随机出栈
        smove k1 k2 v1 将k1的值v1给k2
        sdiff k1 k2 在k1不在k2的元素
        sinter k1 k2 : k1 k2的交集
        sunion k1 k2 : 并集

    Hash：
        kv模式不变 v为键值对
        hmset customer id 1 name zz age 20、 hmget customer id name age
        hgetall customer
        hdel 
        hlen
        hexists customer id
        hkeys、hvals
        hsetnx

    Zset
        zadd zset01 60 v1 70 v2 80 v3
        zscore key val 
        zrank key val
        zrevrank key val


Maxmemory-policy：
    volatile-lru：使用LRU算法移除key 只对设置了过期时间的key
    allkeys-lru：使用LRU算法移除key
    volatile-random：在过期集合中移除随机的key
    allkeys-random：移除随机的key
    volatile-ttl：移除ttl值最小的key，即最近要过期的key
    noeviction：不进行移除，针对写操作，只返回错误信息


持久化机制：
    RDB：
        手动触发：    
            save:阻塞当前redis服务器直到RDB过程完成，线上环境一般不使用
            bgsave：redis进程执行fork操作创建子进程，持久化由子进程负责，阻塞只发生在fork阶段，一般使用bgsave
        自动触发：
            1、使用save相关配置   save m n 表示m秒内数据集存在n次修改时，自动触发bgsave
            2、从节点执行全量复制操作时主节点自动执行bgsave生成RDB文件发送给从节点
            3、执行debug reload重新加载redis时也会触发save操作
            4、默认执行shutdown时，若没开启AOF则自动执行bgsave
        优点：是一个紧凑的二进制文件，代表redis在某一个时间点上的数据快照，非常适合用于备份、全量复制等，redis加载RDB文件远远快于AOF方式
        缺点：RDB没法做到秒级持久化，因为bgsave每次运行需要fork创建子进程，属于重量级操作；redis演进过程中有多个格式的RDB版本

    AOF：
        以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令；目前是redis主流持久化方式
        开启AOF需设置 appendonly yes   默认不开启 AOF文件通过appendfilename配置设置  默认文件名为appendonly.aof 保存路径与RDB持久化方式一致 通过dir配置
    流程：
        1、命令写入缓冲区
        2、缓冲区根据对应策略向硬盘做同步操作
        3、随着AOF文件变大，需定期重写AOF文件  达到压缩的目的
        4、当redis重启时 加载AOF文件恢复数据

    为什么命令追加到缓冲区？
    reids使用单线程响应，若每次写AOF文件命令都直接追加到硬盘，性能就取决于硬盘负载，先写入缓冲区，reids可提供多种缓冲区同步硬盘策略

    随着命令不断写入，AOF文件越来越大，为解决这个问题redis引入AOF重写机制压缩文件
    1、进程内已超时的文件不会再写文件
    2、旧的AOF文件包含无效命令，如del k1 ,set a 111 ,set a 222等
    3、多条命令合并  如 lpush list a,lpush list b,  lpush list a b

    AOF持久化开启且存在AOF文件时优先加载AOF，否则加载RDB；加载完成后redis启动成功，AOF/RDB存在错误 redis启动失败

Redis事务：
    可一次执行多个命令，本质是一组命令的集合，一个事务中命令被序列化
    multi：开启事务
    exec：执行
    discard：放弃事务
    watch：监视一个或多个key  此key被改动事务被打断   （类似乐观锁）
    unwatch：取消watch对所有key的监控

    redis的事务是部分支持；出现set key这样严重错误时会直接报error但还是可以继续往队列添加命令，只是所有命令都不会成功执行，但是出现incr key（其中key所对应value不为数字时），不会报错，执行时只有这条命令不会成功执行


Redis主从复制：
    1、配从不配主
    2、从库配置：slaveof 主库ip 主库端口  每次与master断开连接后都需重新连接，除非配置进redis.conf文件

    常用：
        一主二仆：一个master两个slave  slave只要一连接就会把master所有数据都记录
                读写分离：只有master能读写，slave只能读不能写
                master挂掉后slave保留之前数据，角色仍是slave，master重新连接后可继续正常工作
                slave挂掉后重新连接后角色为master，也就没有之前的数据了，需重新连接，除非配置进redis.conf文件

        薪火相传：上一个slave可以是下一个slave的master，slave同样可以接受其他slave的连接和同步请求，那么该slave作为链条中下一个的master可有效减轻master的压力；中途变更转向：会清除之前数据，重新拷贝最新的

        反客为主：slaveof no one 使当前数据库停止与其他数据库的同步，角色转为master保留之前的数据


    哨兵模式：
        反客为主需手动将slave转为master  在 sentinel.conf添加 sentinel monitor redis-6379(自己起的数据库名) 127.0.0.1 6379 1
        会监控6379端口的master，master挂了会在剩下slave自动选出一个转为master并将其他slave连接到新的master，若挂掉的master重新连接会被转为slave连接到新的master</code></pre><p>一些常见问题</p>
<pre><code>缓存雪崩：高并发下某一时间同时生成很多缓存并且过期时间在同一时刻
    解决：将缓存失效的时间分散开，在原有失效时间上增加随机值

缓存穿透：查询一个一定不存在的数据导致一直请求DB
    解决：1、若查询一个key不存在则以空结果进行缓存，设置过期时间短一点（几分钟）
          2、布隆过滤器(可看成一个bit数组，映射一个值到布隆过滤器需要使用多个不同的hash函数生成多个hash值，检查某个值对应的多个bit位上的值均为1只能说明可能存在而不是一定存在)

缓存击穿：一个存在的key在过期的同一刻有大量请求
    解决：访问key之前采用setnx设置一个短期key锁住当前key的访问

缓存并发：一个缓存若失效可能多个进程同时查DB同时设置缓存
    解决：对缓存查询加锁，key不存在就加锁，然后查DB入缓存 解锁

热点key：缓存中某些key存储在集群中同一台机器，所有流量涌向同一台机器
    解决：将热点key缓存到本地并设置失效时间，每次请求先检查key是否在本地，不存在再访问缓存机器

Redis是单线程还是多线程？
    Redis中IO多路复用器模块是单线程执行，时间处理器也是单线程执行，两个线程不一样，依靠队列保证顺序；不会上下文切换
    单线程只是针对redis中的模块来说，比如接收请求和响应是单线程，处理事件也是单线程，但是不是同一个。</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Nginx/" class="post-title-link" itemprop="url">Nginx</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-21 11:21:56" itemprop="dateModified" datetime="2020-12-21T11:21:56+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Nginx：<br>    负载均衡算法：<br>        1、Random随机算法：最简单的随机算法；缺点：数量足够大时才能保证均匀分配<br>        2、Round Robin轮询算法：依次转发；缺点：集群中服务器硬件配置不同无法区别对待<br>        3、随机轮询：随机选择一个节点开始依次轮询<br>        4、加权轮询：为了解决简单轮询的不足。（Nginx默认负载均衡算法）<br>            一般算法可能为：<br>                1、轮询所有节点找到最大权重节点<br>                2、选中节点权重减1<br>                3、直到减到0，恢复节点原始权重，继续轮询<br>            Nginx加权轮询：<br>                weight：约定权重， effectiveWeight：有效权重 初始为weight 调用成功+1  异常-1   currentWeight：当前权重 初始为0<br>                1、轮询所有节点，计算当前所有节点effectiveWeight之和totalWeight<br>                2、currentWeight = currentWeight + effectiveWeight 选中所有节点中currentWeight最大的节点<br>                3、选中节点的 currentWeight = currentWeight - totalWeight<br>        5、加权随机：按权重随机选取服务器<br>        6、最少连接：记录每台服务器正在处理的连接数，将新来请求转发到连接最少的那台<br>        7、Latebcy-Aware：动态选择最低延迟的节点处理当前请求<br>        8、源地址散列：根据源ip进行hash</p>
<p>正向代理（客户端对于服务端来说不可见）：<br>    客户端向代理服务器发送请求并指定目标服务器，代理向目标服务器转交并将获得内容返回给客户端</p>
<p>反向代理（服务端对客户端不可见）：<br>    客户端向反向代理发送请求，反向代理内部自动根据访问内容进行跳转和返回</p>
<p>负载均衡：<br>http {<br>    //负载均衡<br>    upstream  test.com{<br>        server 192.168.196.10:80 weight=10;<br>        server 192.168.196.11:80 weight=5;<br>    }</p>
<pre><code>upstream  platform-login{
    ip_hash;
    server 192.168.196.12:80;
    server 192.168.196.13:80;
}

server { 
    listen 80;
    server_name 192.168.10.112
    location / {
        xxx
    }
    //反向代理
    location /platform-login/ {
        proxy_pass http://platform-login;
    }

    location /test.com/ {
        proxy_pass http://test.com;
    }
}</code></pre><p>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Nacos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Nacos/" class="post-title-link" itemprop="url">Nacos</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 19:28:16" itemprop="dateModified" datetime="2021-08-26T19:28:16+08:00">2021-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nacos：针对微服务架构中服务发现、配置管理、服务治理的综合型解决方案"><a href="#Nacos：针对微服务架构中服务发现、配置管理、服务治理的综合型解决方案" class="headerlink" title="Nacos：针对微服务架构中服务发现、配置管理、服务治理的综合型解决方案"></a>Nacos：针对微服务架构中服务发现、配置管理、服务治理的综合型解决方案</h1><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>配置中心：在微服务架构中，当系统从一个单体应用，被拆分成分布式系统上一个个服务节点后，配置文件也必须跟着迁移（分割），这样配置就分散了，不仅如此，分散中还包含着冗余。配置中心将配置从各应用中剥离出来，对配置进行统一管理。</p>
<ol>
<li>在配置中心发布/修改配置</li>
<li>配置中心将配置更新通知到各客户端</li>
<li>客户端从配置中心获取最新配置</li>
</ol>
<p>主流配置中心对比：从配置中心角度看，性能方面Nacos读写性能最高，Apollo次之，SpringCloud Config依赖git场景不适合开放大规模自动化运维API，功能方面Apollo最为完善，Nacos具有Apollo大部分配置管理功能（Nacos不支持灰度发布和权限管理），而SpringCloud Config不带运维管理界面。Nacos一大优势是整合了注册中心、配置中心功能，部署和操作相比Apollo都要直观简单。</p>
<h2 id="Nacos特性"><a href="#Nacos特性" class="headerlink" title="Nacos特性"></a>Nacos特性</h2><p>Nacos主要提供以下四大功能：</p>
<ol>
<li><p>服务发现与服务健康检查</p>
<p>Nacos使服务更容易注册，并通过DNS或Http接口发现其他服务，Nacos还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求 </p>
</li>
<li><p>动态配置管理</p>
<p>动态配置服务允许在所有环境中以集中和动态的方式管理所有服务的配置，Nacos消除了在更新配置时重新部署应用程序，这使配置的更改更加高效和灵活</p>
</li>
<li><p>动态DNS服务</p>
<p>Nacos提供基于DNS协议的服务发现能力，旨在支持异构语言的服务发现，支持将注册在Nacos上的服务以域名的方式暴露端点，让三方应用方便的查阅及发现</p>
</li>
<li><p>服务和元数据管理</p>
<p>Nacos从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述，生命周期，服务的静态依赖分析，服务的健康状态，服务的流量管理、路由及安全策略。</p>
</li>
</ol>
<p>单机模式时Nacos默认使用嵌入式数据库实现数据的存储，若想使用外部mysql存储Nacos数据：</p>
<ol>
<li>安装数据库 5.6.5+  mysql8以下</li>
<li>初始化mysql数据库，新建数据库nacos_config，数据库初始化文件：${nacoshome}/conf/nacos-mysql.sql</li>
<li>修改${nacoshome}/conf/application.properties文件，增加mysql数据源配置</li>
</ol>
<h5 id="Nacos配置"><a href="#Nacos配置" class="headerlink" title="Nacos配置"></a>Nacos配置</h5><p>​    发布配置： dataId、group、配置格式（text/json/xml/yaml/html/properties）、配置内容</p>
<h5 id="Nacos客户端获取配置"><a href="#Nacos客户端获取配置" class="headerlink" title="Nacos客户端获取配置"></a>Nacos客户端获取配置</h5><p>​    通过Nacos服务地址端口及dataId和group可通过Nacos的API获取配置<code>NacosFactory.createConfigService(properties).getConfig(dataId,group,5000);</code><br>​    监听配置<br><code>NacosFactory.createConfigService(properties).addListener(dataId,group,new Listener(){</code><br>​    <code>public Executor getExecutor(){</code><br>​          <code>return null;    
​    }</code><br>​    <code>public void receiveConfigInfo(String s){</code><br>​         <code>System.out.println(s);</code><br>​    <code>}</code><br><code>});</code></p>
<p>})</p>
<h4 id="Nacos配置管理模型"><a href="#Nacos配置管理模型" class="headerlink" title="Nacos配置管理模型"></a>Nacos配置管理模型</h4><p>​    通过Namespace、group、Data ID能够定位到一个配置集</p>
<h6 id="配置集（Data-ID）"><a href="#配置集（Data-ID）" class="headerlink" title="配置集（Data ID）"></a>配置集（Data ID）</h6><p>​    在系统中，一个配置文件通常就是一个配置集，一个配置集可以包含系统的各种配置信息，例如一个配置集可能包含了数据源、线程池、日志级别等配置项，每个配置集都可以定义一个有意义的名称，就是配置集的ID即Data ID。</p>
<h6 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h6><p>​    配置集中包含的一个个配置内容即配置项，代表一个具体的可配置的参数与其值域，通常以key=value的形式存在</p>
<h6 id="配置分组（group）"><a href="#配置分组（group）" class="headerlink" title="配置分组（group）"></a>配置分组（group）</h6><p>​    对配置集进行分组，通过一个有意义的字符串来表示，不同配置费分组下可以有相同配置集。默认采用DEFAULT_GROUP。常用来区分不同的项目或应用</p>
<h6 id="命名空间（Namespace）"><a href="#命名空间（Namespace）" class="headerlink" title="命名空间（Namespace）"></a>命名空间（Namespace）</h6><p>​    可用于进行不同环境的配置隔离，例如可以隔开开发环境、测试环境和生产环境，或者隔离不同用户，不同开发人员使用同一nacos管理各自配置，通过namespace隔离，不同namespace下可存在相同名称的配置分组或配置集。默认有一个public命名空间。</p>
<h6 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h6><p>Namespace：代表不同环境<br>Group：代表不同项目<br>Data ID：每个项目下往往有若干工程，每个配置集（Data ID）是一个工程的主配置文件</p>
<p>支持配置的动态刷新：<br>    客户端配置nacos配置中心的地址后，直接使用@value注解获取配置文件的配置，但无法动态刷新，需注入配置文件上下文<br><code>@Autowired</code><br><code>private ConfigurableApplicationContext applicationContext；</code><br><code>applicationContext.getEnvironment().getProperty(&quot;xxx.xx&quot;);</code><br>类上加@RefreshScope注解时使用@Value也可动态刷新</p>
<p>Nacos客户端resources下新建bootstrap.yaml，<font color="red">dataId的名称就是application的name + file-extension</font></p>
<h6 id="自定义扩展dataId"><a href="#自定义扩展dataId" class="headerlink" title="自定义扩展dataId"></a>自定义扩展dataId</h6><p>对于一个项目需多个配置文件的情况可自定义扩展dataId<br><code>ext-config[0]:</code><br>    <code>data-id: test1.properties  (默认DEFAULT_GROUP，namespace即当前配置文件中的namespace)</code><br><code>ext-config[1]:</code><br>    <code>data-id: test2.properties</code><br>    <code>group: group2</code><br><code>ext-config[2]:</code><br>    <code>data-id: test3.properties</code><br>    <code>group: group3</code><br>    <code>refresh: true  (上面两种都不支持动态刷新)</code></p>
<p>或者使用以下方式更为方便：但是此种方法只认DEFAULT_GROUP的dataid</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">	cloud:</span><br><span class="line">		nacos:</span><br><span class="line">			config:</span><br><span class="line">				shared-dataids: test1.properties,test2.properties,test3.properties</span><br><span class="line">				refreshable-dataids: test3.properties</span><br></pre></td></tr></table></figure>

<p>配置的优先级： C&gt;B&gt;A<br>A：通过<code>spring.cloud.nacos.config.shared-dataids</code>支持多个共享Dataid的配置<br>B：通过<code>spring.cloud.nacos.config.ext-config[n].data-id</code>方式支持多个扩展data id，多个Data Id同时配置时，config[n]的n越大，优先级越高<br>C：通过内部相关规则（应用名+扩展名）自动获取相关的Data Id配置</p>
<h6 id="完全关闭配置"><a href="#完全关闭配置" class="headerlink" title="完全关闭配置"></a>完全关闭配置</h6><p>通过设置<code>spring.cloud.nacos.config.enabled=false</code>来完全关闭Nacos Config</p>
<h4 id="Nacos集群部署"><a href="#Nacos集群部署" class="headerlink" title="Nacos集群部署"></a>Nacos集群部署</h4><pre><code>1. 安装3个以上的Nacos服务
 2. 在所有Nacos目录的conf目录下，将文件cluster.conf.example重命名为cluster.conf，将所有机器以ip：port格式配置进去
 3. 所有客户端分别指定nacos集群中的若干节点
 spring.cloud.nacos.config.server-addr: xx.xx.xx.xx:8848,xx.xx.xx.xx:8849,xx.xx.xx.xx:8850</code></pre><p>生产环境部署建议：<br>      通过域名+VIP（虚拟IP）模式来实现，一个域名对应一个VIP，一个VIP对应多个Nacos节点。当Nacos集群迁移时，客户端无需修改。数据库，生产环境下建议至少主备模式，通过修改${nacoshome}/conf/application.properties文件，使nacos拥有多个数据源。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>微服务架构中，通过服务间的协作来实现业务目标，代码中免不了远程调用。服务消费方获取服务提供方的地址及端口就是服务发现。</p>
<p>Ribbon：客户端负载均衡<br>Feign：远程调用<br>客户端启动类添加@EnableDiscoveryClient、@EnableFeignClients</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">	application:</span><br><span class="line">		name: xxx</span><br><span class="line">	cloud:</span><br><span class="line">		nacos:</span><br><span class="line">			discovery:</span><br><span class="line">				server-addr: xx.xx.xx.xx:8848</span><br><span class="line">				namespace: dev_test</span><br><span class="line">				cluster-name: DEFAULT</span><br></pre></td></tr></table></figure>

<p>Provider实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderController</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ProviderController.calss);</span><br><span class="line">    <span class="meta">@Getmapping</span>(<span class="string">"/service"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"provider invoke"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"provider invoke"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value=<span class="string">"xxx"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceAgent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Getmapping</span>(value=<span class="string">"/service"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  ServiceAgent serviceAgent;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/service"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = serviceAgent.service();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务根据name分组，同一服务可有多个实例，即集群</p>
<h2 id="Nacos原理"><a href="#Nacos原理" class="headerlink" title="Nacos原理"></a>Nacos原理</h2><h4 id="Nacos配置中心原理"><a href="#Nacos配置中心原理" class="headerlink" title="Nacos配置中心原理"></a>Nacos配置中心原理</h4><p>Nacos通过推+拉的方式解决长轮询时间间隔问题。</p>
<p>拉的优势：如果用推的方式，服务端需维持与客户端的长连接，需消耗大量资源，还要考虑连接的有效性。例如需心跳保活，而用拉的方式客户端只需通过一个无状态的http请求即可获取到服务端的数据。</p>
<p>在长轮询任务中，当服务端配置信息发生变更时，客户端将最新数据拉取下来后保存在CacheData中，同时更新了该CacheData的md5值，当下次触发checkListenerMd5方法时，会发现当前listener所持有的md5值和CacheData的md5值不一样了，即意味着服务端配置发生变更，这时就需将最新数据通知给Listener的持有者。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Nacos服务端创建了相关配置项后，客户端就可以进行监听了，客户端是通过一个定时任务来检查自己监听的配置项数据的，一旦服务端数据发生变化时，客户端将会获取最新的数据，并将最新的数据保存在一个CacheData对象中，然后重新计算CacheData中的md5属性值，此时就会对该CacheData所绑定的Listener触发receiveConfigInfo回调。</p>
<p>1、先从本地磁盘加载配置，因为应用启动时会加载远程配置到本地，如果本地文件的内容不为空，直接返回；<br>2、如果本地文件内容为空，则调用worker.getServiceConfig加载远程配置<br>3、如果出现异常，则调用本地快照文件加载配置</p>
<p>客户端长轮询主要做两件事：</p>
<ol>
<li><p>检查本地配置checkLocalConfig<br>a. 如果isUseLocalConfigInfo为false，但本地缓存路径的文件是存在的，则将           isUseLocalConfigInfo设为true，并更新cacheData的内容及文件的更新时间</p>
<p>b. 如果isUseLocalConfigInfo为true，但本地缓存文件不存在则设为false，不通知监听器<br>c. 如果isUseLocalConfigInfo为true，本地缓存文件也存在，但是缓存时间与文件更新时间不一致，则更新cacheData中的内容，isUseLocalConfigInfo设为true。<br>若isUseLocalConfigInfo为true，则检查本地文件缓存的md5与cacheData的md5是否一致，不一致则会触发safeNotifyListener回调方法，listener.receiveConfigInfo(contentTmp)  listener的使用者就能接收到最新的配置信息了。</p>
<ol start="2">
<li>检查服务端配置checkUpdateDataIds:获取远程服务器上数据变更的dataId，遍历变化的集合，通过getServerConfig从远程服务器获取相应内容，更新本地cache为服务器端返回的内容，最后遍历cacheDatas，找到变化的数据进行通知。</li>
</ol>
</li>
</ol>
<p>服务端：</p>
<p>客户端发起长轮询请求，服务端收到请求后，先比较客户端请求过来的md5和服务端是否一致，如果不同则直接返回，如果相同则通过schedule延迟29.5s后再比较，为了保证服务端在29.5s内数据变化能及时通知客户端，服务端采用事件订阅的方式来监听服务端本地数据变化的事件，一旦收到事件，则触发DataChangeTask的通知，并遍历allSubs队列中的ClientLongPolling(客户端的长轮询任务)，将结果写回客户端，就完成了一次数据的推送。如果DataChangeTask完成数据“推送”后，ClientLongPolling中的调度任务又开始执行了怎么办？在”推送“前将原等待执行的调度任务取消就可以了，所以在ClientLongPolling方法中最开始的一个步骤就是删除订阅事件。</p>
<h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><p>角色：</p>
<pre><code>1. leader：所有请求处理者，leader副本接受client的更新请求，本地处理后再同步至其他多个副本
 2. follower：请求的被动更新者，从leader接受更新请求，然后写入本地日志文件
 3. candidate：如果follower副本在一段时间内没有收到leader副本的心跳，则判断leader副本可能已经故障，此时启动选举过程，此时副本会变为candidate状态，直到选举结束
 4. term：每一届新的履职期称之为一届任期</code></pre><p>每隔500ms发起一次选举任务和心跳任务</p>
<p>选举过程：</p>
<pre><code>1. 系统刚启动，所有节点任期为0，大家的role都为follower
 2. 一个启动的节点第一个触发未检测到心跳超时，自增任期为1，并且重新计时，给自己投一票，然后向所有其他节点发起投票
 3. 其他节点当前任期为0，收到candidate的投票选举，清零自己的心跳空白等待时间，未超时前不会发起投票，从而避免多重投票导致无效投票的可能性。
 4. 第一个发起投票的节点收到半数投票，成为leader</code></pre><ol>
<li>每次follower收到leader的一次heartbeat，都会清零自己的心跳计时，如果当前心跳计时超时了，仍未收到leader心跳，就会从follower变成candidate</li>
<li>自增当前任期且开始计时，向其它节点发起投票</li>
<li>其它节点会比较任期和日志的序号，至少不能比自己的数据旧才会投票给第一个发起投票的节点</li>
<li>超过半数节点投票成功才会成为leader，否则等待选举超时，再发起第二轮投票</li>
</ol>
<p>在leaderDue内自己是不会发起选举的，只有到期后才会重置leaderDue和heartbeatDue,然后发送投票。每个节点的leaderDusMs设的是随机值，即每个节点的leader任期不一样，从而避免大家同时发起投票，提高选举成功率。某个节点leaderDusMs先减为0, 先自增term，然后发起投票，该节点term+1比其它节点term大，从而成功成为leader。</p>
<p>发起投票的过程为投票发起方向不包含自己的其它节点发起投票请求，其它节点收到请求后，看term是否比自己term大，大则投给他，然后将自己term设为投票发起方的term，重置leaderDueMs（避免自己再发起一轮投票），最后将投票结果返回投票发起方，根据结果有半数投票的leader成为真正的leader。</p>
<p>心跳过程：</p>
<p>​    和选举类似，只有heartBeatDueMs到期后才会发起心跳处理，这里心跳周期远远小于选举的term周期，而且在心跳处理过程中心跳发起方和接收方都会重置选举时间，通过时间的延长阻止各节点发起投票请求。某一节点成为leader后，通过心跳的方式将leader信息传给其他节点。</p>
<p>follower超时：<br>    自身会重新发起选举，如果与其它节点不通，会一直处于选举状态，如果超时一段时间后恢复，会通过选举成为新的leader或者成为原leader的follower（发选举请求前收到了心跳消息），此时有两个leader，但由于旧leader的term较小，最终被新leader同步为follower（为分析结果，待验证）</p>
<p>leader超时：<br>    leader超时重新选举，产生新leader，旧leader恢复后会通过心跳被同步为follower</p>
<h4 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h4><p>​    服务注册：服务提供者会通过轮询配置的注册中心集群地址进行服务的注册，失败则请求下一个节点；nacos client这边在spring容器启动后执行一个服务订阅操作的延时任务，这个任务执行时先拉取nacos server最新的服务列表，然后与本地缓存的服务列表进行比较，取消订阅下线的服务，然后向nacos server发起订阅操作，订阅所有服务。</p>
<p>服务消费者订阅后会执行一个轮训任务（每10s一次）用来拉取最新的服务提供者信息并实时更新，服务提供者注册时nacos服务端也会有一个相应的心跳检测，当心跳检测超时也就是未及时收到服务提供者的心跳包，nacos server判定该服务状态异常，随后通过UDP推送服务信息来告知对应的服务消费者，服务消费者通过PushReceiver来处理udp协议，HostReactor.processServiceJson(String json)来更新本地服务列表。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Mysql%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Mysql%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">Mysql索引</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-04 14:59:18" itemprop="dateModified" datetime="2021-01-04T14:59:18+08:00">2021-01-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>磁盘存取原理：<br>    寻道时间（速度慢、费时）<br>    旋转时间（速度较快）<br>不使用索引效率低下</p>
<p>索引结构<br>    二叉树：极端情况下（索引列递增）效率跟顺序查无差别<br>    红黑树：不会出现二叉树那种极端情况，但数据量大时深度也很深，效率也会降低<br>    HASH：无法范围查询<br>BTree：<br>    节点既存key也存data<br>    度/阶（Degree）-节点的数据存储个数<br>    叶节点具有相同的深度<br>    叶节点的指针为空<br>    节点中的数据key从左到右递增排列<br>硬盘和内存交互以页为单位，1页大约16K，内存读取硬盘数据每次N页，若Degree设的很大，数据放在一层，仍然会导致多次IO（数据大小/N）。</p>
<p>B+Tree（Mysql使用的索引结构）：<br>    非叶子节点不存储data，只存储key，可以增大度<br>    叶子节点不存储指针<br>    顺序访问指针，提高区间访问的性能</p>
<p>B+Tree索引性能分析<br>    一般使用磁盘IO次数评价索引结构优劣<br>    预读：磁盘一般会顺序向后读取一定长度的数据（页的整数倍）放入内存<br>    局部性原理：当一个数据被使用到时，其附近的数据也通常会马上被使用<br>    B+Tree节点的大小设为等于一个页，每次新建节点直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，就实现了一个节点的载入只需一次IO<br>    B+Tree的度d一般会超过100，因此h非常小（一般在3到5之间）</p>
<p>Mysql存储引擎是表级别的（MyISAM 非聚集索引，InnoDB 聚集索引）<br>    MyISAM索引文件和数据文件是分离的，data存的是数据指针（地址）<br>    主键索引和非主键索引实现相同</p>
<pre><code>InnoDB索引实现
    数据文件本身就是索引文件
    表数据文件本身就是按B+Tree组织的一个索引结构文件
    聚集索引-叶节点包含了完整的数据记录
    主键索引叶子节点存储索引和数据，非主键索引叶子节点存储主键的值

为什么InnoDB表必须有主键，并且推荐使用整型自增主键？
    因为InnoDB查询都是根据主键查的，非主键索引都会查到主键然后根据主键去查数据；
    若没有主键，InnoDB会默认选择一列(无重复数据)作为主键，若无满足条件的列则会自己生成主键
    假设使用UUID作为主键，与自增整型主键比，会浪费一些存储空间，UUID用ASCII值比较不如整型的比较大小效率高
    使用UUID主键不连续，插入时可能会导致已有节点分裂和移动，影响性能
为什么非主键叶子节点存储的是主键值？（一致性和节省空间，若增加数据，不用维护多份索引）</code></pre><p>MyISAM和InnoDB<br>    InnoDB支持事务，MyISAM不支持<br>    InnoDB支持外键，MyISAM不支持<br>    都是B+Tree索引结构，InnoDB是聚集索引，数据和索引在一起，MyISAM数据和索引分开<br>    InnoDB必须有主键，MyISAM可以没有<br>    InnoDB不保存表的具体行数（因为事务特性，同一时刻表中行数对不同事务而言是不一样的），MyISAM用变量保存了表的行数<br>    InnoDB支持表/行级锁，MyISAM支持表级锁<br>    InnoDN存储文件frm,ibd  MyISAM存储文件frm,MYD,MYI<br>    frm是表定义文件，ibd是数据文件；myd是数据文件，myi是索引文件</p>
<p>explain extended <sql> 会在explain的基础上额外提供一些查询优化信息，紧随其后使用show warnings可得到优化后的查询语句<br>explain中每个列的信息：<br>    id列：select的序列号，id的顺序按select出现的顺序增长，id越大执行优先级越高，id相同则从上往下执行，id为null最后执行<br>    select type列：表示查询类型<br>        simple：简单查询，查询不包含子查询和union<br>        primary：复杂查询中最外层的select<br>        subquery：包含在select中的子查询<br>        derived：包含在from子句中的子查询<br>        union：在union中第二个和紧随其后的select<br>        union result：从union临时表检索的select<br>    table列：表示explain的一行正在访问哪个表<br>        当from子句中有子查询时，table列是<derivedn>格式，表示当前查询依赖id=N的查询，于是先执行id=N的查询<br>        当有union时，union result的table值为&lt;union 1,2&gt; 1和2表示参与union的select行id<br>    type列：表示关联类型或访问类型，即Mysql如何查找表中的行<br>            依次从最优到最差：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>            一般来说得保证查询达到range级别，最好达到ref<br>        NULL：mysql能在优化阶段分解查询语句，执行阶段用不着再访问表或索引，例如在索引列选取最小值<br>        const，system：mysql能对查询的某部分进行优化并将其转化为一个常量，system是const的一个特例，表里只有一条元素匹配时为system<br>        eq_ref：primary key或unique key索引的所有部分被连接使用，最多返回一条符条件的记录。<br>        ref：相比eq_ref，不使用唯一索引，而是使用普通索引或唯一索引的部分前缀，可能会找到多个符合条件的行<br>        range：范围扫描通常出现在in(),between,&gt;,&lt;,&gt;=等操作中，使用一个索引来检索给定范围的行<br>        index：扫描全表索引，通常比ALL快一些（index从索引读取，ALL从硬盘读取）<br>        ALL：全表扫描，意味着mysql需要从头到尾查所需要的行。<br>    possible keys列：可能使用哪些索引来查找；<br>        可能出现possible keys有值，key列为NULL的情况，这是因为表中数据不多，mysql认为索引对查询帮助不大，选择全表查询<br>        若这列为空，则没有相关索引<br>    key列：mysql实际采用哪个索引来优化对该表的访问，若想强制mysql使用possible keys中的索引，查询中使用force index<br>    key_len列：显示mysql在索引中使用的字节数，通过这个值可算出具体使用索引中哪些列<br>        计算规则：<br>            字符串：<br>                char(n)：n字节长度<br>                varchar(n):2字节存储字符串长度，如果是utf-8，则长度3n+2<br>            数值类型：<br>                tinyint：1字节<br>                smallint：2字节<br>                int：4字节<br>                bigint：8字节<br>            时间类型：<br>                date：3字节<br>                timestamp：4字节<br>                datetime：8字节<br>            如果字段允许为空，需要1字节记录是否为NULL<br>            索引最大长度768字节，当字符串过长，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引<br>    ref列：这一列显示key列记录的索引中，表查找值所用到的列或常量<br>    rows列：这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数<br>    Extra列：<br>        Using index：查询的列被索引覆盖（索引包含查询的列），并且where筛选条件是索引的前导列，是性能高的表现<br>        Using where：查询的列未被索引覆盖，where筛选条件非索引的前导列<br>        Using where Using index：查询的列被索引覆盖，且where筛选条件是索引列之一但是不是索引的前导列<br>        NULL：查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引但部分字段未被索引覆盖，必须通过‘回表’来实现<br>        Using index condition：与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围<br>        Using temporary：mysql创建一张临时表来处理查询，出现这种情况一般要通过索引来优化<br>        Using filesort：mysql会对结果进行一个外部索引排序，而不是按索引次序从表里读取，这种情况也要用索引来优化</derivedn></sql></p>
<p>索引的最佳实践<br>    1、全值匹配:条件字段中用到联合索引字段时最好按索引定义的顺序全部用到（若全部使用到但是未按顺序排，mysql会自动优化）。<br>    2、最左前缀法则：如果是联合索引，查询从最左前列开始并且不跳过联合索引中的列<br>        如果最左前列（带头大哥）的索引失效（不是使用‘=’而是用‘&gt;’等范围），则（联合索引中）后面的索引都失效<br>    3、不在索引列上做任何操作（计算、函数、自动or手动类型转换），会导致索引失效而全表扫描<br>    4、存储引擎不能使用索引中范围条件右边的列<br>        explain select * from employees where name=’Rose’ and age=22 and position=’manager’;（name、age、position为联合索引） 走联合索引<br>        explain select * from employees where name=’Rose’ and age&gt;22 and position=’manager’;  position字段不走索引<br>    5、尽量使用覆盖索引（索引列包含查询列），减少select *语句<br>    6、mysql在使用（!=或&lt;&gt;）的时候无法使用索引导致全表扫描<br>    7、is null,is not null也不会使用索引<br>    8、like以通配符开头‘%xxx’ mysql索引会失效导致全表扫描<br>        解决like ‘%字符串%’不被使用的方法：<br>            a.使用覆盖索引，查询字段必须是建立覆盖索引字段<br>            b.当覆盖索引指向的字段时varchar(380)及380以上的字段时，覆盖索引会失效<br>    9、字符串不加单引号索引会失效<br>    10、少用or或in，非主键字段的索引会失效，主键索引是否生效与数据量有关，得看mysql查询优化结果<br>    11、使用join时应该小表在前，大表在后（小表驱动大表），左连接建右表索引，因为左表所有数据都要用到，右表中查找匹配左表的数据</p>
<p>Mysql的锁与事务隔离级别<br>锁的分类：<br>    从性能上分为乐观锁（用版本对比来实现）和悲观锁<br>    从对数据库操作的类型分，分为读锁和写锁（都属于悲观锁）<br>        读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响<br>        写锁（排他锁）：当前写操作没完成前，它会阻断其他读锁和写锁<br>    从对数据操作粒度分，分为表锁和行锁</p>
<p>表锁<br>表锁（偏读），偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁粒度大，发生锁冲突的概率最高，并发度最低<br>MyISAM在执行查询语句前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁<br>1、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一张表的读请求，但会阻塞同一表的写请求（自己当前session也不能写），只有当读锁释放后，才会执行其它进程的写操作<br>2、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一张表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作<br>简而言之就是  读锁会阻塞写，但是不会阻塞读，而写锁则会把读和写都阻塞</p>
<p>行锁<br>行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度小，发生锁冲突概率最低，并发度也最高<br>事务是由一组SQL组成的逻辑处理单元<br>Atomicity：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行<br>Consistent：在事务开始和完成时，数据都必须保持一致状态<br>Isolation：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的‘独立’环境执行。意味着事务处理过程中的中间状态对外部不可见，反之亦然<br>Durable：事务完成之后，它对数据的修改是永久性的，即使出现系统故障也能保持。</p>
<p>并发事务处理带来的问题<br>更新丢失：当两个或多个事务选择同一行进行更新，最后的事务更新覆盖了之前事务的更新操作 （可用乐观锁解决）<br>脏读：一个事务读取到另一个事务修改了但未提交的数据  （解决：事务隔离级别设为已提交读）<br>不可重复读：事务A中两次执行同一条查询sql结果不一致（数据被其他事务修改）  （解决：事务隔离级别设为可重复读）<br>幻读：事务A读到了事务B提交的新增数据</p>
<p>查看当前数据库事务隔离级别： show variables like ‘tx_isolation’;<br>设置事务隔离级别： set tx_isolation=‘REPEATABLE-READ’；<br>可重复读   MVCC机制：select操作不会更新版本号，是快照读，增删改会更新版本号，是当前版本。</p>
<p>Oracle默认隔离级别为已提交读，Mysql默认隔离级别为可重复读<br>Spring设置的隔离级别与数据库默认级别不一致，以Spring为准，若Spring设置的隔离级别数据库本身不支持，则以数据库为准<br>Oracle支持两种：已提交读和串行化<br>Mysql四种都支持</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Kafka/" class="post-title-link" itemprop="url">Kafka</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 15:19:02" itemprop="dateModified" datetime="2022-03-14T15:19:02+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kafka：<br>    一个分布式的基于 发布/订阅 模式的消息队列  主要用于大数据实时处理领域</p>
<p>使用消息队列的好处：<br>    1、解耦，允许独立扩展和修改两边的处理过程<br>    2、可恢复性，系统一部分组件失效时不会影响到整个系统<br>    3、缓冲，优化数据流经过系统的速度<br>    4、削峰</p>
<p>运用场景：<br>    1、异步处理：<br>        例如用户注册后需发注册邮件和注册短信，传统作法有串行和并行两种，串行：注册信息入库后发送注册邮件、注册短信后返回给用户；并行：信息入库后并行发送邮件和短信，成功后返回。使用消息队列后：信息入库后邮件、短信信息写入消息队列后直接返回。<br>    2、应用解耦：<br>        例如用户下单后订单系统调用库存系统接口，假如库存系统无法访问就会导致下单失败；使用消息队列：订单系统持久化信息后写入消息队列返回下单成功，库存系统拉取消息扣减库存。<br>    3、流量削峰：<br>        例如秒杀活动，服务器收到请求后写入消息队列，秒杀业务根据队列中信息做后续处理<br>    4、日志处理：<br>        日志采集客户端写入kafka队列，日志处理应用消费队列中数据<br>    5、消息通讯：<br>        点对点通讯：A、B使用同一队列 聊天室：多个客户端订阅同一主题；</p>
<p>消息队列的两种模式：<br>    1、点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）<br>    2、发布/订阅模式（消费者消费数据后不会清除数据）</p>
<p>一个kafka集群中有多个broker（每台机器一个broker），一个broker中多个topic，一个topic中有多个分区partition，每个partition可有多个副本，副本必须分布在不同机器否则无意义，副本中有一个leader，其他为follower；只对leader进行读写，follower只是备份；</p>
<p>消息存储：逻辑上每个partition分为多个segment，每个segment中有存储文件索引的index文件和存储数据的log文件。物理表现为每个partition都有一个文件夹，其中有各个分区的log和index文件，命名规则为当前文件首条消息的offset；</p>
<p>如何定位到指定offset的消息：通过二分法查找到小于等于指定offset的最大offset文件，用 N=（指定offse - 此文件offset）即可找到指定offset消息的索引，即在此index索引文件中第N条消息在log数据文件中的偏移量，从对应log文件中此偏移量位置开始读取，<br>消息结构包含offset和消息大小，所以可以确定读到哪里截止。</p>
<p>producer生产消息存放：<br>    1、指定partition、key、value，存到指定分区<br>    2、指定key、value，通过key的hash值与topic的partition取余存到对应分区<br>    3、指定value，第一次调用随机生成一个整数（后续递增），将此值与partition取余得到对应分区，即轮询</p>
<p>数据可靠性保证：topic每个partition收到producer发送的数据后，都需向producer发送ack，若没收到会重新发送</p>
<p>何时发送ack?<br>    确保有follower和leader同步完成，leader再发送ack，这样才能保证leader挂掉后能在follower中选出新的leader<br>多少个follower同步完成后发送ack？<br>    方案1、半数以上完成。优点：延迟低  缺点：选举leader时，容忍n台机器故障需要2n+1个副本<br>    方案2、全部完成同步。优点：选举新leader时，容忍n台故障需要n+1个副本  缺点：延迟高<br>Kafka选择了第二种，因为：<br>    1、同样为了容忍n台节点故障，方案1需要多出n个副本，而kafka每个分区都有大量数据，方案一会造成大量数据冗余<br>    2、网络延迟对kafka影响较小</p>
<p>ISR<br>    方案2当有一个follower因某种故障迟迟不能与leader同步那么leader就会一直等下去，直到同步才会发送ack。怎么解决这个问题？<br>    leader维护了一个动态的in-sync-replica set（ISR），意为和leader保持同步的follower集合，当ISR中follower完成数据同步后leader就会发送ack，若有follower迟迟不能同步，则将该follower踢出ISR，该事件阀值由replica.lag.time.max.ms参数设定，leader故障就会从ISR选举新leader</p>
<p>ack应答机制（可靠性级别）<br>    0：producer不等待broker的ack，broker一接收到没落盘就返回。beoker故障可能数据丢失。<br>    1：等待ack，leader落盘成功后返回ack，若在follower同步成功前leader故障会导致数据丢失。<br>    -1：等待ack，leader和follower全部落盘成功才返回。若在follower同步后，broker发送ack之前，leader故障会导致数据重复。</p>
<p>Log文件中的LEO和HW<br>    LEO：log end offse，每个副本最后一个offset<br>    HW：high watermark，所有副本中最小的LEO，消费者能见到的最大offset</p>
<p>1、follower故障<br>    故障后会被临时踢出ISR，待该follower恢复后。会读取磁盘上次记录的HW，将高于HW部分截掉，从HW开始向leader同步，等该follower的LEO大于等于该partition的HW，及即follower追上leader后，重新加入ISR</p>
<p>2、leader故障<br>    leader故障后会从ISR选出新的leader，为保证多个副本数据一致性，其余follower会先将各自log文件高于HW部分截掉，然后从新的leader同步数据<br>    （只能保证副本间数据一致性，不保证数据不丢失或不重复）</p>
<p>Exactly Once语义<br>    Ack级别设为,-1,保证不会丢失数据，即At Least Once<br>    Ack级别设为0，保证生产者只发送一次，即At Most Once<br>    Kafka0.11版本之前不能保证既不重复也不丢失，0.11后增加幂等性，At Least Once + 幂等性 = Exactly Once<br>启用幂等性只需将producer参数中enable.idompotence设为true即可，开启后producer会在初始化时分配一个PID，发往同一partition的消息会带上sequence Number，而Broker端会对&lt;PID,Partition,SeqNumber&gt;缓存，当相同主键消息提交时broker只会持久化一条</p>
<p>消费者：<br>    消费方式：Kafka采用pull拉模式从broker中读取数据<br>    push推模式很难适应消费速率不同的消费者，因为发送速率由broker决定<br>    pull模式缺点是无数据时也会循环取空数据；针对这点Kafka在消费时会传入一个timeout参数，无数据时会等上timeout的时间再返回。</p>
<p>消费者分区分配：<br>    1、Range（默认）：假如有10个分区0-9 3个消费者C1 C2 C3 则C1：0,1,2,3 C2:4,5,6 C3:7,8,9<br>        基于主题，同一个消费者组哪些成员指定了相同的主题则由这些成员去消费该主题分区。如有一个主题分区为0-6这7个分区，同组两个消费者B、D消费该主题，则B被分配0-3这4个分区，D被分配4-6这三个。<br>        当同组多个消费者消费主题相同且数量较多时，可能会导致B消费20个，D消费15个，消费不平衡。<br>    2、RoundRobin: 轮询  3个消费者C0 C1 C2 集群中三个主题t0,t1,t2 这三个主题分别有1、2、3个分区，即t0p0,t1p0,t1p1,t2p0,t2p1,t2p2这6个分区<br>        C0订阅主题t0，消费者C1订阅了主题t0和t1，C2订阅了t0 t1 t2<br>        C0：t0p0     C1:t1p0     C2:t1p1、t2p0、t2p1、t2p2</p>
<pre><code>3、Sticky：黏性分区  1、轮询  2、最优配置 3、分配尽可能和上次分配的保持相同
    C0：t0p0     C1:t1p0、t1p1    C2:t2p0、t2p1、t2p2</code></pre><p>Rebalance触发时机:<br>    1、组成员个数发生变化<br>    2、订阅topic个数发生变化<br>    3、订阅topic的分区数发生变化</p>
<p>消费者offset维护：<br>    0.9之前默认将offset保存在Zookeeper中，0.9之后默认将offset保存在Kafka一个内置的topic中_consumer_offsets<br>    消费者组G+主题T+分区P来确定offset</p>
<p>reset：若存在已提交的offset，不管设置为earliest或者latest都会从已提交的offset处开始消费；若不存在已提交的offset，earliest表示从头开始消费，latest表示消费最新数据。<br>none:topic各分区都存在已提交的offset时从offset开始消费，只要有一个分区不存在已提交的offset抛出异常</p>
<p>Kafka事务<br>    Producer事务：PID和Transaction ID绑定，producer重启后可通过Transaction ID获取原来的PID；Transaction Coordinator会将事务状态保存到Kafka的一个内部topic</p>
<pre><code>Consumer事务：
事务机制主要从Producer方面考虑，对于Consumer而言无法保证commit的信息被精确消费，由于Consumer可通过offset访问任意信息，而且不同Segment File生命周期不同，同一事务消息可能出现重启后被删除的情况</code></pre><p>Kafka API<br>    Producer发送消息：异步发送，main线程将消息发送给RecordAccumulator，Sender线程不断从中拉取消息发送到Kafka broker<br>    batch.size：数据累积到batch.size后sender才会发送数据<br>    linger.ms：如果数据迟迟未达到batch.size,sender等待linger.ms之后就会发送数据。</p>
<p>自定义分区 Partition</p>
<p>自定义存储offset：ConsumerRebalanceListener<br>    自动提交/手动提交可能会导致漏消费数据/重复消费数据，可自定义存储offset</p>
<p>自定义拦截器  ProducerInterceptor</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/JVM/" class="post-title-link" itemprop="url">JVM</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-23 14:20:04" itemprop="dateModified" datetime="2022-03-23T14:20:04+08:00">2022-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>����ʱ��������<br>    �̹߳������ѣ���Ŷ���ʵ��������������������Ϣ����������̬����������ʱ�����أ���������һ�ֹ淶�����ô���һ��ʵ��;JDK7�Ժ����ر��ƶ������У��߼��ϻ������ڷ�������<br>    �̸߳��룺�����ջ���洢�ֲ���������������ջ����̬���ӡ��������ڵȣ������ط���ջ�������������ִ��java������¼��������ִ�е�������ֽ���ָ��ĵ�ַ��ִ�б��ط���������ֵΪ�գ�</p>
<p>����Ĵ�����<br>    �����ڴ淽ʽ<br>        ָ����ײ���ڴ����ʱ����ʹ�ù����ڴ����һ�ߣ�δʹ�õ��ڴ������һ���м����һ��ָ����Ϊָʾ��<br>        �����б����ڴ治����ʱ������¼��Щ�ڴ�����<br>    ѡ�����ַ��䷽ʽȡ���������ռ����Ƿ���пռ�ѹ����������<br>    �̰߳�ȫ�ķ����ڴ棺1��CAS + ʧ������ 2��TLAB �����̷߳��仺�壺ÿ���߳�����Java���з���һС���ڴ�</p>
<p>�����ڶ��ڴ沼�֣�<br>    1������ͷ<br>        �ٴ洢������������ʱ���ݣ���ϣ�롢GC�ִ����䡢��״̬��־���̳߳��е�����ƫ���߳�ID��ƫ��ʱ�����<br>        ������ָ��<br>    2��ʵ�����ݣ����������洢����Ч��Ϣ��<br>    3��������䣨�κζ���Ĵ�С������8�ֽڵ���������</p>
<p>����ķ��ʶ�λ��<br>    1��ʹ�þ������   ջ ref –&gt; ���о���� –&gt; ʵ����/������<br>    2��ʹ��ֱ��ָ�루HotSpot��   ջ ref –&gt; ʵ����/������<br>��һ�ֺô��Ƕ����ƶ��������ռ���ֻ��ı����е�ʵ������ָ�룬�����ref<br>�ڶ��ֺô��Ƿ����ٶȿ�</p>
<p>OutOfMemoryError:<br>    ����������ϴ������󣬱�֤GC Roots������֮���пɴ�·�������������ջ��������Щ����<br>    ջ�����<br>            1���߳�����ջ��ȴ�����������������ȣ����޵����Լ��� StackOverflowError<br>            2�������ջ�ڴ�������̬��չ������������ر�����(HotSpotѡ��֧����չ)������չջ�����޷����뵽�㹻�ڴ�ʱ��OutOfMemoryError<br>    ������������ʱ�����������<br>        ����String.intern��CGLib���ɴ�����̬�� ��JDK8֮�󷽷���Ų��Ԫ�ռ䣬Ԫ�ռ䲻��������У�����ʹ�ñ����ڴ棬���ѳ��������쳣��<br>    ֱ���ڴ�����������ڴ���������ɵ�dump�ļ���С ��ֱ�ӻ���ʹ��DirectMemory������NIO�� ���Ǽ��ֱ���ڴ�</p>
<p>�������գ�<br>        ���ü�����������������һ����������ÿ����һ���ط���������������ֵ+1������ʧЧʱ-1 ���޷����ѭ���������⣬Java�����������δʹ�ô˷�����<br>        �ɴ��Է�������GC Roots��ʼ���������ù�ϵ������������GC Roots�����������������ж�Ϊ�ɻ��ն���<br>        GC Roots��<br>            1���������ջ�����ر������������õĶ���<br>            2�����������ྲ̬�������õĶ���<br>            3���������г������õĶ���<br>            4�����ط���ջ��JNI���õĶ���<br>            5��������ڲ������ã���פ�쳣����ϵͳ����������������ݶ�Ӧ��Class����<br>            6����ͬ�������еĶ���<br>            7���ִ��ռ����ֲ�����ʱ��������Ķ�����ʱ�Եļ���</p>
<p>���ã�<br>    ǿ���ã��������ձ���ڵ����ø�ֵ Obj obj=new Obj������ǿ���ù�ϵ��������Զ���ᱻ����<br>    �����ã�SoftReference�ӿڣ���ϵͳ��Ҫ�����ڴ����ǰ���������Щ���󣬻��պ������㹻�ڴ棬�׳��ڴ�����쳣<br>    �����ã�WeakReference�ӿڣ�ֻ�����浽��һ���������շ���Ϊֹ�������ڴ��Ƿ��㹻��������������ù����Ķ���<br>    �����ã�PlantomReference�ӿڣ�����Զ�������ʱ�乹��Ӱ�죬Ҳ�޷�ͨ��������ȡ�ö���ʵ����ֻ��Ϊ���ڶ��󱻻���ʱ�յ�ϵͳ֪ͨ����������ö��У�ReferenceQueue������ʹ�á�</p>
<p>��������ڽ��пɴ��Է�����û����GC Roots�����������ᱻ��һ�α�ǣ��������ɸѡ�Ƿ���Ҫִ��finalize������<br>������û�и���finalize�����ѱ���������ù����򶼲���ִ��finalize��������ִ����ָ������ᴥ�����������ʼ���У�������֤�ȴ�����������ֹĳ������˷�����ѭ�����ϵͳ������finalize�����Ƕ����������������һ�λ��ᣬֻҪ������������һ��������������</p>
<p>���շ�������<br>    ��Ҫ���������֣������ĳ����Ͳ���ʹ�õ�����<br>    �������գ��Ѿ�û���κζ������ó������иó���<br>    ����ʹ�õ��ࣺ<br>      1����������ʵ�����ѱ�����<br>      2�����ظ������������ѱ�����<br>      3�������Ӧ��Class����û�����κεط�������</p>
<p>�ִ��ռ����ۣ�������������˵֮��<br>  ���ִ���˵��������������ǳ���Ϧ���<br>  ǿ�ִ���˵��������������ռ����̵Ķ����Խ��������<br>  ������ü�˵��������������ͬ��������˵��ռ������<br>���ݿ�����ü�˵������Ϊ�������������ɨ�������������ֻ��������������һ��ȫ�����ݽṹ�����伯���������������Ϊ����С�飬��ʶ��������Ŀ��ڴ����ڿ�����ã�����Minor GCʱ�����˿�����õ�С���ڴ����Żᱻ���뵽GC Rootsɨ�裬�˷���Ȼ�ڶ���ı����ù�ϵʱά�����ݵ���ȷ�Ի�����һЩ����ʱ����������ɨ��������������ǻ���ġ�</p>
<p>Partial GC:ָĿ�겻�������ռ�����Java�ѵ������ռ�<br>    Minor GC��ָĿ��ֻ���������������ռ�<br>    Major GC��ָĿ��ֻ��������������ռ���CMS��<br>    Mixed GC��ָĿ���ռ�����������������������������ռ�<br>Full GC���ռ�����Java�Ѻͷ������������ռ�</p>
<p>���-����㷨����������ռ��㷨<br>    ȱ�㣺1��ִ��Ч�ʲ��ȶ�����Java���а��������������д󲿷���Ҫ�����գ���ʱ������д�����Ǻ��������<br>          2���ڴ���Ƭ�����⣬����������������ڴ���Ƭ������Ҫ����ϴ����ʱ�޷��ҵ��㹻�����ڴ����ǰ���������ռ�<br>���-�����㷨�����ڴ水��������Ϊ��С��ȵ����飬ÿ��ֻʹ������һ�飬������ڴ�����Ὣ���ŵĶ����Ƶ���һ���ϣ��ٰ���ʹ�ù����ڴ�ռ�һ����������<br>    ȱ�㣺1������ڴ��ж������������������ڴ�临�ƿ���<br>          2���������ڴ���СΪԭ����һ��<br>    ����Java�����������Ȳ��ñ��-�����㷨ȥ����������������������98%��������һ���ռ�������Eden:Survivor��8:1    ��survivor���������һ���������ռ��Ĵ�������Щ����㽫ͨ�����䵣������ֱ�ӽ��������<br>���-�����㷨�������д��������ڴ�ռ��һ���ƶ���Ȼ��ֱ���������߽�������ڴ�<br>    �ƶ��������������������ÿ�λ��ն��д���������������ƶ������������Ǽ�Ϊ���صĲ�������STW<br>    ���ƶ�������ɢ�ڶ��еĴ������¿ռ���Ƭ������ֻ�����������ӵ��ڴ���������ڴ�������������Ʃ�硰�������з���������<br>    �����������㣬�������ռ�ͣ��ʱ�俴�����ƶ�����ʱ��ͣ�ٻ���̣������������������������ƶ�����������<br>    ����һ�ֺ�ϡ��ʽ�Ľ�������������ʱ����ñ��-����㷨��ֱ����Ƭ����Ӱ��������ʱ�����ñ��-�����㷨�ռ�һ�Ρ����ڱ��-�����CMS�ռ���������Ƭ����ʱ���õľ������֡�</p>
<p>Hotspot�㷨ϸ��ʵ�֣�<br>    OopMap���ݽṹ��һ������ض�����ɣ�Hotspot�ͻ�Ѷ�����ʲôƫ��������ʲô���͵����ݼ���������ڼ�ʱ���������Ҳ�����ض�λ�ü�¼��ջ��ͼĴ�����Щλ�������ã�<br>    �����ռ�����ɨ���ǾͿ�ֱ�ӵ�֪��Щ��Ϣ������������һ����©�شӷ�������GCRoots��ʼ���ҡ�<br>    ����OopMap���ݱ仯��ָ��ǳ��࣬��Ϊÿ��ָ����ɶ�ӦOopMap����Ҫ��������洢�ռ䣬���ֻ���ض�λ�ü�¼��Щ��Ϣ����Щλ�ñ���Ϊ��ȫ�㡣<br>    ǿ��Ҫ�����ִ�дﵽ��ȫ�������ͣ����ȫ���ѡ�����������Ƿ�����ó���ʱ��ִ�е�����Ϊ��׼��ѡ���ģ����� �������á�ѭ����ת���쳣��ת��<br>   ����������ռ�ʱ�����̶߳��ܵ������ȫ�㣺<br>        ����ʽ�жϣ����ڼ������ã������������ռ�ʱ��ϵͳ���Ƚ������û��߳�ȫ���жϣ��������жϵط����ڰ�ȫ��ͻָ������߳�ִ�У�����һ���������ж�ֱ���ܵ���ȫ�㡣<br>        ����ʽ�жϣ��������ռ���Ҫ�ж��߳�ʱ����ֱ�Ӷ��̲߳���������������һ����־λ�����߳�ִ��ʱ��������ȥ��ѯ�����־��һ�������жϱ�־Ϊ������Լ�����İ�ȫ�������жϹ���<br>    ��ѯ��־�ĵط��밲ȫ�����غϵģ����⻹Ҫ�������д��������������Ҫ��Java�ѷ����ڴ�ĵط�������Ϊ�˼���Ƿ񼴽�Ҫ���������ռ�������û���㹻�ڴ�����¶���<br>    �û��̴߳���sleep/blocked״̬ʱ�޷���Ӧ������ж����󣬶�����������������밲ȫ�������<br>    ��ȫ����ָ�ܹ�ȷ����ĳ�δ���Ƭ�������ù�ϵ����仯�����������κεط���ʼ�����ռ����������ġ�</p>
<pre><code>���伯�뿨����
    �����ռ������������н�������Ϊ���伯�����ݽṹ�����ڱ��������������ӽ�GC Rootsɨ�跶Χ��
    ��ʵ�ϲ�ֹ��������������������漰���������ռ���Ϊ�������ռ�������G1��ZGC��Shenandoah�ȶ���������ͬ���⡣    </code></pre><p>JVM���ò���</p>
<p>-Xms����ʼ�ڴ��С��Ĭ��Ϊ�����ڴ�1/64  �ȼ���-XX��InitialHeapSize<br>-Xmx���������ڴ棬Ĭ��Ϊ�����ڴ�1/4 �ȼ��� -XX��MaxHeapSize<br>-Xss�����õ����߳�ջ�Ĵ�С��һ��Ĭ��Ϊ512k~1024k �ȼ��� -XX��ThreadStackSize</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2020/05/31/Java%E4%B8%AD%E7%9A%84%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Java%E4%B8%AD%E7%9A%84%E9%94%81/" class="post-title-link" itemprop="url">Java中的锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 16:12:18" itemprop="dateCreated datePublished" datetime="2020-05-31T16:12:18+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-31 14:25:13" itemprop="dateModified" datetime="2020-05-31T14:25:13+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>锁从宏观上分类，分为悲观锁与乐观锁。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p>
<h2 id="java线程阻塞的代价"><a href="#java线程阻塞的代价" class="headerlink" title="java线程阻塞的代价"></a>java线程阻塞的代价</h2><p>java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p>
<ol>
<li><p>如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；</p>
</li>
<li><p>如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。</p>
<p>synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。</p>
</li>
</ol>
<h2 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h2><p>markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，它的最后2bit是锁状态标志位，用来标记当前对象的状态，对象的所处的状态，决定了markword存储的内容，如下表所示:</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>标志位</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>未锁定</td>
<td>01</td>
<td>对象哈希码、对象分代年龄</td>
</tr>
<tr>
<td>可偏向</td>
<td>01</td>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
</tr>
<tr>
<td>轻量级锁定</td>
<td>00</td>
<td>指向锁记录的指针</td>
</tr>
<tr>
<td>膨胀(重量级锁定)</td>
<td>10</td>
<td>执行重量级锁定的指针</td>
</tr>
<tr>
<td>GC标记</td>
<td>11</td>
<td>空(不需要记录信息)</td>
</tr>
</tbody></table>
<h2 id="Java中的锁-1"><a href="#Java中的锁-1" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><p>无锁—–&gt;偏向锁—–&gt;轻量级锁—–&gt;自旋锁（过渡态）—–&gt;重量级锁</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ol>
<li><p>检查对象头中markWord标志位是否01 可偏向</p>
</li>
<li><p>是则判断线程id是否指向当前线程，若是则执行同步代码。否则CAS获取锁，获取成功执行同步代码，失败表示有竞争，当达到全局安全点时获取偏向锁的线程会挂起 偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续向下执行同步代码（会STW）</p>
<p>适用场景：始终只有一个线程执行同步块，执行期间一旦有竞争就升级为轻量级锁同时撤销偏向锁（会STW），有锁竞争时关闭偏向锁</p>
</li>
</ol>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><pre><code>1. 拷贝锁对象MarWord到LockRecord，使用CAS尝试将对象的MarkWord更新为指向LockRecord的指针，并将LockRecord的owner指向对象的MarkWord,更新成功则表示拥有该对象锁，并将MarkWord标志位设为轻量级锁00 ，更新失败就检查对象MarkWord是否指向当前线程栈帧，是就说明已有当前对象的锁，否则说明多个线程竞争锁，膨胀为重量级锁标志位改为10 后面等待锁的线程也会进入阻塞状态，当前线程自旋来获取锁</code></pre><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><pre><code>1. 尝试获取锁的线程在没有获取锁的时候，去执行一个空循环，即自旋，若干次自旋后还没获取到锁，才被挂起，获取到则执行同步代码</code></pre><h2 id="Synchronized的执行过程"><a href="#Synchronized的执行过程" class="headerlink" title="Synchronized的执行过程"></a>Synchronized的执行过程</h2><pre><code>1. 检测MarkWord是否是当前线程ID，是则处于偏向锁
 2. 不是则CAS将当前线程ID替换为MarkWord，成功则获得偏向锁，失败则表明有竞争，升级为轻量级锁
 3. 当前线程使用CAS将MarkWord替换为锁记录指针，成功则获取到锁，失败表示其他线程竞争锁，当前线程尝试用自旋来获取锁
 4. 自旋成功依然处于轻量级状态，失败则膨胀为重量级锁</code></pre><p>以上几种锁都是JVM的内部实现</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><pre><code>1. 减少锁的时间：不需同步的代码块，能不放在同步块就不要放在同步块
 2. 减少锁的粒度：用空间换时间，例如JAVA8之前的ConcurrenthashMap中的分段锁
 3. 锁粗化：循环内的操作需加锁，则应将锁放到循环外
 4. 使用读写锁：ReentrantReadWriteLock  读加锁并发读，写加锁单线程写
 5. 读写分离：CopyOnWriteArrayList 读多写少， 读不加锁，写加锁
 6. 使用CAS：使用volatile + cas  并发少的情况用
 7. 清楚缓存行的伪共享：32位和64位操作系统缓存32bit/64bit缓存行，可能缓存行中包含除所需同步数据外的其他数据，由于被加锁，其他数据访问时也需经历阻塞获取锁等过程，JDK1.8通过加Contended注解（需在jvm添加-XX：-RestrictContended）</code></pre><p>​    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2020/05/01/Java8%20Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/Java8%20Stream/" class="post-title-link" itemprop="url">Java8 Stream</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-01 19:10:49" itemprop="dateCreated datePublished" datetime="2020-05-01T19:10:49+08:00">2020-05-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Lambda表达式基本语法"><a href="#Lambda表达式基本语法" class="headerlink" title="Lambda表达式基本语法"></a>Lambda表达式基本语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   Lambda表达式基本语法：</span></span><br><span class="line"><span class="comment"> *          parameters -&gt; expression</span></span><br><span class="line"><span class="comment"> *  一、 无参  无返回值</span></span><br><span class="line"><span class="comment"> *       () -&gt; System.out.println("Hello Lambda");</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  二、 有参  无返回值</span></span><br><span class="line"><span class="comment"> *       x -&gt; System.out.println(x);</span></span><br><span class="line"><span class="comment"> *       (x,y) -&gt; System.out.println(x +y);</span></span><br><span class="line"><span class="comment"> *  三、 有参  有返回值 Lambda体有多条语句</span></span><br><span class="line"><span class="comment"> *       (x,y) -&gt; &#123;System.out.println(x +y); return x+y;&#125;</span></span><br><span class="line"><span class="comment"> *       若Lambda体只有一条语句可省略&#123;&#125;和return</span></span><br><span class="line"><span class="comment"> *       (x,y) -&gt; x+y</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Java8 内置四大核心函数式接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Consumer&lt;T&gt;: 消费型接口</span></span><br><span class="line"><span class="comment"> *      void accept(T t);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Supplier&lt;T&gt;: 供给型接口</span></span><br><span class="line"><span class="comment"> *      T get();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Function&lt;T,R&gt;: 函数型接口</span></span><br><span class="line"><span class="comment"> *      R apply(T t);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Predicate&lt;T&gt;: 断言型接口</span></span><br><span class="line"><span class="comment"> *      boolean test(T t);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  方法引用：若Lambda体中内容有方法已经实现，可以使用方法引用</span></span><br><span class="line"><span class="comment"> *  主要有三种语法格式：</span></span><br><span class="line"><span class="comment"> *      对象::实例方法名</span></span><br><span class="line"><span class="comment"> *      类::静态方法名</span></span><br><span class="line"><span class="comment"> *      类::实例方法名</span></span><br><span class="line"><span class="comment"> *  注意：</span></span><br><span class="line"><span class="comment"> *      ①Lambda体中调用方法的参数列表和返回值类型要与函数式接口中参数列表和返回值类型保持一致</span></span><br><span class="line"><span class="comment"> *      ②若Lambda参数列表中第一参数是方法调用者，第二参数是实例方法的参数，可以使用ClassName::method</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  构造器引用： ClassName::new</span></span><br><span class="line"><span class="comment"> *      需要调用的构造器参数列表与函数式接口中抽象方法参数列表保持一致</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  数组引用：Type[]::new</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        TreeSet&lt;Integer&gt; tree =<span class="keyword">new</span> TreeSet&lt;&gt;(com);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Lambda表达式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;((x,y) -&gt; Integer.compare(x,y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream流式操作"><a href="#Stream流式操作" class="headerlink" title="Stream流式操作"></a>Stream流式操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream的三个步骤</span></span><br><span class="line"><span class="comment"> * 1、创建Stream</span></span><br><span class="line"><span class="comment"> * 2、中间操作</span></span><br><span class="line"><span class="comment"> * 3、终止操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一、创建Stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、通过Collection系列集合提供的stream()或parallelStream()</span></span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、通过Arrays中的静态方法stream()获取数组流</span></span><br><span class="line">        User[] users=<span class="keyword">new</span> User[<span class="number">10</span>];</span><br><span class="line">        Stream&lt;User&gt; stream1 = Arrays.stream(users);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、通过Stream中的静态方法of()</span></span><br><span class="line">        Stream&lt;String&gt; ss = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、创建无限流</span></span><br><span class="line">        <span class="comment">//迭代</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>,x -&gt; x+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成</span></span><br><span class="line">        Stream.generate(() -&gt; Math.random()).limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二、中间操作</span></span><br><span class="line"><span class="comment">     * 筛选与切片</span></span><br><span class="line"><span class="comment">     * filter--接收Lambda  从流中过滤某些元素</span></span><br><span class="line"><span class="comment">     * limit--截断流，使其元素不超过给定数量</span></span><br><span class="line"><span class="comment">     * skip(n)--跳过元素，返回一个跳过了前n个元素的流，若流中元素不足n个，则返回一个空流</span></span><br><span class="line"><span class="comment">     * distinct--通过流中元素的hashCode和equals去重元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * filter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        <span class="comment">//中间操作</span></span><br><span class="line">        <span class="comment">//中间操作不会执行任何操作，只有执行终止操作，中间操作才会被全部执行 “惰性求值”</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 内部迭代:迭代操作由StreamAPI完成</span></span><br><span class="line"><span class="comment">         * 这里 “Stream的中间操作” 会输出userList.size()次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;User&gt; userStream = userList.stream().filter(e -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Stream的中间操作"</span>);</span><br><span class="line">            <span class="keyword">return</span> e.getAge() &gt; <span class="number">30</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止操作  一次性执行全部内容</span></span><br><span class="line">        userStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里 “断路” 不一定会输出userList.size()次 找到两条符合条件记录就不会再遍历</span></span><br><span class="line"><span class="comment">         * 短路操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        userList.stream().filter(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"短路"</span>);</span><br><span class="line">            <span class="keyword">return</span> e.getAge() &gt; <span class="number">22</span>;</span><br><span class="line">        &#125;).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * skip</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        <span class="comment">//满足filter条件的结果集跳过两个元素后输出</span></span><br><span class="line">        userList.stream().filter(e -&gt; e.getAge() &gt; <span class="number">20</span>).skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * distinct</span></span><br><span class="line"><span class="comment">     * 注意：distinct 是通过流中元素的hashCode和equals去重元素，必要时需重写hashCode和equals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        userList.stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 映射</span></span><br><span class="line"><span class="comment">     * map--接受Lambda，将元素转换为其他形式或提取信息。</span></span><br><span class="line"><span class="comment">     *      接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射为一个新元素</span></span><br><span class="line"><span class="comment">     * flatMap--接收一个函数作为参数，将流中每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ccc"</span>, <span class="string">"ddd"</span>, <span class="string">"eee"</span>);</span><br><span class="line">        list.stream().map((str) -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamDemo::filterCharacter);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        streamStream.forEach(sm -&gt; &#123;sm.forEach(System.out::println);&#125;);*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//flatMap</span></span><br><span class="line">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamDemo::filterCharacter);</span><br><span class="line">        characterStream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">filterCharacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        List&lt;Character&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character ch:str.toCharArray())&#123;</span><br><span class="line">                list.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * sorted--自然排序（comparable）</span></span><br><span class="line"><span class="comment">     * sorted（comparator）--定制排序（Comparator）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"ccc"</span>, <span class="string">"aaa"</span>, <span class="string">"abc"</span>, <span class="string">"cbd"</span>);</span><br><span class="line">        list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = User.getUserList();</span><br><span class="line">        userList.stream().sorted((e1,e2) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e1.getAge()==e2.getAge())&#123;</span><br><span class="line">                <span class="keyword">return</span> e1.getName().compareTo(e2.getName());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  e1.getAge() - e2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止操作</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *查找与匹配</span></span><br><span class="line"><span class="comment">     * allMatch--检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">     * anyMatch--检查是否至少匹配一个元素</span></span><br><span class="line"><span class="comment">     * noneMatch--检查是否没有匹配所有元素</span></span><br><span class="line"><span class="comment">     * findFirst--返回第一个元素</span></span><br><span class="line"><span class="comment">     * findAny--返回当前流中任意元素</span></span><br><span class="line"><span class="comment">     * count--返回流中元素总个数</span></span><br><span class="line"><span class="comment">     * max--返回流中最大值</span></span><br><span class="line"><span class="comment">     * min--返回流中最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"001"</span>, <span class="number">38</span>, User.Status.VOCATION),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"003"</span>, <span class="number">20</span>, User.Status.BUSY),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"005"</span>, <span class="number">18</span>, User.Status.FREE),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"004"</span>, <span class="number">35</span>, User.Status.BUSY),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"002"</span>, <span class="number">27</span>, User.Status.FREE)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = users.stream().allMatch(e -&gt; e.getStatus().equals(User.Status.BUSY));</span><br><span class="line">        System.out.println(b1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b2 = users.stream().anyMatch(e -&gt; e.getStatus().equals(User.Status.BUSY));</span><br><span class="line">        System.out.println(b2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b3 = users.stream().noneMatch(e -&gt; e.getStatus().equals(User.Status.BUSY));</span><br><span class="line">        System.out.println(b3);</span><br><span class="line"></span><br><span class="line">        Optional&lt;User&gt; first = users.stream().sorted((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge()))</span><br><span class="line">                .findFirst();</span><br><span class="line">        System.out.println(first.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//parallelStream  并行</span></span><br><span class="line">        Optional&lt;User&gt; any = users.parallelStream().filter(e -&gt; e.getStatus().equals(User.Status.FREE))</span><br><span class="line">                .findAny();</span><br><span class="line">        System.out.println(any.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(users.stream().count());</span><br><span class="line"></span><br><span class="line">        Optional&lt;User&gt; max = users.stream().max((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge()));</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归约</span></span><br><span class="line"><span class="comment">     * reduce(T,BinaryOperator) / reduce(BinaryOperator)  可将流中元素反复结合起来，得到一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        Integer sum = list.stream().reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收集</span></span><br><span class="line"><span class="comment">     * collect--将流转换为其他形式，接收一个Collect接口的实现 用于给Stream中元素做汇总的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"001"</span>, <span class="number">38</span>, User.Status.VOCATION),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"003"</span>, <span class="number">20</span>, User.Status.BUSY),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"005"</span>, <span class="number">18</span>, User.Status.FREE),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"004"</span>, <span class="number">35</span>, User.Status.BUSY),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">"002"</span>, <span class="number">27</span>, User.Status.FREE)</span><br><span class="line">        );</span><br><span class="line">        users.stream().map(User::getName).collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">        users.stream().map(User::getName).collect(Collectors.toSet()).forEach(System.out::println);</span><br><span class="line">        users.stream().map(User::getName).collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>)).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.parallelStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCaculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinCaculate</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> length=end -start;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;=THRESHOLD)&#123;</span><br><span class="line">            <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> middle = (start + end) /<span class="number">2</span>;</span><br><span class="line">            ForkJoinCaculate left=<span class="keyword">new</span> ForkJoinCaculate(start,middle);</span><br><span class="line">            left.fork();</span><br><span class="line"></span><br><span class="line">            ForkJoinCaculate right=<span class="keyword">new</span> ForkJoinCaculate(middle+<span class="number">1</span>,end);</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.parallelStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task=<span class="keyword">new</span> ForkJoinCaculate(<span class="number">0</span>,<span class="number">100000000000L</span>);</span><br><span class="line">        Long sum=pool.invoke(task);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"耗时（ms）："</span>+ Duration.between(start,end).toMillis());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;=<span class="number">100000000000L</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"耗时（ms）："</span>+ Duration.between(start,end).toMillis());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java8并行流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        LongStream.rangeClosed(<span class="number">0</span>,<span class="number">100000000000L</span>)</span><br><span class="line">                .parallel()</span><br><span class="line">                .reduce(<span class="number">0</span>,Long::sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(sum);</span></span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"耗时（ms）："</span>+ Duration.between(start,end).toMillis());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java8日期API"><a href="#Java8日期API" class="headerlink" title="Java8日期API"></a>Java8日期API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8_01.optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSimpleDateFormat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        SimpleDateFormat dateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line">        Callable&lt;Date&gt; task=<span class="keyword">new</span> Callable&lt;Date&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Date <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> dateFormat.parse(<span class="string">"20200425"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        List&lt;Future&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(pool.submit(task));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Future&lt;Date&gt; future: results)&#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">       ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">        Callable&lt;Date&gt; task=<span class="keyword">new</span> Callable&lt;Date&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Date <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> df.get().parse(<span class="string">"20200425"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        List&lt;Future&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(pool.submit(task));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Future&lt;Date&gt; future: results)&#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        DateTimeFormatter dtf=DateTimeFormatter.ofPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line">        Callable&lt;LocalDate&gt; task=<span class="keyword">new</span> Callable&lt;LocalDate&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalDate <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> LocalDate.parse(<span class="string">"20200425"</span>,dtf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        List&lt;Future&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(pool.submit(task));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Future&lt;Date&gt; future: results)&#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime ldt =LocalDateTime.now();</span><br><span class="line">        System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">        LocalDateTime ldt2 =LocalDateTime.of(<span class="number">2020</span>,<span class="number">04</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">00</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(ldt2);</span><br><span class="line"></span><br><span class="line">        LocalDateTime ldt3 =ldt2.plusYears(<span class="number">2</span>);</span><br><span class="line">        System.out.println(ldt3);</span><br><span class="line"></span><br><span class="line">        LocalDateTime ldt4 =ldt2.minusMonths(<span class="number">2</span>);</span><br><span class="line">        System.out.println(ldt4);</span><br><span class="line"></span><br><span class="line">        System.out.println(ldt2.getYear());</span><br><span class="line">        System.out.println(ldt2.getMonthValue());</span><br><span class="line">        System.out.println(ldt2.getDayOfMonth());</span><br><span class="line">        System.out.println(ldt2.getMinute());</span><br><span class="line">        System.out.println(ldt2.getSecond());</span><br><span class="line"></span><br><span class="line">        System.out.println(LocalDateTime.parse(<span class="string">"2020-04-25T23:00:18"</span>).</span><br><span class="line">                format(DateTimeFormatter.ofPattern(<span class="string">"yyyyMMdd"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Instant in1=Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Instant in2=Instant.now();</span><br><span class="line">        Duration duration =Duration.between(in1,in2);</span><br><span class="line">        System.out.println(duration.toMillis());</span><br><span class="line"></span><br><span class="line">        LocalDate ld1=LocalDate.of(<span class="number">2018</span>,<span class="number">07</span>,<span class="number">01</span>);</span><br><span class="line">        LocalDate ld2=LocalDate.now();</span><br><span class="line"></span><br><span class="line">        Period p=Period.between(ld1,ld2);</span><br><span class="line"></span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant instant =Instant.now();</span><br><span class="line">        LocalDateTime ld=LocalDateTime.ofInstant(instant,ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">        System.out.println(ld);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yyguy123" src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">yyguy123</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yyguy123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yyguy123" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yyguy123@gmail.com" title="E-Mail → mailto:yyguy123@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yyguy123</span>
</div>
  
  <div>
      <span>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
