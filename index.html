<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="folyjzSrNTxM-gzANuN149Z3GWMMc4Go2VluVGIRh48">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yyguy123.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="yyguy123的个人博客">
<meta property="og:url" content="http://yyguy123.github.io/index.html">
<meta property="og:site_name" content="yyguy123的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yyguy123">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yyguy123.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>yyguy123的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yyguy123的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">若无闲事挂心头，便是人间好时节</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">一些问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 19:10:37" itemprop="dateCreated datePublished" datetime="2022-06-25T19:10:37+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-25 19:09:35" itemprop="dateModified" datetime="2022-06-25T19:09:35+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>同步和异步、阻塞和非阻塞<br>    同步和异步关注的是消息通信机制，<br>    所谓同步，就是在发出调用时没得到结果前该调用就不返回，一旦调用返回就得到返回值<br>    异步：调用发出后就直接返回，没有返回结果；一个异步调用发出后，调用者不会立刻得到结果，被调用者通过状态、通知来通知调用者或者通过回调函数处理这个调用</p>
<pre><code>阻塞和非阻塞关注的是程序在等待调用结果时的状态
阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回
非阻塞调用是指在不能立刻得到结果之前，该调用不会阻塞当前线程
这里阻塞非阻塞和是否同步异步无关</code></pre><p>​<br>NIO由原来的阻塞读写变成了单线程轮询事件，找到可读写的网络描述符进行读写，除了事件轮询是阻塞的，剩余都是纯cpu操作，没必要开启多线程，解决了线程切换问题<br>​    事件分发器，单线程选择就绪事件<br>​    IO处理器，conect\read\write等纯CPU操作，一般开启cpu核心个线程数<br>​    业务线程<br>​    </p>
<p>反射：通过类限定名获取到字节码，将字节码中方法、变量、构造函数映射为对应的Method\Filed\Constructor等类<br>    getMethods获取public的方法（包括父类）<br>    getDeclaredMethods获取当前类声明的所有方法<br>    getDeclaredMethods从缓存或JVM中获取该class声明的方法列表，searchMethods方法从返回的方法列表找到一个匹配名称和参数的方法对象，找到就copy一份返回，每次调用getDeclaredMethods返回的都是新对象；先从reflectionDate中获取declaredMethods，为空就到JVM获取并赋值给reflectionDate</p>
<pre><code>Class.forName 会初始化static块
ClassLoader.loadClass不会执行静态块

JDK动态代理Porxy  InvocationHandler  接口、实现类、代理类    代理类中有实现类的引用 </code></pre><p>cglib动态代理基于asm框架 无反射机制 不需要接口  空间换时间</p>
<p>常见线程池参数：<br>    corePoolSize：核心线程数         corePoolSize = tasks/taskTime<br>    queueCapacity:任务队列容量         queueCapacity = corePoolSize/taskTime  *  respTime<br>    maxPoolSize：最大线程数<br>    keepAliveTIme：线程空闲时间<br>    allowCoreThreadTimeout:是否允许核心线程空闲退出  默认false</p>
<p>常见tomcat参数：<br>内存：<br>    -server  :服务器模式<br>    -Xms    ：java虚拟机初始化最小内存<br>    -Xmx    ：java虚拟机可用最大内存<br>    -Xss    ：每个java线程堆栈大小<br>    -XX:NewSize    :堆区域新生代内存默认大小<br>    -XX:MaxNewSize    :堆区域新生代内存最大可分配大小<br>    -XX:PermSize    :内存永久保留区域<br>    -XX:MaxPermSize    :内存最大永久保留区域<br>    -XX:+UseParNewGC    :对新生代采用多线程并行回收<br>    -XX:BiasedLocking    ：优化线程</p>
<p>并发：<br>    minSpareThreads:初始化时创建的socket连接数<br>    maxSpareThreads:最大空闲socket连接数<br>    maxThreads：客户请求最大线程数<br>    acceptAccount：监听端口队列最大数<br>    enableLookups：是否反查域名  设为false<br>    disableUploadTimeout：是否使用上传超时机制<br>    connectionUploadTimeout：上传超时时间<br>    keepAliveTimeout: 长连接最大保持时间<br>    URIEncoding：指定tomcat容器URL编码格式<br>    connectionTimeout：网络连接超时</p>
<p>工厂模式、策略模式、代理模式、单例模式、装饰类模式</p>
<p>代理：<br>    代理类和目标类实现同一接口，代理类持有目标类引用<br>策略：<br>    配置类配置多种策略类，策略类实现同一接口，context环境类取策略类处理<br>装饰类：<br>    装饰类持有目标类引用，目标类作为参数传入装饰类得到增强<br>单例：<br>    实例化bean后，只暴露一个获取bean的方法<br>工厂：<br>    大量产品需要创建且具有共同接口时使用，一般使用静态工厂</p>
<p>Spring的IOC、AOP<br>IOC：控制反转，将创建对象的控制权交给IOC容器，由主动创建变为被动接收；<br>DI：依赖注入，外部容器动态将依赖对象注入到组件中<br>    注入方式：构造、set、接口注入</p>
<p>bean实例化的几种方式：有参构造、无参构造、静态工厂、实例工厂<br>bean的生命周期：spring容器创建对象、执行init方法、调用自己方法、spring容器关闭时执行destory方法<br>spring加载流程：listener加载配置文件，读取信息到context，context按需动态创建、注入bean,</p>
<p>Spring事务传播机制：<br>    required（默认）：当前无事务就新建一个事务，有就加入那个事务<br>    supports：支持当前事务，若当前无事务就以非事务运行<br>    mandatory：使用当前事务，没有事务抛出异常<br>    requires_new：新建事务，若当前存在事务，把当前事务挂起<br>    not_supported：以非事务运行，存在事务则把当前事务挂起<br>    never：以非事务运行，存在事务则抛异常<br>    nested：存在事务就嵌套在事务内运行，没有则跟required一样</p>
<p>实验：ServiceA中调用serviceB中的方法，在不同传播机制下的表现（以下异常都为插入后进行by/zero运算）<br>                    ServiceA                    ServiceB                            场景<br>Transaction            required                    required                            A、B共用一个事务，有一个异常全部回滚<br>                    required                    requires_new                        B异常AB都回滚，A异常A回滚B提交<br>                    required                    supports                            AB异常都全部回滚<br>                    required                    mandatory                            AB异常都全部回滚<br>                    required                    not_supported                        AB异常都会导致A回滚、B提交<br>                    required                    never                                运行时会抛出存在事务异常<br>                    required                    nested                                AB异常都全部回滚</p>
<pre><code>never/not_supported            required/requires_new/nested        A异常AB都提交，B异常A提交B回滚</code></pre><p>nested和required的区别：required是合并为一个事务，B抛异常就算被A捕获也都会回滚；nested嵌套事务，B异常被A捕获A可以插入B回滚    </p>
<p>spring的事务超时=事务开始时到最后一个statement创建时间 + 最后一个statement执行超时时间<br>isolation事务隔离级别<br>数据库事务隔离级别：Oracle只支持已提交读和串行化，MySQL支持四种：未提交读，已提交读，可重复读，串行化。<br>若spring+oracle，配置隔离级别为Read UnCommited/Repeatable，不起效果。</p>
<p>系统之间交互时事务超时问题：可以不使用事务包裹交互时的操作，将交互前后的数据库操作拆成两个事务<br>并发时事务问题：使用Synchronized修饰的方法也被@Transactional修饰时，可能出现代码执行完了锁被释放但事务正要提交时其他线程进入读取到数据库的数据然后操作，<br>但是之后前一个线程操作提交了，当前线程的操作都是基于旧数据会有问题。</p>
<p>SpringMVC工作流程：<br>    1、用户发送请求到前端控制器DispatcherServlet<br>    2、DispatcherServlet收到请求调用HandlerMapping处理器映射器<br>    3、处理器映射器找到具体处理器（根据xml配置、注解等方式），生成处理器对象及处理器拦截器（如果有则生成）返回给DispatcherServlet<br>    4、DispatcherServlet调用HandlerAdapter处理器适配器<br>    5、HandlerAdapter经过适配调用具体处理器（Controller）<br>    6、Controller执行完返回ModelAndView<br>    7、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet<br>    8、DispatcherServlet将ModelAndView传给ViewResolver视图解析器<br>    9、ViewResolver解析后返回具体view<br>    10、DispatcherServlet根据view进行渲染视图（将模型数据填充至视图）<br>    11、DispatcherServlet响应用户</p>
<p>Java8新特性<br>    1、Lambda表达式，增加函数式接口概念（），在可以使用Lambda表达式的地方，方法声明时必须包含一个函数式接口，任何函数式接口都可被Lambda表达式替换。如Comparator<br>    2、新的日期API，原API非线程安全、时区处理麻烦；新的java.time包涵盖了所有处理日期的操作<br>    3、optional，不用显式进行空值检测<br>    4、构造器和方法引用<br>    5、接口新增默认方法<br>    6、Stream流式操作</p>
<p>​    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Zookeeper/" class="post-title-link" itemprop="url">Zookeeper</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 19:10:37" itemprop="dateCreated datePublished" datetime="2022-06-25T19:10:37+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-25 19:26:19" itemprop="dateModified" datetime="2022-06-25T19:26:19+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Zookeeper=文件系统+监听通知机制</p>
<p>文件系统： 节点可以存储数据  1M<br>监听通知机制： 客户端注册监听节点，节点发生变化（节点数据改变、被删除、子目录节点增加和删除）时，Zookeeper会通知客户端</p>
<p>zookeeper四种数据节点</p>
<p>persistent–持久化节点<br>  客户端与zookeeper断开连接后 该节点依然存在<br>persitent_sequential 持久有序节点<br>  客户端与zookeeper断开连接后，该节点依旧存在，只是zookeeper给该节点名称进行顺序编号<br>ephemeral–临时节点<br>  客户端与zookeeper断开连接后 该节点被删除<br>ephemeral_sequential 临时有序节点<br>  客户端与zookeeper断开连接后 该节点被删除 只是zookeeper给该节点名称进行顺序编号</p>
<p>利用临时节点即可实现分布式锁   独占锁<br>开始–&gt;创建临时节点/lock –&gt; 创建失败则监听/lock节点并等待;创建成功则获取锁，执行完逻辑然后删除/lock，释放锁，此事件就会被监听到并再次尝试创建临时节点;<br>上面的操作删除节点的同时会通知所有客户端<br>可使用临时有序节点优化：   时序锁<br>开始–&gt;在/locks下创建临时有序节点–&gt;获取/locks下所有子节点–&gt;将子节点按序由小到大排序–&gt;当前节点序号是否最小？<br>不是则阻塞，监听比自己序号小1的节点的删除事件;是则获取锁，执行完逻辑后删除节点释放锁，此事件就会被监听到并重复“获取/locks下所有子节点。。。”等系列操作；</p>
<p>zookeeper作为分布式锁的优缺点：<br>  优点：不依靠超时时间释放锁，可靠性高<br>  缺点：性能略低  因为要频繁创建删除节点</p>
<h5 id="Zookeeper选举投票机制"><a href="#Zookeeper选举投票机制" class="headerlink" title="Zookeeper选举投票机制"></a>Zookeeper选举投票机制</h5><ol>
<li>只有启动了的zk节点才能参与投票</li>
<li>每个zk服务启动时，接受一轮对自己的投票</li>
<li>leader角色决策条件，当启动后，如果自身接受投票数超过zk集群节点个数的一半，立刻变为leader</li>
<li>投票操作需要竞争，myid编号-权重</li>
</ol>
<p>流程：</p>
<ol>
<li>启动zk21：接受投票，集群中只有zk21，有1票投给自己</li>
<li>启动zk22：接受投票，自己投给自己，zk21投给自己，通过myid竞争得1票，共2票</li>
<li>启动zk23：自己投自己，通过myid竞争 zk21，zk22投给zk23，共3票，票数过半晋升为leader</li>
<li>启动zk24：已存在leader 只能为follower</li>
<li>启动zk25：已存在leader 只能为follower</li>
</ol>
<p>决定最终leader因素： myid权重 + 启动顺序</p>
<p>重新选举：先比较zxid（事务ID）再比较myid，票数过半及晋升为leader</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/xxl-job/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/xxl-job/" class="post-title-link" itemprop="url">xxl-job</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 19:10:37" itemprop="dateCreated datePublished" datetime="2022-06-25T19:10:37+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-25 19:27:13" itemprop="dateModified" datetime="2022-06-25T19:27:13+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原生定时任务框架先天缺陷：<br> 1、不支持分片任务：处理有序数据时，多机器分片执行任务处理不同数据<br> 2、不支持生命周期统一管理：不重启服务情况下关闭、启动任务<br> 3、不支持集群：存在任务重复执行问题<br> 4、不支持失败重试：出现异常后任务终结、不能根据任务状态控制任务重新执行<br> 5、不支持动态调整：不重启服务的情况下修改任务参数<br> 6、无报警机制：任务失败后没有报警机制<br> 7、任务数据统计难以统计：任务数据量大时，对于任务执行情况无法高效的统计执行情况</p>
<p>xxl-job<br>   调度器、触发器、通讯<br>   执行器、通讯</p>
<p>运行模式一般选bean模式  其他GLUE是直接使用当前调度器作为执行器解析输入的源代码去执行</p>
<p>分片任务：<br>   路由策略选分片广播，输入参数，代码获取参数识别自己要从哪执行</p>
<p>执行器自动注册会有心跳保活，手动录入不会有心跳保活了；手动录入要慎重选择路由策略，例如路由策略为 第一个 时，手动录入的第一台机器挂了任务会执行失败</p>
<p>appName相同为同一个执行器组</p>
<p>为避免多个服务器同时调度任务，通过mysql悲观锁实现分布式锁（for update语句）<br>admin启动：<br>    查询自动注册的执行器，移除90s内没注册的，每30s检查一次<br>    失败任务监测，根据对应设置进行告警、重试操作</p>
<p>XxljobDynamicScheduler初始化时：<br>  JobRegistryMonitor.getInstance.start();//调度中心注册守护线程  维持和执行器间的心跳<br>  JobFaileMonitorHelper.getInstance.start();//任务失败处理的守护线程<br>  NetComServerFactory.putService(Admin.class,XxljobDynamicScheduler.adminBiz);//初始化本地调度中心服务<br>  NetComServerFactory.setAccessToken(accessToken);<br>  initI18n();//国际化</p>
<p>1、JobRegistryMonitor.getInstance.start();<br>   开启一个单独线程，每30s轮训数据库，如果某个执行器的注册信号在近90s没有写入数据库表xxl_job_qrtz_trigger_registry，那么调度中心认为该执行器已死，<br>会更新数据库表xxl_job_qrtz_trigger_group，使每个执行器组只保留活着的执行器，这里的执行器按调度中心来区分的。每个执行器组都有一个唯一的appName，<br>执行器向调度中心注册时就是通过这个appName标志来区分属于哪个执行器组</p>
<p>2、JobFaileMonitorHelper.getInstance.start();<br>   每隔10s执行一下逻辑。数据库表xxl_job_qrtz_trigger_log里存着每个任务每次的执行记录，这里面记录着任务执行状态，若某条任务状态码为500，<br>那么这条执行记录是以失败告终的。那么失败守护线程就会根据这个任务的executorFailRetryCount（失败重试次数，前端新增任务时配置）是否大于0，若大于0，<br>会尝试再执行下这个任务，并相应的在数据库该条执行日志将executorFailRetryCount值减一，最后发出失败告警。</p>
<p>3、初始化本地调度中心的服务Map一级accessToken值，调度中心实例用HashMap对象存了起来。<br>4、国际化，支持中英文</p>
<p>如何触发：<br>timewheel时间轮 本质是Map&lt;Integer,List&gt;<br>触发算法：<br>JobScheduleHelper<br> scheduleThread死循环 首先利用for update进行获取任务的资格锁定 再拿到距now 5s内的任务列表数据：scheduleList 分三中情况处理：<br> for循环遍历scheduleList集合<br> 1、当前任务触发时间超时5s以上（任务下一次触发时间+5s &lt; now）：直接跳过不执行，重置trigger_next_time<br> 2、（任务下一次触发时间&lt; now &lt;= 下一次触发时间+5s）：线程执行触发逻辑，若任务下一次触发时间在5s内，<br> 则放到时间轮内（Map&lt;Integer,List&gt;秒数(0-59)=&gt;任务id列表），再重置trigger_next_time<br> 3、（now &lt;= 任务下一次触发时间）：对触发时间秒数进行60取模直接放到时间轮内，重置trigger_next_time</p>
<p> ringData的处理逻辑在第二个守护线程ringThread中<br>  ringThread死循环 取当前秒数刻度和前一个刻度，在ringData中获取要执行的任务</p>
<p>不管是scheduleThread还是ringThread，最后完成任务调度的都是JobTriggerPoolHelper，此类有两个线程池fastTriggerPool和slowTriggerPool<br>调度线程池隔离，拆分为fast和slow，1分钟窗口期内任务耗时达500ms超过10次，该窗口期内判定为慢任务，慢任务自动降级进入slow线程池，避免耗尽调度线程，提高系统稳定性<br>triggerPool.execute{<br>  …<br>  XxlJobTrigger.trigger —-&gt; processTrigger—&gt; runExecutor –&gt; XxljobScheduler.getExecutorBiz这里的executorBiz是XxlRpcReference.getObject()获取到的代理类<br>  executorBiz.run 此处执行的就是XxlRpcReference的invoke方法 发起远程调用<br>  …<br>  }</p>
<p>执行器：<br>    XxlJobExecutorApplication –&gt; XxlJobSpringExecutor(其中adminAddress为调度中心地址) 实现了ApplicationContextAware保存上下文信息–&gt; start<br>–&gt; 调用本类私有方法取出JobHandler实现类，再调用registJobHandler(name,handler)进行注册  维护了一个Map –&gt;调用父类start方法 大部分业务逻辑在此处理<br>–&gt; 日志处理器初始化、向adminBizList字段中放入XxlRpcReferenceBean返回的代理类、任务日志清除、任务结果回调处理线程、启动XxlRpcProviderFactory</p>
<p>XxlRpcProviderFactory 可以返回Rpc调用服务提供端的工厂类，启动了一个以netty作为通讯模型，hessian作为序列化方式的，ExecutorServiceRegistry作为注册逻辑<br>实现类的服务提供端，接着我们向其添加一个服务ExecutorBiz，处理请求的实现类为ExecutorBizImpl 调用start完成执行器端的服务暴露， ExecutorServiceRegistry<br>调用其start 以30s的间隔和调度中心进行心跳通知，然后调用server的start方法 此时server为NettyHttpServer<br>整个代码结构就是用netty启动了个服务， ChannelHandler，NettyHttpServerHandler 调用私有方法process 这里调用了xxlRpcProviderFactory的invokeService方法完成<br>服务实现的反射调用</p>
<p>ExecutorBizImpl<br>XxlJobExecutor内部会有个以jobId为key，执行这个任务的线程为value的字段jobThreadRepository，我们首先去尝试获取当前正在执行这个任务的线程，<br>如果有就根据任务设置的运行模式进行处理，如果没有正在执行此任务的线程，就调用XxlJobExecutor.registJobThread启动一个线程，最后将任务数据推送给这个可能<br>是从jobThreadRepository获取到的也可能是新创建的线程  JobThread的run方法会从triggerQueue里poll出任务，然后用之前设置的handler进行execute方法调用并利用<br>idleTimes字段进行无任务空转的次数控制，至此执行器完成了启动，暴露ExecutorBiz服务，接收任务调度数据TriggerParam并在JobThread线程中完成任务配置的业务<br>handler的执行</p>
<p>轮询：不能按机器性能充分利用资源<br>权重：可按机器性能分配任务<br>一致性hash：整个空间按顺时针方向组织，圆环上的点从0到2的32次方，将各个服务器使用hash进行哈希，具体可选服务器IP或主机名，确定服务器在哈希环的位置，将<br>数据key使用相同的hash计算出哈希值，从此位置顺时针第一台遇到的服务器就是其该定位到的服务器。使用虚拟节点避免数据倾斜问题。<br>实际应用通常将虚拟节点数设为32甚至更大。  TreeMap<br>LRU：最近最少使用，淘汰最长时间未被使用的    看最后一次被使用到发生调度的时间长短<br>LFU：最少访问算法，淘汰一定时间内访问次数最少的  看一定时间段内被使用的频率</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Sql%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Sql%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Sql优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-21 11:21:56" itemprop="dateModified" datetime="2020-12-21T11:21:56+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数据库sql优化：<br>    1、避免全表扫描，应考虑在where和order by后的字段建立索引<br>    2、尽量避免在where子句中对字段进行null值判断，否则会放弃索引使用全表扫描<br>    3、尽量避免在where子句使用！= 或 &lt;&gt; 否则会放弃索引使用全表扫描<br>    4、尽量避免在where子句使用or来连接，否则会放弃索引使用全表扫描，可使用union all<br>    5、in和not in要慎用，否则会放弃索引使用全表扫描，连续的值推荐使用between<br>    6、通配符（%）不要放在索引字段词首，否则会放弃索引使用全表扫描<br>    7、尽量避免在where子句对字段进行函数操作。否则会放弃索引使用全表扫描<br>    8、尽量避免在where子句对字段进行表达式操作，否则会放弃索引使用全表扫描<br>    9、不要在where子句“=”左边进行函数或其他运算，否则可能会导致系统无法正确使用索引<br>    10、若使用索引字段为条件，且该索引为复合索引，那么必须使用到该索引中第一个字段作为索引条件时才能保证系统使用该索引，并应尽可能让字段顺序与索引顺序一致<br>    11、并非所有索引都对查询有效，当索引列有大量数据重复时，sql可能不会去利用索引<br>    12、索引不是越多越好，提高select效率，降低了insert、update效率，因为insert/update可能会重建索引，一个表索引最好不超过6个<br>    13、一般char比varchar2效率高，但varchar2更节省空间，在节省很多空间情况下varchar2效率更高；含中文字符用nchar/nvarchar2,纯英文和数字用char/varchar2<br>    14、尽可能使用varchar代替char，节省空间<br>    15、不要使用select * from  t，解析时会将<em>转化为列名，降低效率<br>    16、避免频繁创建删除临时表<br>    17、避免大事务操作<br>    18、尽量避免向客户端返回大数据量<br>    19、新建临时表数据量量很大时采用select into代替create table 避免大量log<br>    20、多表查询时数据量少的表放在后面，因为oracle解析器按照从右到左的顺序处理from后的表名<br>    21、一般count（一个索引字段）&gt;count（</em>）&gt;count（一个非索引字段）<br>    22、IN和EXISTS<br>        IN：子查询先产生结果集  select * form tableA where x in (select y from tableB); 适合tableB记录少，tableA记录多且有索引的情况<br>        EXISTS：先主查询    select * from tableA where exists(select * from tableB b where b.id=a.id) 适合tableA记录少，tableB记录多且有索引的情况<br>    23、decode：避免重复扫描相同记录<br>        decode(k ,v1, v2 ,v3): 当k值为v1时返回v2 否则返回v3<br>        decode(k,v1,v2,v3,v4): 当k值为v1时返回v2，为v3时返回v4<br>    24、高效删除重复记录： delete from emp e where e.rowid &gt; (select min(m.rowid) from emp m where m.emp_no=e.emp_no);</p>
<pre><code>explain plan for &lt;sql&gt;

ID：序号，不是执行先后顺序，执行先后根据缩进判断
operation：操作内容
rows：估计当前操作返回的结果集
cost：sql执行代价
time：估计当前操作时间
Access：通过某种方式定位了需要的数据，表示这个谓词条件的值将会影响数据访问路径
filter：把所有数据访问了，过滤不需要的，表示谓词条件的值不会影响数据访问路径</code></pre><p>truncate和delete<br>truncate table 表名 速度快效率高；功能上与不带where的deete相同，truncate不能带条件<br>对于有外键的表不能用truncate而应使用delete，truncate不能用于参与了索引视图的表<br>若有rollback，delete会被撤销truncate不会。</p>
<p>数据库范式<br>    第一范式：1、列不可再分 2、同一列中不可有多个值 3、不可有重复的列<br>    第二范式：1、满足第一范式 2、没有部分函数依赖<br>    第三范式：1、满足第二范式 2、没有传递依赖</p>
<p>尽量不要用外键，极大影响性能；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Sharding-Sphere/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Sharding-Sphere/" class="post-title-link" itemprop="url">Sharding-Sphere</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-01 17:44:19" itemprop="dateModified" datetime="2021-01-01T17:44:19+08:00">2021-01-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么要分库分表：<br>    业务越开越大，单表数据超出数据库支持的容量；持久化磁盘IO，传统的数据库性能瓶颈<br>    1、换数据库（缓存）<br>    2、Sql、索引、字段优化<br>    3、读写分离（业务有关优化）<br>    4、分库分表（业务）<br>    5、分区<br>读写分离：我们应用程序访问数据库无非是CRUD   分开 –&gt;分库  前提条件： master -&gt;slave 主从同步架构  一般用于读多写少</p>
<p>分库分表方式： 垂直/水平<br>垂直：<br>    通俗说法叫大表拆小表，拆分是基于关系型数据库中的列（字段）进行的<br>    特点：1、每个库（表）的结构都不一样<br>          2、每个库（表）的数据至少有一列一样<br>          3、每个库（表）的并集是全量数据<br>    优点：拆分后业务逻辑清晰（专库专用按业务拆分）<br>          实现动静分离、冷热数据分离设计体现  冷库：发布说说信息  热库：说说点赞和评论信息<br>          数据维护简单，按业务不同业务放到不同机器<br>    缺点：如果单表数据量大，读写压力大<br>          受某种业务来决定或限制，一个业务往往会影响到数据库瓶颈<br>          部分业务无法关联join，只能通过java程序，提高了开发复杂度</p>
<p>水平：<br>    以某个字段按照一定规律（取模）将一个表的数据分到多个库中<br>    特点：1、每个库（表）的结构都一样<br>          2、每个库（表）的数据都不一样<br>          3、每个库（表）的并集是全量数据<br>    优点：单库（表）的数据保持在一定量，有助于性能提高<br>          提高了系统的稳定性和负载能力<br>          切分的表的结构相同，程序改造较少<br>    缺点：数据的扩容很有难度维护量大<br>          拆分规则很难抽象出来<br>          分片事务的一致性问题部分业务无法关联join，只能通过java程序</p>
<p>读写分离：主从同步、数据一致性、网络延迟的问题<br>分库分表：增加维护成本、分布式事务（跨库事务）、跨库join、分布式全局唯一id等问题</p>
<p>分库分表算法：<br>    取模（Hash）：通过userid进行123%3=xxx 数据分散均衡 但是扩容时间复杂度为O(N)<br>            一致性Hash：假设某个哈希函数H的值空间为0-2^32 -1，整个空间按顺时针方向组织，0和2^32 -1在零点方向重合，下一步将各个服务器使用Hash，具体可<br>            选择服务器ip或主机名，确定其在哈希环上的位置，将数据key使用相同的函数hash计算出哈希值，从此位置顺时针行走，第一台遇到的服务器就是其应该<br>            定位到的服务器。<br>            一致性哈希算法对于节点的增减都只需重定位环空间中一小部分数据，具有较好的容错性和扩展性。<br>            另外，一致性哈希算法在节点过少时，容易因节点分布不均导致数据倾斜问题，为解决这种问题，一致性哈希算法引入虚拟节点机制，对每一个节点计算多<br>            个hash，每个计算结果位置都放置一个此服务节点。 实际应用中通常将虚拟节点数设为32甚至更大。<br>    范围区分（range）：例如 按月、按省     会有热点数据问题<br>    预定义（list）：预计数据量，先设计好分多少库  （100W-1亿数据  10库）</p>
<p>常见中间件：sharding-sphere、atlas<br>Proxy代理：mycat（重）、mysql-proxy、atlas、sharding-proxy（sharding-sphere）<br>        连接请求发给代理，由代理选择连接数据库<br>JDBC直连：TDDL（淘宝  半开源）、sharding-jdbc（sharding-sphere）<br>        在应用层选择连接的数据库</p>
<p>Sharding-Sphere：<br>    LogicTable逻辑表：数据分片的逻辑表，对于水平拆分的数据（库）表，同一类表的总称  例如t_order_0、t_order_1逻辑表为t_order<br>    ActualTable真实表：在分片的数据库中真实存在的物理表，如t_order_0、t_order_1<br>    DataNode数据节点表：数据分片的最小单元，由数据源名称和数据表组成。例：ds_1.t_order_0，配置时默认各个分片数据库的表结构均相同，<br>        直接配置逻辑表和真实表对应关系即可，如果各数据库表结构不同，可使用ds.actual_table配置<br>    BindingTable绑定表：指在任何场景下分片规则均一致的主表和字表。例如订单表和订单项表。BindingTable关系的多表关联查询不会出现笛卡尔积关联，<br>        关联查询效率大大提升<br>    ShardingColumn分片字段：用于将数据库（表）水平拆分的关键字段，例如订单表订单ID取模分片，则订单ID为分片字段，SQL中若无分片字段将执行全路由，性能较差<br>        Sharding-JDBC支持多分片字段<br>    BroadcastTable广播表：指所有分片数据源中都存在的表，表结构和表中数据在每个数据库中完全一致，适用于数据量不大但需要与海量数据表关联查询的场景，<br>        例如字典表<br>    LogicIndex逻辑索引：某些数据库（如PostgreSQL）不允许同一个库存在名称相同的索引，某些数据库（如Mysql）则允许只要同一个表中不存在名称相同的索引即可。<br>        逻辑索引用于同一个库不允许出现相同索引名称的分表场景，需要将同库不同表的索引名称改写为索引名+表名，改写之前的索引名称为逻辑索引</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-21 11:21:56" itemprop="dateModified" datetime="2020-12-21T11:21:56+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis：<br>    数据结构：<br>        String:<br>            set k1 qwer ,   get k1<br>            del k1<br>            append k1 123 (qwer123)<br>            incr/decr/incrby/decrby  必须是数字<br>            getrange/setrange   getrange k1 0 2 (qwe)<br>            setex 设置过期时间 setex k2 10 v2<br>            setnx    不存在就set成功，存在就返回0<br>            mset/mget/msetnx</p>
<pre><code>    List:
        rpush mylist 1 2 3 4 5          rpush list 1 2 3
        lpush rpush lpop rpop
        lrem key n val 删除n个val
        ltrim key start end 截取指定范围值赋给key
        rpoplpush mylist list   (5123)
        lset key index value  
        linsert key before/after v1 v2 在v1前/后 插入v2

    Set：
        sadd、smembers、sismember
        scard 获取元素个数
        srem key val 
        srandmember key n 随机列出n个元素
        spop key 随机出栈
        smove k1 k2 v1 将k1的值v1给k2
        sdiff k1 k2 在k1不在k2的元素
        sinter k1 k2 : k1 k2的交集
        sunion k1 k2 : 并集

    Hash：
        kv模式不变 v为键值对
        hmset customer id 1 name zz age 20、 hmget customer id name age
        hgetall customer
        hdel 
        hlen
        hexists customer id
        hkeys、hvals
        hsetnx

    Zset
        zadd zset01 60 v1 70 v2 80 v3
        zscore key val 
        zrank key val
        zrevrank key val


Maxmemory-policy：
    volatile-lru：使用LRU算法移除key 只对设置了过期时间的key
    allkeys-lru：使用LRU算法移除key
    volatile-random：在过期集合中移除随机的key
    allkeys-random：移除随机的key
    volatile-ttl：移除ttl值最小的key，即最近要过期的key
    noeviction：不进行移除，针对写操作，只返回错误信息


持久化机制：
    RDB：
        手动触发：    
            save:阻塞当前redis服务器直到RDB过程完成，线上环境一般不使用
            bgsave：redis进程执行fork操作创建子进程，持久化由子进程负责，阻塞只发生在fork阶段，一般使用bgsave
        自动触发：
            1、使用save相关配置   save m n 表示m秒内数据集存在n次修改时，自动触发bgsave
            2、从节点执行全量复制操作时主节点自动执行bgsave生成RDB文件发送给从节点
            3、执行debug reload重新加载redis时也会触发save操作
            4、默认执行shutdown时，若没开启AOF则自动执行bgsave
        优点：是一个紧凑的二进制文件，代表redis在某一个时间点上的数据快照，非常适合用于备份、全量复制等，redis加载RDB文件远远快于AOF方式
        缺点：RDB没法做到秒级持久化，因为bgsave每次运行需要fork创建子进程，属于重量级操作；redis演进过程中有多个格式的RDB版本

    AOF：
        以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令；目前是redis主流持久化方式
        开启AOF需设置 appendonly yes   默认不开启 AOF文件通过appendfilename配置设置  默认文件名为appendonly.aof 保存路径与RDB持久化方式一致 通过dir配置
    流程：
        1、命令写入缓冲区
        2、缓冲区根据对应策略向硬盘做同步操作
        3、随着AOF文件变大，需定期重写AOF文件  达到压缩的目的
        4、当redis重启时 加载AOF文件恢复数据

    为什么命令追加到缓冲区？
    reids使用单线程响应，若每次写AOF文件命令都直接追加到硬盘，性能就取决于硬盘负载，先写入缓冲区，reids可提供多种缓冲区同步硬盘策略

    随着命令不断写入，AOF文件越来越大，为解决这个问题redis引入AOF重写机制压缩文件
    1、进程内已超时的文件不会再写文件
    2、旧的AOF文件包含无效命令，如del k1 ,set a 111 ,set a 222等
    3、多条命令合并  如 lpush list a,lpush list b,  lpush list a b

    AOF持久化开启且存在AOF文件时优先加载AOF，否则加载RDB；加载完成后redis启动成功，AOF/RDB存在错误 redis启动失败

Redis事务：
    可一次执行多个命令，本质是一组命令的集合，一个事务中命令被序列化
    multi：开启事务
    exec：执行
    discard：放弃事务
    watch：监视一个或多个key  此key被改动事务被打断   （类似乐观锁）
    unwatch：取消watch对所有key的监控

    redis的事务是部分支持；出现set key这样严重错误时会直接报error但还是可以继续往队列添加命令，只是所有命令都不会成功执行，但是出现incr key（其中key所对应value不为数字时），不会报错，执行时只有这条命令不会成功执行


Redis主从复制：
    1、配从不配主
    2、从库配置：slaveof 主库ip 主库端口  每次与master断开连接后都需重新连接，除非配置进redis.conf文件

    常用：
        一主二仆：一个master两个slave  slave只要一连接就会把master所有数据都记录
                读写分离：只有master能读写，slave只能读不能写
                master挂掉后slave保留之前数据，角色仍是slave，master重新连接后可继续正常工作
                slave挂掉后重新连接后角色为master，也就没有之前的数据了，需重新连接，除非配置进redis.conf文件

        薪火相传：上一个slave可以是下一个slave的master，slave同样可以接受其他slave的连接和同步请求，那么该slave作为链条中下一个的master可有效减轻master的压力；中途变更转向：会清除之前数据，重新拷贝最新的

        反客为主：slaveof no one 使当前数据库停止与其他数据库的同步，角色转为master保留之前的数据


    哨兵模式：
        反客为主需手动将slave转为master  在 sentinel.conf添加 sentinel monitor redis-6379(自己起的数据库名) 127.0.0.1 6379 1
        会监控6379端口的master，master挂了会在剩下slave自动选出一个转为master并将其他slave连接到新的master，若挂掉的master重新连接会被转为slave连接到新的master</code></pre><p>一些常见问题</p>
<pre><code>缓存雪崩：高并发下某一时间同时生成很多缓存并且过期时间在同一时刻
    解决：将缓存失效的时间分散开，在原有失效时间上增加随机值

缓存穿透：查询一个一定不存在的数据导致一直请求DB
    解决：1、若查询一个key不存在则以空结果进行缓存，设置过期时间短一点（几分钟）
          2、布隆过滤器(可看成一个bit数组，映射一个值到布隆过滤器需要使用多个不同的hash函数生成多个hash值，检查某个值对应的多个bit位上的值均为1只能说明可能存在而不是一定存在)

缓存击穿：一个存在的key在过期的同一刻有大量请求
    解决：访问key之前采用setnx设置一个短期key锁住当前key的访问

缓存并发：一个缓存若失效可能多个进程同时查DB同时设置缓存
    解决：对缓存查询加锁，key不存在就加锁，然后查DB入缓存 解锁

热点key：缓存中某些key存储在集群中同一台机器，所有流量涌向同一台机器
    解决：将热点key缓存到本地并设置失效时间，每次请求先检查key是否在本地，不存在再访问缓存机器

Redis是单线程还是多线程？
    Redis中IO多路复用器模块是单线程执行，时间处理器也是单线程执行，两个线程不一样，依靠队列保证顺序；不会上下文切换
    单线程只是针对redis中的模块来说，比如接收请求和响应是单线程，处理事件也是单线程，但是不是同一个。</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Nginx/" class="post-title-link" itemprop="url">Nginx</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-21 11:21:56" itemprop="dateModified" datetime="2020-12-21T11:21:56+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Nginx：<br>    负载均衡算法：<br>        1、Random随机算法：最简单的随机算法；缺点：数量足够大时才能保证均匀分配<br>        2、Round Robin轮询算法：依次转发；缺点：集群中服务器硬件配置不同无法区别对待<br>        3、随机轮询：随机选择一个节点开始依次轮询<br>        4、加权轮询：为了解决简单轮询的不足。（Nginx默认负载均衡算法）<br>            一般算法可能为：<br>                1、轮询所有节点找到最大权重节点<br>                2、选中节点权重减1<br>                3、直到减到0，恢复节点原始权重，继续轮询<br>            Nginx加权轮询：<br>                weight：约定权重， effectiveWeight：有效权重 初始为weight 调用成功+1  异常-1   currentWeight：当前权重 初始为0<br>                1、轮询所有节点，计算当前所有节点effectiveWeight之和totalWeight<br>                2、currentWeight = currentWeight + effectiveWeight 选中所有节点中currentWeight最大的节点<br>                3、选中节点的 currentWeight = currentWeight - totalWeight<br>        5、加权随机：按权重随机选取服务器<br>        6、最少连接：记录每台服务器正在处理的连接数，将新来请求转发到连接最少的那台<br>        7、Latebcy-Aware：动态选择最低延迟的节点处理当前请求<br>        8、源地址散列：根据源ip进行hash</p>
<p>正向代理（客户端对于服务端来说不可见）：<br>    客户端向代理服务器发送请求并指定目标服务器，代理向目标服务器转交并将获得内容返回给客户端</p>
<p>反向代理（服务端对客户端不可见）：<br>    客户端向反向代理发送请求，反向代理内部自动根据访问内容进行跳转和返回</p>
<p>负载均衡：<br>http {<br>    //负载均衡<br>    upstream  test.com{<br>        server 192.168.196.10:80 weight=10;<br>        server 192.168.196.11:80 weight=5;<br>    }</p>
<pre><code>upstream  platform-login{
    ip_hash;
    server 192.168.196.12:80;
    server 192.168.196.13:80;
}

server { 
    listen 80;
    server_name 192.168.10.112
    location / {
        xxx
    }
    //反向代理
    location /platform-login/ {
        proxy_pass http://platform-login;
    }

    location /test.com/ {
        proxy_pass http://test.com;
    }
}</code></pre><p>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Nacos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Nacos/" class="post-title-link" itemprop="url">Nacos</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 19:28:16" itemprop="dateModified" datetime="2021-08-26T19:28:16+08:00">2021-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nacos：针对微服务架构中服务发现、配置管理、服务治理的综合型解决方案"><a href="#Nacos：针对微服务架构中服务发现、配置管理、服务治理的综合型解决方案" class="headerlink" title="Nacos：针对微服务架构中服务发现、配置管理、服务治理的综合型解决方案"></a>Nacos：针对微服务架构中服务发现、配置管理、服务治理的综合型解决方案</h1><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>配置中心：在微服务架构中，当系统从一个单体应用，被拆分成分布式系统上一个个服务节点后，配置文件也必须跟着迁移（分割），这样配置就分散了，不仅如此，分散中还包含着冗余。配置中心将配置从各应用中剥离出来，对配置进行统一管理。</p>
<ol>
<li>在配置中心发布/修改配置</li>
<li>配置中心将配置更新通知到各客户端</li>
<li>客户端从配置中心获取最新配置</li>
</ol>
<p>主流配置中心对比：从配置中心角度看，性能方面Nacos读写性能最高，Apollo次之，SpringCloud Config依赖git场景不适合开放大规模自动化运维API，功能方面Apollo最为完善，Nacos具有Apollo大部分配置管理功能（Nacos不支持灰度发布和权限管理），而SpringCloud Config不带运维管理界面。Nacos一大优势是整合了注册中心、配置中心功能，部署和操作相比Apollo都要直观简单。</p>
<h2 id="Nacos特性"><a href="#Nacos特性" class="headerlink" title="Nacos特性"></a>Nacos特性</h2><p>Nacos主要提供以下四大功能：</p>
<ol>
<li><p>服务发现与服务健康检查</p>
<p>Nacos使服务更容易注册，并通过DNS或Http接口发现其他服务，Nacos还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求 </p>
</li>
<li><p>动态配置管理</p>
<p>动态配置服务允许在所有环境中以集中和动态的方式管理所有服务的配置，Nacos消除了在更新配置时重新部署应用程序，这使配置的更改更加高效和灵活</p>
</li>
<li><p>动态DNS服务</p>
<p>Nacos提供基于DNS协议的服务发现能力，旨在支持异构语言的服务发现，支持将注册在Nacos上的服务以域名的方式暴露端点，让三方应用方便的查阅及发现</p>
</li>
<li><p>服务和元数据管理</p>
<p>Nacos从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述，生命周期，服务的静态依赖分析，服务的健康状态，服务的流量管理、路由及安全策略。</p>
</li>
</ol>
<p>单机模式时Nacos默认使用嵌入式数据库实现数据的存储，若想使用外部mysql存储Nacos数据：</p>
<ol>
<li>安装数据库 5.6.5+  mysql8以下</li>
<li>初始化mysql数据库，新建数据库nacos_config，数据库初始化文件：${nacoshome}/conf/nacos-mysql.sql</li>
<li>修改${nacoshome}/conf/application.properties文件，增加mysql数据源配置</li>
</ol>
<h5 id="Nacos配置"><a href="#Nacos配置" class="headerlink" title="Nacos配置"></a>Nacos配置</h5><p>​    发布配置： dataId、group、配置格式（text/json/xml/yaml/html/properties）、配置内容</p>
<h5 id="Nacos客户端获取配置"><a href="#Nacos客户端获取配置" class="headerlink" title="Nacos客户端获取配置"></a>Nacos客户端获取配置</h5><p>​    通过Nacos服务地址端口及dataId和group可通过Nacos的API获取配置<code>NacosFactory.createConfigService(properties).getConfig(dataId,group,5000);</code><br>​    监听配置<br><code>NacosFactory.createConfigService(properties).addListener(dataId,group,new Listener(){</code><br>​    <code>public Executor getExecutor(){</code><br>​          <code>return null;    
​    }</code><br>​    <code>public void receiveConfigInfo(String s){</code><br>​         <code>System.out.println(s);</code><br>​    <code>}</code><br><code>});</code></p>
<p>})</p>
<h4 id="Nacos配置管理模型"><a href="#Nacos配置管理模型" class="headerlink" title="Nacos配置管理模型"></a>Nacos配置管理模型</h4><p>​    通过Namespace、group、Data ID能够定位到一个配置集</p>
<h6 id="配置集（Data-ID）"><a href="#配置集（Data-ID）" class="headerlink" title="配置集（Data ID）"></a>配置集（Data ID）</h6><p>​    在系统中，一个配置文件通常就是一个配置集，一个配置集可以包含系统的各种配置信息，例如一个配置集可能包含了数据源、线程池、日志级别等配置项，每个配置集都可以定义一个有意义的名称，就是配置集的ID即Data ID。</p>
<h6 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h6><p>​    配置集中包含的一个个配置内容即配置项，代表一个具体的可配置的参数与其值域，通常以key=value的形式存在</p>
<h6 id="配置分组（group）"><a href="#配置分组（group）" class="headerlink" title="配置分组（group）"></a>配置分组（group）</h6><p>​    对配置集进行分组，通过一个有意义的字符串来表示，不同配置费分组下可以有相同配置集。默认采用DEFAULT_GROUP。常用来区分不同的项目或应用</p>
<h6 id="命名空间（Namespace）"><a href="#命名空间（Namespace）" class="headerlink" title="命名空间（Namespace）"></a>命名空间（Namespace）</h6><p>​    可用于进行不同环境的配置隔离，例如可以隔开开发环境、测试环境和生产环境，或者隔离不同用户，不同开发人员使用同一nacos管理各自配置，通过namespace隔离，不同namespace下可存在相同名称的配置分组或配置集。默认有一个public命名空间。</p>
<h6 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h6><p>Namespace：代表不同环境<br>Group：代表不同项目<br>Data ID：每个项目下往往有若干工程，每个配置集（Data ID）是一个工程的主配置文件</p>
<p>支持配置的动态刷新：<br>    客户端配置nacos配置中心的地址后，直接使用@value注解获取配置文件的配置，但无法动态刷新，需注入配置文件上下文<br><code>@Autowired</code><br><code>private ConfigurableApplicationContext applicationContext；</code><br><code>applicationContext.getEnvironment().getProperty(&quot;xxx.xx&quot;);</code><br>类上加@RefreshScope注解时使用@Value也可动态刷新</p>
<p>Nacos客户端resources下新建bootstrap.yaml，<font color="red">dataId的名称就是application的name + file-extension</font></p>
<h6 id="自定义扩展dataId"><a href="#自定义扩展dataId" class="headerlink" title="自定义扩展dataId"></a>自定义扩展dataId</h6><p>对于一个项目需多个配置文件的情况可自定义扩展dataId<br><code>ext-config[0]:</code><br>    <code>data-id: test1.properties  (默认DEFAULT_GROUP，namespace即当前配置文件中的namespace)</code><br><code>ext-config[1]:</code><br>    <code>data-id: test2.properties</code><br>    <code>group: group2</code><br><code>ext-config[2]:</code><br>    <code>data-id: test3.properties</code><br>    <code>group: group3</code><br>    <code>refresh: true  (上面两种都不支持动态刷新)</code></p>
<p>或者使用以下方式更为方便：但是此种方法只认DEFAULT_GROUP的dataid</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">	cloud:</span><br><span class="line">		nacos:</span><br><span class="line">			config:</span><br><span class="line">				shared-dataids: test1.properties,test2.properties,test3.properties</span><br><span class="line">				refreshable-dataids: test3.properties</span><br></pre></td></tr></table></figure>

<p>配置的优先级： C&gt;B&gt;A<br>A：通过<code>spring.cloud.nacos.config.shared-dataids</code>支持多个共享Dataid的配置<br>B：通过<code>spring.cloud.nacos.config.ext-config[n].data-id</code>方式支持多个扩展data id，多个Data Id同时配置时，config[n]的n越大，优先级越高<br>C：通过内部相关规则（应用名+扩展名）自动获取相关的Data Id配置</p>
<h6 id="完全关闭配置"><a href="#完全关闭配置" class="headerlink" title="完全关闭配置"></a>完全关闭配置</h6><p>通过设置<code>spring.cloud.nacos.config.enabled=false</code>来完全关闭Nacos Config</p>
<h4 id="Nacos集群部署"><a href="#Nacos集群部署" class="headerlink" title="Nacos集群部署"></a>Nacos集群部署</h4><pre><code>1. 安装3个以上的Nacos服务
 2. 在所有Nacos目录的conf目录下，将文件cluster.conf.example重命名为cluster.conf，将所有机器以ip：port格式配置进去
 3. 所有客户端分别指定nacos集群中的若干节点
 spring.cloud.nacos.config.server-addr: xx.xx.xx.xx:8848,xx.xx.xx.xx:8849,xx.xx.xx.xx:8850</code></pre><p>生产环境部署建议：<br>      通过域名+VIP（虚拟IP）模式来实现，一个域名对应一个VIP，一个VIP对应多个Nacos节点。当Nacos集群迁移时，客户端无需修改。数据库，生产环境下建议至少主备模式，通过修改${nacoshome}/conf/application.properties文件，使nacos拥有多个数据源。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>微服务架构中，通过服务间的协作来实现业务目标，代码中免不了远程调用。服务消费方获取服务提供方的地址及端口就是服务发现。</p>
<p>Ribbon：客户端负载均衡<br>Feign：远程调用<br>客户端启动类添加@EnableDiscoveryClient、@EnableFeignClients</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">	application:</span><br><span class="line">		name: xxx</span><br><span class="line">	cloud:</span><br><span class="line">		nacos:</span><br><span class="line">			discovery:</span><br><span class="line">				server-addr: xx.xx.xx.xx:8848</span><br><span class="line">				namespace: dev_test</span><br><span class="line">				cluster-name: DEFAULT</span><br></pre></td></tr></table></figure>

<p>Provider实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderController</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ProviderController.calss);</span><br><span class="line">    <span class="meta">@Getmapping</span>(<span class="string">"/service"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"provider invoke"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"provider invoke"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value=<span class="string">"xxx"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceAgent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Getmapping</span>(value=<span class="string">"/service"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  ServiceAgent serviceAgent;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/service"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = serviceAgent.service();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务根据name分组，同一服务可有多个实例，即集群</p>
<h2 id="Nacos原理"><a href="#Nacos原理" class="headerlink" title="Nacos原理"></a>Nacos原理</h2><h4 id="Nacos配置中心原理"><a href="#Nacos配置中心原理" class="headerlink" title="Nacos配置中心原理"></a>Nacos配置中心原理</h4><p>Nacos通过推+拉的方式解决长轮询时间间隔问题。</p>
<p>拉的优势：如果用推的方式，服务端需维持与客户端的长连接，需消耗大量资源，还要考虑连接的有效性。例如需心跳保活，而用拉的方式客户端只需通过一个无状态的http请求即可获取到服务端的数据。</p>
<p>在长轮询任务中，当服务端配置信息发生变更时，客户端将最新数据拉取下来后保存在CacheData中，同时更新了该CacheData的md5值，当下次触发checkListenerMd5方法时，会发现当前listener所持有的md5值和CacheData的md5值不一样了，即意味着服务端配置发生变更，这时就需将最新数据通知给Listener的持有者。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Nacos服务端创建了相关配置项后，客户端就可以进行监听了，客户端是通过一个定时任务来检查自己监听的配置项数据的，一旦服务端数据发生变化时，客户端将会获取最新的数据，并将最新的数据保存在一个CacheData对象中，然后重新计算CacheData中的md5属性值，此时就会对该CacheData所绑定的Listener触发receiveConfigInfo回调。</p>
<p>1、先从本地磁盘加载配置，因为应用启动时会加载远程配置到本地，如果本地文件的内容不为空，直接返回；<br>2、如果本地文件内容为空，则调用worker.getServiceConfig加载远程配置<br>3、如果出现异常，则调用本地快照文件加载配置</p>
<p>客户端长轮询主要做两件事：</p>
<ol>
<li><p>检查本地配置checkLocalConfig<br>a. 如果isUseLocalConfigInfo为false，但本地缓存路径的文件是存在的，则将           isUseLocalConfigInfo设为true，并更新cacheData的内容及文件的更新时间</p>
<p>b. 如果isUseLocalConfigInfo为true，但本地缓存文件不存在则设为false，不通知监听器<br>c. 如果isUseLocalConfigInfo为true，本地缓存文件也存在，但是缓存时间与文件更新时间不一致，则更新cacheData中的内容，isUseLocalConfigInfo设为true。<br>若isUseLocalConfigInfo为true，则检查本地文件缓存的md5与cacheData的md5是否一致，不一致则会触发safeNotifyListener回调方法，listener.receiveConfigInfo(contentTmp)  listener的使用者就能接收到最新的配置信息了。</p>
<ol start="2">
<li>检查服务端配置checkUpdateDataIds:获取远程服务器上数据变更的dataId，遍历变化的集合，通过getServerConfig从远程服务器获取相应内容，更新本地cache为服务器端返回的内容，最后遍历cacheDatas，找到变化的数据进行通知。</li>
</ol>
</li>
</ol>
<p>服务端：</p>
<p>客户端发起长轮询请求，服务端收到请求后，先比较客户端请求过来的md5和服务端是否一致，如果不同则直接返回，如果相同则通过schedule延迟29.5s后再比较，为了保证服务端在29.5s内数据变化能及时通知客户端，服务端采用事件订阅的方式来监听服务端本地数据变化的事件，一旦收到事件，则触发DataChangeTask的通知，并遍历allSubs队列中的ClientLongPolling(客户端的长轮询任务)，将结果写回客户端，就完成了一次数据的推送。如果DataChangeTask完成数据“推送”后，ClientLongPolling中的调度任务又开始执行了怎么办？在”推送“前将原等待执行的调度任务取消就可以了，所以在ClientLongPolling方法中最开始的一个步骤就是删除订阅事件。</p>
<h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><p>角色：</p>
<pre><code>1. leader：所有请求处理者，leader副本接受client的更新请求，本地处理后再同步至其他多个副本
 2. follower：请求的被动更新者，从leader接受更新请求，然后写入本地日志文件
 3. candidate：如果follower副本在一段时间内没有收到leader副本的心跳，则判断leader副本可能已经故障，此时启动选举过程，此时副本会变为candidate状态，直到选举结束
 4. term：每一届新的履职期称之为一届任期</code></pre><p>每隔500ms发起一次选举任务和心跳任务</p>
<p>选举过程：</p>
<pre><code>1. 系统刚启动，所有节点任期为0，大家的role都为follower
 2. 一个启动的节点第一个触发未检测到心跳超时，自增任期为1，并且重新计时，给自己投一票，然后向所有其他节点发起投票
 3. 其他节点当前任期为0，收到candidate的投票选举，清零自己的心跳空白等待时间，未超时前不会发起投票，从而避免多重投票导致无效投票的可能性。
 4. 第一个发起投票的节点收到半数投票，成为leader</code></pre><ol>
<li>每次follower收到leader的一次heartbeat，都会清零自己的心跳计时，如果当前心跳计时超时了，仍未收到leader心跳，就会从follower变成candidate</li>
<li>自增当前任期且开始计时，向其它节点发起投票</li>
<li>其它节点会比较任期和日志的序号，至少不能比自己的数据旧才会投票给第一个发起投票的节点</li>
<li>超过半数节点投票成功才会成为leader，否则等待选举超时，再发起第二轮投票</li>
</ol>
<p>在leaderDue内自己是不会发起选举的，只有到期后才会重置leaderDue和heartbeatDue,然后发送投票。每个节点的leaderDusMs设的是随机值，即每个节点的leader任期不一样，从而避免大家同时发起投票，提高选举成功率。某个节点leaderDusMs先减为0, 先自增term，然后发起投票，该节点term+1比其它节点term大，从而成功成为leader。</p>
<p>发起投票的过程为投票发起方向不包含自己的其它节点发起投票请求，其它节点收到请求后，看term是否比自己term大，大则投给他，然后将自己term设为投票发起方的term，重置leaderDueMs（避免自己再发起一轮投票），最后将投票结果返回投票发起方，根据结果有半数投票的leader成为真正的leader。</p>
<p>心跳过程：</p>
<p>​    和选举类似，只有heartBeatDueMs到期后才会发起心跳处理，这里心跳周期远远小于选举的term周期，而且在心跳处理过程中心跳发起方和接收方都会重置选举时间，通过时间的延长阻止各节点发起投票请求。某一节点成为leader后，通过心跳的方式将leader信息传给其他节点。</p>
<p>follower超时：<br>    自身会重新发起选举，如果与其它节点不通，会一直处于选举状态，如果超时一段时间后恢复，会通过选举成为新的leader或者成为原leader的follower（发选举请求前收到了心跳消息），此时有两个leader，但由于旧leader的term较小，最终被新leader同步为follower（为分析结果，待验证）</p>
<p>leader超时：<br>    leader超时重新选举，产生新leader，旧leader恢复后会通过心跳被同步为follower</p>
<h4 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h4><p>​    服务注册：服务提供者会通过轮询配置的注册中心集群地址进行服务的注册，失败则请求下一个节点；nacos client这边在spring容器启动后执行一个服务订阅操作的延时任务，这个任务执行时先拉取nacos server最新的服务列表，然后与本地缓存的服务列表进行比较，取消订阅下线的服务，然后向nacos server发起订阅操作，订阅所有服务。</p>
<p>服务消费者订阅后会执行一个轮训任务（每10s一次）用来拉取最新的服务提供者信息并实时更新，服务提供者注册时nacos服务端也会有一个相应的心跳检测，当心跳检测超时也就是未及时收到服务提供者的心跳包，nacos server判定该服务状态异常，随后通过UDP推送服务信息来告知对应的服务消费者，服务消费者通过PushReceiver来处理udp协议，HostReactor.processServiceJson(String json)来更新本地服务列表。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Mysql%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Mysql%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">Mysql索引</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-04 14:59:18" itemprop="dateModified" datetime="2021-01-04T14:59:18+08:00">2021-01-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>磁盘存取原理：<br>    寻道时间（速度慢、费时）<br>    旋转时间（速度较快）<br>不使用索引效率低下</p>
<p>索引结构<br>    二叉树：极端情况下（索引列递增）效率跟顺序查无差别<br>    红黑树：不会出现二叉树那种极端情况，但数据量大时深度也很深，效率也会降低<br>    HASH：无法范围查询<br>BTree：<br>    节点既存key也存data<br>    度/阶（Degree）-节点的数据存储个数<br>    叶节点具有相同的深度<br>    叶节点的指针为空<br>    节点中的数据key从左到右递增排列<br>硬盘和内存交互以页为单位，1页大约16K，内存读取硬盘数据每次N页，若Degree设的很大，数据放在一层，仍然会导致多次IO（数据大小/N）。</p>
<p>B+Tree（Mysql使用的索引结构）：<br>    非叶子节点不存储data，只存储key，可以增大度<br>    叶子节点不存储指针<br>    顺序访问指针，提高区间访问的性能</p>
<p>B+Tree索引性能分析<br>    一般使用磁盘IO次数评价索引结构优劣<br>    预读：磁盘一般会顺序向后读取一定长度的数据（页的整数倍）放入内存<br>    局部性原理：当一个数据被使用到时，其附近的数据也通常会马上被使用<br>    B+Tree节点的大小设为等于一个页，每次新建节点直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，就实现了一个节点的载入只需一次IO<br>    B+Tree的度d一般会超过100，因此h非常小（一般在3到5之间）</p>
<p>Mysql存储引擎是表级别的（MyISAM 非聚集索引，InnoDB 聚集索引）<br>    MyISAM索引文件和数据文件是分离的，data存的是数据指针（地址）<br>    主键索引和非主键索引实现相同</p>
<pre><code>InnoDB索引实现
    数据文件本身就是索引文件
    表数据文件本身就是按B+Tree组织的一个索引结构文件
    聚集索引-叶节点包含了完整的数据记录
    主键索引叶子节点存储索引和数据，非主键索引叶子节点存储主键的值

为什么InnoDB表必须有主键，并且推荐使用整型自增主键？
    因为InnoDB查询都是根据主键查的，非主键索引都会查到主键然后根据主键去查数据；
    若没有主键，InnoDB会默认选择一列(无重复数据)作为主键，若无满足条件的列则会自己生成主键
    假设使用UUID作为主键，与自增整型主键比，会浪费一些存储空间，UUID用ASCII值比较不如整型的比较大小效率高
    使用UUID主键不连续，插入时可能会导致已有节点分裂和移动，影响性能
为什么非主键叶子节点存储的是主键值？（一致性和节省空间，若增加数据，不用维护多份索引）</code></pre><p>MyISAM和InnoDB<br>    InnoDB支持事务，MyISAM不支持<br>    InnoDB支持外键，MyISAM不支持<br>    都是B+Tree索引结构，InnoDB是聚集索引，数据和索引在一起，MyISAM数据和索引分开<br>    InnoDB必须有主键，MyISAM可以没有<br>    InnoDB不保存表的具体行数（因为事务特性，同一时刻表中行数对不同事务而言是不一样的），MyISAM用变量保存了表的行数<br>    InnoDB支持表/行级锁，MyISAM支持表级锁<br>    InnoDN存储文件frm,ibd  MyISAM存储文件frm,MYD,MYI<br>    frm是表定义文件，ibd是数据文件；myd是数据文件，myi是索引文件</p>
<p>explain extended <sql> 会在explain的基础上额外提供一些查询优化信息，紧随其后使用show warnings可得到优化后的查询语句<br>explain中每个列的信息：<br>    id列：select的序列号，id的顺序按select出现的顺序增长，id越大执行优先级越高，id相同则从上往下执行，id为null最后执行<br>    select type列：表示查询类型<br>        simple：简单查询，查询不包含子查询和union<br>        primary：复杂查询中最外层的select<br>        subquery：包含在select中的子查询<br>        derived：包含在from子句中的子查询<br>        union：在union中第二个和紧随其后的select<br>        union result：从union临时表检索的select<br>    table列：表示explain的一行正在访问哪个表<br>        当from子句中有子查询时，table列是<derivedn>格式，表示当前查询依赖id=N的查询，于是先执行id=N的查询<br>        当有union时，union result的table值为&lt;union 1,2&gt; 1和2表示参与union的select行id<br>    type列：表示关联类型或访问类型，即Mysql如何查找表中的行<br>            依次从最优到最差：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>            一般来说得保证查询达到range级别，最好达到ref<br>        NULL：mysql能在优化阶段分解查询语句，执行阶段用不着再访问表或索引，例如在索引列选取最小值<br>        const，system：mysql能对查询的某部分进行优化并将其转化为一个常量，system是const的一个特例，表里只有一条元素匹配时为system<br>        eq_ref：primary key或unique key索引的所有部分被连接使用，最多返回一条符条件的记录。<br>        ref：相比eq_ref，不使用唯一索引，而是使用普通索引或唯一索引的部分前缀，可能会找到多个符合条件的行<br>        range：范围扫描通常出现在in(),between,&gt;,&lt;,&gt;=等操作中，使用一个索引来检索给定范围的行<br>        index：扫描全表索引，通常比ALL快一些（index从索引读取，ALL从硬盘读取）<br>        ALL：全表扫描，意味着mysql需要从头到尾查所需要的行。<br>    possible keys列：可能使用哪些索引来查找；<br>        可能出现possible keys有值，key列为NULL的情况，这是因为表中数据不多，mysql认为索引对查询帮助不大，选择全表查询<br>        若这列为空，则没有相关索引<br>    key列：mysql实际采用哪个索引来优化对该表的访问，若想强制mysql使用possible keys中的索引，查询中使用force index<br>    key_len列：显示mysql在索引中使用的字节数，通过这个值可算出具体使用索引中哪些列<br>        计算规则：<br>            字符串：<br>                char(n)：n字节长度<br>                varchar(n):2字节存储字符串长度，如果是utf-8，则长度3n+2<br>            数值类型：<br>                tinyint：1字节<br>                smallint：2字节<br>                int：4字节<br>                bigint：8字节<br>            时间类型：<br>                date：3字节<br>                timestamp：4字节<br>                datetime：8字节<br>            如果字段允许为空，需要1字节记录是否为NULL<br>            索引最大长度768字节，当字符串过长，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引<br>    ref列：这一列显示key列记录的索引中，表查找值所用到的列或常量<br>    rows列：这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数<br>    Extra列：<br>        Using index：查询的列被索引覆盖（索引包含查询的列），并且where筛选条件是索引的前导列，是性能高的表现<br>        Using where：查询的列未被索引覆盖，where筛选条件非索引的前导列<br>        Using where Using index：查询的列被索引覆盖，且where筛选条件是索引列之一但是不是索引的前导列<br>        NULL：查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引但部分字段未被索引覆盖，必须通过‘回表’来实现<br>        Using index condition：与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围<br>        Using temporary：mysql创建一张临时表来处理查询，出现这种情况一般要通过索引来优化<br>        Using filesort：mysql会对结果进行一个外部索引排序，而不是按索引次序从表里读取，这种情况也要用索引来优化</derivedn></sql></p>
<p>索引的最佳实践<br>    1、全值匹配:条件字段中用到联合索引字段时最好按索引定义的顺序全部用到（若全部使用到但是未按顺序排，mysql会自动优化）。<br>    2、最左前缀法则：如果是联合索引，查询从最左前列开始并且不跳过联合索引中的列<br>        如果最左前列（带头大哥）的索引失效（不是使用‘=’而是用‘&gt;’等范围），则（联合索引中）后面的索引都失效<br>    3、不在索引列上做任何操作（计算、函数、自动or手动类型转换），会导致索引失效而全表扫描<br>    4、存储引擎不能使用索引中范围条件右边的列<br>        explain select * from employees where name=’Rose’ and age=22 and position=’manager’;（name、age、position为联合索引） 走联合索引<br>        explain select * from employees where name=’Rose’ and age&gt;22 and position=’manager’;  position字段不走索引<br>    5、尽量使用覆盖索引（索引列包含查询列），减少select *语句<br>    6、mysql在使用（!=或&lt;&gt;）的时候无法使用索引导致全表扫描<br>    7、is null,is not null也不会使用索引<br>    8、like以通配符开头‘%xxx’ mysql索引会失效导致全表扫描<br>        解决like ‘%字符串%’不被使用的方法：<br>            a.使用覆盖索引，查询字段必须是建立覆盖索引字段<br>            b.当覆盖索引指向的字段时varchar(380)及380以上的字段时，覆盖索引会失效<br>    9、字符串不加单引号索引会失效<br>    10、少用or或in，非主键字段的索引会失效，主键索引是否生效与数据量有关，得看mysql查询优化结果<br>    11、使用join时应该小表在前，大表在后（小表驱动大表），左连接建右表索引，因为左表所有数据都要用到，右表中查找匹配左表的数据</p>
<p>Mysql的锁与事务隔离级别<br>锁的分类：<br>    从性能上分为乐观锁（用版本对比来实现）和悲观锁<br>    从对数据库操作的类型分，分为读锁和写锁（都属于悲观锁）<br>        读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响<br>        写锁（排他锁）：当前写操作没完成前，它会阻断其他读锁和写锁<br>    从对数据操作粒度分，分为表锁和行锁</p>
<p>表锁<br>表锁（偏读），偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁粒度大，发生锁冲突的概率最高，并发度最低<br>MyISAM在执行查询语句前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁<br>1、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一张表的读请求，但会阻塞同一表的写请求（自己当前session也不能写），只有当读锁释放后，才会执行其它进程的写操作<br>2、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一张表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作<br>简而言之就是  读锁会阻塞写，但是不会阻塞读，而写锁则会把读和写都阻塞</p>
<p>行锁<br>行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度小，发生锁冲突概率最低，并发度也最高<br>事务是由一组SQL组成的逻辑处理单元<br>Atomicity：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行<br>Consistent：在事务开始和完成时，数据都必须保持一致状态<br>Isolation：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的‘独立’环境执行。意味着事务处理过程中的中间状态对外部不可见，反之亦然<br>Durable：事务完成之后，它对数据的修改是永久性的，即使出现系统故障也能保持。</p>
<p>并发事务处理带来的问题<br>更新丢失：当两个或多个事务选择同一行进行更新，最后的事务更新覆盖了之前事务的更新操作 （可用乐观锁解决）<br>脏读：一个事务读取到另一个事务修改了但未提交的数据  （解决：事务隔离级别设为已提交读）<br>不可重复读：事务A中两次执行同一条查询sql结果不一致（数据被其他事务修改）  （解决：事务隔离级别设为可重复读）<br>幻读：事务A读到了事务B提交的新增数据</p>
<p>查看当前数据库事务隔离级别： show variables like ‘tx_isolation’;<br>设置事务隔离级别： set tx_isolation=‘REPEATABLE-READ’；<br>可重复读   MVCC机制：select操作不会更新版本号，是快照读，增删改会更新版本号，是当前版本。</p>
<p>Oracle默认隔离级别为已提交读，Mysql默认隔离级别为可重复读<br>Spring设置的隔离级别与数据库默认级别不一致，以Spring为准，若Spring设置的隔离级别数据库本身不支持，则以数据库为准<br>Oracle支持两种：已提交读和串行化<br>Mysql四种都支持</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2022/06/25/Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/Kafka/" class="post-title-link" itemprop="url">Kafka</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 18:33:33" itemprop="dateCreated datePublished" datetime="2022-06-25T18:33:33+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 15:19:02" itemprop="dateModified" datetime="2022-03-14T15:19:02+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kafka：<br>    一个分布式的基于 发布/订阅 模式的消息队列  主要用于大数据实时处理领域</p>
<p>使用消息队列的好处：<br>    1、解耦，允许独立扩展和修改两边的处理过程<br>    2、可恢复性，系统一部分组件失效时不会影响到整个系统<br>    3、缓冲，优化数据流经过系统的速度<br>    4、削峰</p>
<p>运用场景：<br>    1、异步处理：<br>        例如用户注册后需发注册邮件和注册短信，传统作法有串行和并行两种，串行：注册信息入库后发送注册邮件、注册短信后返回给用户；并行：信息入库后并行发送邮件和短信，成功后返回。使用消息队列后：信息入库后邮件、短信信息写入消息队列后直接返回。<br>    2、应用解耦：<br>        例如用户下单后订单系统调用库存系统接口，假如库存系统无法访问就会导致下单失败；使用消息队列：订单系统持久化信息后写入消息队列返回下单成功，库存系统拉取消息扣减库存。<br>    3、流量削峰：<br>        例如秒杀活动，服务器收到请求后写入消息队列，秒杀业务根据队列中信息做后续处理<br>    4、日志处理：<br>        日志采集客户端写入kafka队列，日志处理应用消费队列中数据<br>    5、消息通讯：<br>        点对点通讯：A、B使用同一队列 聊天室：多个客户端订阅同一主题；</p>
<p>消息队列的两种模式：<br>    1、点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）<br>    2、发布/订阅模式（消费者消费数据后不会清除数据）</p>
<p>一个kafka集群中有多个broker（每台机器一个broker），一个broker中多个topic，一个topic中有多个分区partition，每个partition可有多个副本，副本必须分布在不同机器否则无意义，副本中有一个leader，其他为follower；只对leader进行读写，follower只是备份；</p>
<p>消息存储：逻辑上每个partition分为多个segment，每个segment中有存储文件索引的index文件和存储数据的log文件。物理表现为每个partition都有一个文件夹，其中有各个分区的log和index文件，命名规则为当前文件首条消息的offset；</p>
<p>如何定位到指定offset的消息：通过二分法查找到小于等于指定offset的最大offset文件，用 N=（指定offse - 此文件offset）即可找到指定offset消息的索引，即在此index索引文件中第N条消息在log数据文件中的偏移量，从对应log文件中此偏移量位置开始读取，<br>消息结构包含offset和消息大小，所以可以确定读到哪里截止。</p>
<p>producer生产消息存放：<br>    1、指定partition、key、value，存到指定分区<br>    2、指定key、value，通过key的hash值与topic的partition取余存到对应分区<br>    3、指定value，第一次调用随机生成一个整数（后续递增），将此值与partition取余得到对应分区，即轮询</p>
<p>数据可靠性保证：topic每个partition收到producer发送的数据后，都需向producer发送ack，若没收到会重新发送</p>
<p>何时发送ack?<br>    确保有follower和leader同步完成，leader再发送ack，这样才能保证leader挂掉后能在follower中选出新的leader<br>多少个follower同步完成后发送ack？<br>    方案1、半数以上完成。优点：延迟低  缺点：选举leader时，容忍n台机器故障需要2n+1个副本<br>    方案2、全部完成同步。优点：选举新leader时，容忍n台故障需要n+1个副本  缺点：延迟高<br>Kafka选择了第二种，因为：<br>    1、同样为了容忍n台节点故障，方案1需要多出n个副本，而kafka每个分区都有大量数据，方案一会造成大量数据冗余<br>    2、网络延迟对kafka影响较小</p>
<p>ISR<br>    方案2当有一个follower因某种故障迟迟不能与leader同步那么leader就会一直等下去，直到同步才会发送ack。怎么解决这个问题？<br>    leader维护了一个动态的in-sync-replica set（ISR），意为和leader保持同步的follower集合，当ISR中follower完成数据同步后leader就会发送ack，若有follower迟迟不能同步，则将该follower踢出ISR，该事件阀值由replica.lag.time.max.ms参数设定，leader故障就会从ISR选举新leader</p>
<p>ack应答机制（可靠性级别）<br>    0：producer不等待broker的ack，broker一接收到没落盘就返回。beoker故障可能数据丢失。<br>    1：等待ack，leader落盘成功后返回ack，若在follower同步成功前leader故障会导致数据丢失。<br>    -1：等待ack，leader和follower全部落盘成功才返回。若在follower同步后，broker发送ack之前，leader故障会导致数据重复。</p>
<p>Log文件中的LEO和HW<br>    LEO：log end offse，每个副本最后一个offset<br>    HW：high watermark，所有副本中最小的LEO，消费者能见到的最大offset</p>
<p>1、follower故障<br>    故障后会被临时踢出ISR，待该follower恢复后。会读取磁盘上次记录的HW，将高于HW部分截掉，从HW开始向leader同步，等该follower的LEO大于等于该partition的HW，及即follower追上leader后，重新加入ISR</p>
<p>2、leader故障<br>    leader故障后会从ISR选出新的leader，为保证多个副本数据一致性，其余follower会先将各自log文件高于HW部分截掉，然后从新的leader同步数据<br>    （只能保证副本间数据一致性，不保证数据不丢失或不重复）</p>
<p>Exactly Once语义<br>    Ack级别设为,-1,保证不会丢失数据，即At Least Once<br>    Ack级别设为0，保证生产者只发送一次，即At Most Once<br>    Kafka0.11版本之前不能保证既不重复也不丢失，0.11后增加幂等性，At Least Once + 幂等性 = Exactly Once<br>启用幂等性只需将producer参数中enable.idompotence设为true即可，开启后producer会在初始化时分配一个PID，发往同一partition的消息会带上sequence Number，而Broker端会对&lt;PID,Partition,SeqNumber&gt;缓存，当相同主键消息提交时broker只会持久化一条</p>
<p>消费者：<br>    消费方式：Kafka采用pull拉模式从broker中读取数据<br>    push推模式很难适应消费速率不同的消费者，因为发送速率由broker决定<br>    pull模式缺点是无数据时也会循环取空数据；针对这点Kafka在消费时会传入一个timeout参数，无数据时会等上timeout的时间再返回。</p>
<p>消费者分区分配：<br>    1、Range（默认）：假如有10个分区0-9 3个消费者C1 C2 C3 则C1：0,1,2,3 C2:4,5,6 C3:7,8,9<br>        基于主题，同一个消费者组哪些成员指定了相同的主题则由这些成员去消费该主题分区。如有一个主题分区为0-6这7个分区，同组两个消费者B、D消费该主题，则B被分配0-3这4个分区，D被分配4-6这三个。<br>        当同组多个消费者消费主题相同且数量较多时，可能会导致B消费20个，D消费15个，消费不平衡。<br>    2、RoundRobin: 轮询  3个消费者C0 C1 C2 集群中三个主题t0,t1,t2 这三个主题分别有1、2、3个分区，即t0p0,t1p0,t1p1,t2p0,t2p1,t2p2这6个分区<br>        C0订阅主题t0，消费者C1订阅了主题t0和t1，C2订阅了t0 t1 t2<br>        C0：t0p0     C1:t1p0     C2:t1p1、t2p0、t2p1、t2p2</p>
<pre><code>3、Sticky：黏性分区  1、轮询  2、最优配置 3、分配尽可能和上次分配的保持相同
    C0：t0p0     C1:t1p0、t1p1    C2:t2p0、t2p1、t2p2</code></pre><p>Rebalance触发时机:<br>    1、组成员个数发生变化<br>    2、订阅topic个数发生变化<br>    3、订阅topic的分区数发生变化</p>
<p>消费者offset维护：<br>    0.9之前默认将offset保存在Zookeeper中，0.9之后默认将offset保存在Kafka一个内置的topic中_consumer_offsets<br>    消费者组G+主题T+分区P来确定offset</p>
<p>reset：若存在已提交的offset，不管设置为earliest或者latest都会从已提交的offset处开始消费；若不存在已提交的offset，earliest表示从头开始消费，latest表示消费最新数据。<br>none:topic各分区都存在已提交的offset时从offset开始消费，只要有一个分区不存在已提交的offset抛出异常</p>
<p>Kafka事务<br>    Producer事务：PID和Transaction ID绑定，producer重启后可通过Transaction ID获取原来的PID；Transaction Coordinator会将事务状态保存到Kafka的一个内部topic</p>
<pre><code>Consumer事务：
事务机制主要从Producer方面考虑，对于Consumer而言无法保证commit的信息被精确消费，由于Consumer可通过offset访问任意信息，而且不同Segment File生命周期不同，同一事务消息可能出现重启后被删除的情况</code></pre><p>Kafka API<br>    Producer发送消息：异步发送，main线程将消息发送给RecordAccumulator，Sender线程不断从中拉取消息发送到Kafka broker<br>    batch.size：数据累积到batch.size后sender才会发送数据<br>    linger.ms：如果数据迟迟未达到batch.size,sender等待linger.ms之后就会发送数据。</p>
<p>自定义分区 Partition</p>
<p>自定义存储offset：ConsumerRebalanceListener<br>    自动提交/手动提交可能会导致漏消费数据/重复消费数据，可自定义存储offset</p>
<p>自定义拦截器  ProducerInterceptor</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yyguy123" src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">yyguy123</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yyguy123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yyguy123" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yyguy123@gmail.com" title="E-Mail → mailto:yyguy123@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yyguy123</span>
</div>
  
  <div>
      <span>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
