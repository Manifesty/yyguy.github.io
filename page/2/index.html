<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="folyjzSrNTxM-gzANuN149Z3GWMMc4Go2VluVGIRh48">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yyguy123.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="yyguy123的个人博客">
<meta property="og:url" content="http://yyguy123.github.io/page/2/index.html">
<meta property="og:site_name" content="yyguy123的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yyguy123">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yyguy123.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>yyguy123的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yyguy123的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">若无闲事挂心头，便是人间好时节</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2020/04/07/Spring%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/Spring%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">Spring事务</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 22:19:53" itemprop="dateCreated datePublished" datetime="2020-04-07T22:19:53+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 19:25:39" itemprop="dateModified" datetime="2020-05-01T19:25:39+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<h2 style="margin-left:0cm;"> </h2>

<h2 style="margin-left:0cm;"><strong>一、数据库的事物的基本特性</strong></h2>

<div>
<p style="margin-left:0cm;">事物是区分文件存储系统与Nosql数据库重要特性之一，其存在的意义是为了保证即使在并发情况下也能正确的执行crud操作。怎样才算是正确的呢？这时提出了事物需要保证的四个特性即ACID：</p>
</div>

<ol><li>A: 原子性(atomicity)
    <ul><li><span style="color:#a5a5a5;">事物中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事物的失败；</span></li>
    </ul></li>
    <li>C: 一致性(consistency)
    <ul><li><span style="color:#a5a5a5;">事物结束后系统状态是一致的；</span></li>
    </ul></li>
    <li>I:  隔离性(isolation)
    <ul><li><span style="color:#a5a5a5;">并发执行的事物彼此无法看到对方的中间状态；</span></li>
    </ul></li>
    <li>D: 持久性(durability)
    <ul><li><span style="color:#a5a5a5;">事物完成后所做的改动都会被持久化，即使发生灾难性的失败。</span></li>
    </ul></li>
</ol><p style="margin-left:0cm;">在高并发的情况下，要完全保证其ACID特性是非常困难的，除非把所有的事物串行化执行，但带来的负面的影响将是性能大打折扣。很多时候我们有些业务对事物的要求是不一样的，所以数据库中设计了四种隔离级别，供用户基于业务进行选择。</p>

<table border="1" cellspacing="0" style="margin-left:.5pt;width:412.7pt;"><tbody><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#4f4f4f;">隔离级别</span></strong></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#4f4f4f;">脏读（Dirty Read）</span></strong></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#4f4f4f;">不可重复读（NonRepeatable Read）</span></strong></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#4f4f4f;">幻读（Phantom Read）</span></strong></p>
            </td>
        </tr><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><span style="color:#4f4f4f;">未提交读（Read uncommitted）</span></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
        </tr><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><span style="color:#4f4f4f;">已提交读（Read committed）</span></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
        </tr><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><span style="color:#4f4f4f;">可重复读（Repeatable read）</span></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">可能</span></p>
            </td>
        </tr><tr><td style="width:113.9pt;">
            <p style="margin-left:0cm;"><span style="color:#4f4f4f;">可串行化（SERIALIZABLE）</span></p>
            </td>
            <td style="width:77.05pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:131.3pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
            <td style="width:90.45pt;">
            <p style="margin-left:0cm;"><span style="color:#1c7231;">不可能</span></p>
            </td>
        </tr></tbody></table><p> </p>

<p style="margin-left:0cm;"><strong>脏读 :</strong></p>

<p style="margin-left:0cm;"><span style="color:#a5a5a5;">一个事物读取到另一事物未提交的更新数据</span></p>

<p style="margin-left:0cm;"><strong>不可重复读 : </strong></p>

<p style="margin-left:0cm;"><span style="color:#a5a5a5;">在同一事物中,多次读取同一数据返回的结果有所不同, 换句话说, 后续读取可以读到另一事物已提交的更新数据. 相反, “可重复读”在同一事物中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事物已提交的更新数据。</span></p>

<p style="margin-left:0cm;"><strong>幻读 :</strong></p>

<p style="margin-left:0cm;"><span style="color:#a5a5a5;">在同一事物中,多次读取同一表数据条数返回的结果有所不同,</span></p>

<p style="margin-left:0cm;"> <span style="color:#a5a5a5;">查询表中一条数据如果不存在就插入一条，并发的时候却发现，里面居然有两条相同的数据。这就幻读的问题。</span></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>数据库默认隔离级别：</strong></p>

<p style="margin-left:0cm;">Oracle中默认级别是 Read committed</p>

<p style="margin-left:0cm;">mysql 中默认级别 Repeatable read。另外要注意的是mysql 执行一条查询语句默认是一个独立的事物，所以看上去效果跟Read committed一样。</p>

<p style="margin-left:0cm;"># 查看mysql 的默认隔离级别</p>

<p style="margin-left:0cm;">SELECT @@tx_isolation</p>

<p style="margin-left:0cm;"> </p>

<div>
<h2 style="margin-left:0cm;"><strong>二、Sring 对事物的支持与使用</strong></h2>

<p style="margin-left:0cm;"><strong>1、spring 事物相关API说明</strong></p>

<p style="margin-left:0cm;">spring 事物是在数据库事物的基础上进行封装扩展 其主要特性如下：</p>

<ol><li>
    <ol><li>支持原有的数据事物的隔离级别</li>
        <li>加入了事物传播的概念 提供多个事物的和并或隔离的功能</li>
        <li>提供声明式事物，让业务代码与事物分离，事物变得更易用。</li>
    </ol></li>
</ol><p style="margin-left:0cm;">怎么样去使用Spring事物呢？spring 提供了三个接口供使用事物。分别是：</p>

<p style="margin-left:0cm;"> </p>

<ol><li>TransactionDefinition
    <ul><li><span style="color:#a5a5a5;">事物定义</span></li>
    </ul></li>
    <li>PlatformTransactionManager
    <ul><li><span style="color:#a5a5a5;">事物管理</span></li>
    </ul></li>
    <li>TransactionStatus
    <ul><li><span style="color:#a5a5a5;">事物运行时状态</span></li>
    </ul></li>
</ol><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>接口结构图：</strong></p>

<p style="margin-left:0cm;"><img alt height="241" src="https://img-blog.csdnimg.cn/2020040722121591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQ0Njk1,size_16,color_FFFFFF,t_70" width="547"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>API说明：</strong></p>

<pre>
<code class="language-java">public class SpringTransactionExample {
    private static String url = "jdbc:mysql://192.168.0.147:3306/test";
    private static String user = "root";
    private static String password = "123456";

    public static Connection openConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://192.168.0.147:3306/test", "root", "123456");
        return conn;
    }

    public static void main(String[] args) {
        final DataSource ds = new DriverManagerDataSource(url, user, password);
        final TransactionTemplate template = new TransactionTemplate();
        template.setTransactionManager(new DataSourceTransactionManager(ds));
        template.execute(new TransactionCallback&lt;Object&gt;() {
            @Override
            public Object doInTransaction(TransactionStatus status) {
                Connection conn = DataSourceUtils.getConnection(ds);
                Object savePoint = null;
                try {
                    {
                        // 插入
                        PreparedStatement prepare = conn.
                                prepareStatement("insert INTO account (accountName,user,money) VALUES (?,?,?)");
                        prepare.setString(1, "111");
                        prepare.setString(2, "aaaa");
                        prepare.setInt(3, 10000);
                        prepare.executeUpdate();
                    }
                    // 设置保存点
                    savePoint = status.createSavepoint();
                    {
                        // 插入
                        PreparedStatement prepare = conn.
                                prepareStatement("insert INTO account (accountName,user,money) VALUES (?,?,?)");
                        prepare.setString(1, "222");
                        prepare.setString(2, "bbb");
                        prepare.setInt(3, 10000);
                        prepare.executeUpdate();
                    }
                    {
                        // 更新
                        PreparedStatement prepare = conn.
                                prepareStatement("UPDATE account SET money= money+1 where user=?");
                        prepare.setString(1, "asdflkjaf");
                        Assert.isTrue(prepare.executeUpdate() &gt; 0, "");
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                } catch (Exception e) {
                    System.out.println("更新失败");
                    if (savePoint != null) {
                        status.rollbackToSavepoint(savePoint);
                    } else {
                        status.setRollbackOnly();
                    }
                }
                return null;
            }
        });
    }
}
</code></pre>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>2、声明示事物</strong></p>

<p style="margin-left:0cm;">我们前面是通过调用API来实现对事物的控制，这非常的繁琐，与直接操作JDBC事物并没有太多的改善，所以Spring提出了声明示事物，使我们对事物的操作变得非常简单，甚至不需要关心它。</p>

<p style="margin-left:0cm;">配置spring.xml</p>

<pre>
<code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;context:annotation-config/&gt;
    &lt;context:component-scan base-package="com.test.service.**"&gt;
    &lt;/context:component-scan&gt;

    &lt;bean class="org.springframework.jdbc.core.JdbcTemplate"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;!-- similarly, don't forget the PlatformTransactionManager --&gt;
    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;
    &lt;!-- don't forget the DataSource --&gt;
    &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;constructor-arg name="url" value="jdbc:mysql://192.168.0.147/test"/&gt;
        &lt;constructor-arg name="username" value="root"/&gt;
        &lt;constructor-arg name="password" value="123456"/&gt;
    &lt;/bean&gt;
    &lt;tx:annotation-driven transaction-manager="txManager"&gt;&lt;/tx:annotation-driven&gt;
&lt;/beans&gt;
</code></pre>

<p style="margin-left:0cm;">编写服务类</p>

<pre>
<code class="language-java">@Transactional
public void addAccount(String name, int initMenoy) {
    String accountid = new SimpleDateFormat("yyyyMMddhhmmss").format(new Date());
    jdbcTemplate.update("insert INTO account (accountName,user,money) VALUES (?,?,?)", accountid, name, initMenoy);
    // 人为报错
    int i = 1 / 0;
}
</code></pre>

<p style="margin-left:0cm;"><strong>3、事物传播机制</strong></p>

<p style="margin-left:0cm;"> </p>

<table border="1" cellspacing="0" style="margin-left:.5pt;width:412.7pt;"><tbody><tr><td style="width:75pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">类别</span></strong></p>
            </td>
            <td style="width:173.5pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">事物传播类型</span></strong></p>
            </td>
            <td style="width:164.15pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">说明</span></strong></p>
            </td>
        </tr><tr><td rowspan="3" style="width:75pt;">
            <p style="margin-left:0cm;">支持当前事物</p>
            </td>
            <td style="width:173.5pt;">
            <p style="margin-left:0cm;"><span style="color:#ff0000;">PROPAGATION_REQUIRED</span></p>

<pre><code>    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（必须的）&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;如果当前没有事物，就新建一个事物，如果已经存在一个事物中，加入到这个事物中。这是最常见的选择。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_SUPPORTS&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（支持）&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;支持当前事物，如果当前没有事物，就以非事物方式执行。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_MANDATORY&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（强制）&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;使用当前的事物，如果当前没有事物，就抛出异常。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;3&quot; style=&quot;width:75pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;不支持当前事物&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_REQUIRES_NEW&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;隔离)&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;新建事物，如果当前存在事物，把当前事物挂起。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_NOT_SUPPORTED&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;不支持)&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;以非事物方式执行操作，如果当前存在事物，就把当前事物挂起。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_NEVER&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;(强制非事物)&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;以非事物方式执行，如果当前存在事物，则抛出异常。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:75pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;套事物&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:173.5pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;PROPAGATION_NESTED&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（嵌套事物）&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;width:164.15pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;如果当前存在事物，则在嵌套事物内执行。如果当前没有事物，则执行与PROPAGATION_REQUIRED类似的操作。&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;strong&gt;常用事物传播机制：&lt;/strong&gt;&lt;/p&gt;</code></pre><ol><li>PROPAGATION_REQUIRED，
    <ul><li><span style="color:#a5a5a5;">这个也是默认的传播机制；</span></li>
    </ul></li>
    <li>PROPAGATION_NOT_SUPPORTED
    <ul><li><span style="color:#a5a5a5;">可以用于发送提示消息，站内信、短信、邮件提示等。不属于并且不应当影响主体业务逻辑，即使发送失败也不应该对主体业务逻辑回滚。</span></li>
    </ul></li>
    <li>PROPAGATION_REQUIRES_NEW
    <ul><li><span style="color:#a5a5a5;">总是新启一个事物，这个传播机制适用于不受父方法事物影响的操作，比如某些业务场景下需要记录业务日志，用于异步反查，那么不管主体业务逻辑是否完成，日志都需要记录下来，不能因为主体业务逻辑报错而丢失日志；</span></li>
    </ul></li>
</ol><p style="margin-left:0cm;"><strong>用例1:</strong></p>

<p style="margin-left:0cm;">创建用户时初始化一个帐户，表结构和服务类如下。</p>

<table border="1" cellspacing="0" style="margin-left:.5pt;width:387.9pt;"><tbody><tr><td style="width:103.15pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">表结构</span></strong></p>
            </td>
            <td style="width:103.15pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">服务类</span></strong></p>
            </td>
            <td style="width:181.55pt;">
            <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">功能描述</span></strong></p>
            </td>
        </tr><tr><td style="vertical-align:top;width:103.15pt;">
            <p style="margin-left:0cm;">user</p>
            </td>
            <td style="vertical-align:top;width:103.15pt;">
            <p style="margin-left:0cm;">UserSerivce</p>
            </td>
            <td style="vertical-align:top;width:181.55pt;">
            <p style="margin-left:0cm;">创建用户，并添加帐户</p>
            </td>
        </tr><tr><td style="vertical-align:top;width:103.15pt;">
            <p style="margin-left:0cm;">account</p>
            </td>
            <td style="vertical-align:top;width:103.15pt;">
            <p style="margin-left:0cm;">AccountService</p>
            </td>
            <td style="vertical-align:top;width:181.55pt;">
            <p style="margin-left:0cm;">添加帐户</p>
            </td>
        </tr></tbody></table><p style="margin-left:0cm;">UserSerivce.createUser(name) 实现代码</p>

<pre>
<code class="language-java">@Transactional
public void createUser(String name) {
    // 新增用户基本信息
    jdbcTemplate.update("INSERT INTO `user` (name) VALUES(?)", name);
    //调用accountService添加帐户
    accountService.addAccount(name, 10000);
 ｝

AccountService.addAccount(name,initMoney) 实现代码（方法的最后有一个异常）
@Transactional(propagation = Propagation.REQUIRED)
public void addAccount(String name, int initMoney) {
    String accountid = new SimpleDateFormat("yyyyMMddhhmmss").format(new Date());
    jdbcTemplate.update("insert INTO account (accountName,user,money) VALUES (?,?,?)", accountid, name, initMenoy);
    // 出现分母为零的异常
    int i = 1 / 0;
}
</code></pre>

<p style="margin-left:0cm;">实验预测一：</p>

<table border="1" cellspacing="0" style="margin-left:.5pt;width:412.7pt;"><tbody><tr><td style="vertical-align:top;width:54.9pt;">
            <p style="margin-left:0cm;"> </p>
            </td>
            <td style="width:120.6pt;">
            <p style="margin-left:0cm;">createUser</p>
            </td>
            <td style="width:113.9pt;">
            <p style="margin-left:0cm;">addAccount<span style="color:#ff0000;">(</span><span style="color:#ff0000;">异常)</span></p>
            </td>
            <td style="width:123.25pt;">
            <p style="margin-left:0cm;">预测结果</p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景一</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">无事物</p>
            </td>
            <td style="vertical-align:top;width:113.9pt;">
            <p style="margin-left:0cm;">required</p>
            </td>
            <td style="vertical-align:top;width:123.25pt;">
            <p style="margin-left:0cm;">user （成功） Account（不成功） <span style="color:#1c7231;">正确</span></p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景二</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">required</p>
            </td>
            <td style="vertical-align:top;width:113.9pt;">
            <p style="margin-left:0cm;">无事物</p>
            </td>
            <td style="vertical-align:top;width:123.25pt;">
            <p style="margin-left:0cm;">user （不成功） Account（不成功） <span style="color:#1c7231;">正确</span></p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景三</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">required</p>
            </td>
            <td style="vertical-align:top;width:113.9pt;">
            <p style="margin-left:0cm;">not_supported</p>
            </td>
            <td style="vertical-align:top;width:123.25pt;">
            <p style="margin-left:0cm;">user （不成功） Account（成功）<span style="color:#1c7231;">正确</span></p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景四</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">required</p>
            </td>
            <td style="vertical-align:top;width:113.9pt;">
            <p style="margin-left:0cm;">required_new</p>
            </td>
            <td style="vertical-align:top;width:123.25pt;">
            <p style="margin-left:0cm;">user （不成功） Account（不成功）<span style="color:#1c7231;">正确</span></p>
            </td>
        </tr><tr><td style="width:54.9pt;">
            <p style="margin-left:0cm;">场景五</p>
            </td>
            <td style="vertical-align:top;width:120.6pt;">
            <p style="margin-left:0cm;">required</p>

<pre><code>    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;异常移至createUser方法未尾)&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt; &lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:113.9pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;required_new&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:123.25pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;user （不成功） Account（成功）&lt;span style=&quot;color:#1c7231;&quot;&gt;正确&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:54.9pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;场景六&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:120.6pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;required&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;异常移至createUser方法未尾)&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#000000;&quot;&gt;（&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;addAccount &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;方法称至当前类&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;）&lt;/span&gt;&lt;/p&gt;

    &lt;p style=&quot;margin-left:0cm;&quot;&gt; &lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:113.9pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;required_new&lt;/p&gt;
    &lt;/td&gt;
    &lt;td style=&quot;vertical-align:top;width:123.25pt;&quot;&gt;
    &lt;p style=&quot;margin-left:0cm;&quot;&gt;user （不成功） Account（不成功）&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p style=&quot;margin-left:0cm;&quot;&gt; &lt;/p&gt;</code></pre><div>
<h2 style="margin-left:0cm;"><strong>三、aop 事物底层实现原理</strong></h2>
</div>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">讲事物原理之前我们先来做一个实验，当场景五的环境改变，把addAccount 方法移至UserService 类下，其它配置和代码不变：</p>

<pre>
<code class="language-java">@Override
@Transactional
public void createUser(String name) {
    jdbcTemplate.update("INSERT INTO `user` (name) VALUES(?)", name);
    addAccount(name, 10000);
    // 人为报错
    int i = 1 / 0;
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void addAccount(String name, int initMoney) {
    String accountid = new SimpleDateFormat("yyyyMMddhhmmss").format(new Date());
    jdbcTemplate.update("insert INTO account (accountName,user,money) VALUES (?,?,?)", accountid, name, initMoney);
}
</code></pre>

<p style="margin-left:0cm;">经过演示我们发现得出的结果与场景五并不 一至，required_new 没有起到其对应的作用。原因在于spring 声明示事物使用动态代理实现，而当调用同一个类的方法时，是会不会走代理逻辑的，自然事物的配置也会失效。</p>

<p style="margin-left:0cm;">通过一个动态代理的实现来模拟这种场景</p>

<pre>
<code class="language-java">UserSerivce proxyUserSerivce = (UserSerivce) Proxy.newProxyInstance(TestTransaction.class.getClassLoader(),
        new Class[]{UserSerivce.class}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                try {
                    System.out.println("开启事物:"+method.getName());
                    return method.invoke(userSerivce, args);
                } finally {
                    System.out.println("关闭事物:"+method.getName());
                }
            }
        });
proxyUserSerivce.createUser("test");
</code></pre>

<p style="margin-left:0cm;">当我们调用createUser 方法时 仅打印了 createUser  的事物开启、关闭，并没有打印addAccount 方法的事物开启、关闭，由此可见addAccount  的事物配置是失效的。</p>

<p style="margin-left:0cm;">如果业务当中上真有这种场景该如何实现呢？在spring xml中配置 暴露proxy 对象，然后在代码中用AopContext.currentProxy() 就可以获当前代理对象</p>

<p style="margin-left:0cm;">&lt;!-- 配置暴露proxy --&gt;</p>

<p style="margin-left:0cm;">&lt;aop:aspectj-autoproxy expose-proxy="true"/&gt;</p>

<p style="margin-left:0cm;">// 基于代理对象调用创建帐户，事物的配置又生效了</p>

<p style="margin-left:0cm;">((UserSerivce) AopContext.currentProxy()).addAccount(name, 10000);</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>
</td></tr></tbody></table></td></tr></tbody></table></div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2020/03/20/Hello/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/Hello/" class="post-title-link" itemprop="url">Hello</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 21:57:28" itemprop="dateCreated datePublished" datetime="2020-03-20T21:57:28+08:00">2020-03-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2020/03/20/Git%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/Git%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Git基本概念和底层原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 20:17:01" itemprop="dateCreated datePublished" datetime="2020-03-20T20:17:01+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-20 20:18:08" itemprop="dateModified" datetime="2020-03-20T20:18:08+08:00">2020-03-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GIT和SVN的主要区别"><a href="#GIT和SVN的主要区别" class="headerlink" title="GIT和SVN的主要区别"></a>GIT和SVN的主要区别</h1><ol>
<li>存储方式不一样</li>
<li>使用方式不一样</li>
<li>管理模式不一样</li>
</ol>
<p><strong>1、存储方式区别</strong><br>   GIT把内容按元数据方式存储类似k/v数据库，而SVN是按文件(新版svn已改成元数据存储)<br>       演示git 存储过程演示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .git/objects/df/</span><br><span class="line">git cat-file -p df70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'version1'</span> &gt; text.txt</span><br><span class="line">git <span class="built_in">hash</span>-object -w text.txt</span><br></pre></td></tr></table></figure>

<p><strong>2、使用方式区别</strong><br>    从本地把文件推送远程服务，SVN只需要commint 而GIT需要 add、commint、push 三个步骤<br>SVN基本使用过程<br><img src="https://img-blog.csdnimg.cn/20200207220323296.png" alt="在这里插入图片描述"><br>Git基本使用过程<br><img src="https://img-blog.csdnimg.cn/2020020722041424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQ0Njk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3、版本管理模式区别</strong><br>git 是一个分布式的版本管理系统，而要SVN是一个远程集中式的管理系统</p>
<p>集中式<br><img src="https://img-blog.csdnimg.cn/202002072204584.png" alt="在这里插入图片描述"><br>分布式<br><img src="https://img-blog.csdnimg.cn/202002072205124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQ0Njk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="二、GIT-核心命令使用"><a href="#二、GIT-核心命令使用" class="headerlink" title="二、GIT 核心命令使用"></a>二、GIT 核心命令使用</h1><p>主要内容:</p>
<ol>
<li>git 客户端安装配置</li>
<li>整体认识GIT的基本使用</li>
<li>分支管理</li>
<li>标签管理</li>
<li>远程仓库配置</li>
</ol>
<p><strong>1、安装git 客户端安装</strong><br>官方客户端： httpsd://git-scm.com/downloads<br>其它客户端：<a href="https://tortoisegit.org/download/" target="_blank" rel="external nofollow noopener noreferrer">https://tortoisegit.org/download/</a></p>
<p><strong>2、认识GIT的基本使用</strong></p>
<ol>
<li>git 项目创建与克隆</li>
<li>文件提交与推送<br>完整模拟从项目添加到push 过程<ul>
<li>创建项目 </li>
<li>初始化git仓库</li>
<li>提交文件 </li>
<li>远程关联 </li>
<li>push 至远程仓库</li>
</ul>
</li>
</ol>
<p><strong>本地初始化GIT 仓库:</strong><br>#基于远程仓库克隆至本地</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;remote_url&gt;</span><br></pre></td></tr></table></figure>
<p>#当前目录初始化为git 本地仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init  &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>基于mvn 模板创建项目<br>mvn archetype:generate</p>
<p>本地添加<br>#添加指定文件至暂存区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;fileName&gt;</span><br></pre></td></tr></table></figure>
<p>#添加指定目录至暂存区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>#添加所有</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure>
<p>#将指定目录及子目录移除出暂存区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;target&gt; -r</span><br></pre></td></tr></table></figure>
<p>#将该文件从commit后撤回到add后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;target&gt;</span><br></pre></td></tr></table></figure>
<p>#添加忽略配置文件 .gitignore</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以'#'开始的行，被视为注释.                                                                                                                          </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略掉所有文件名是 foo.txt的文件.</span></span><br><span class="line"></span><br><span class="line">foo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有生成的 html文件,</span></span><br><span class="line"></span><br><span class="line">*.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># foo.html是手工维护的，所以例外.</span></span><br><span class="line"></span><br><span class="line">!foo.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有.o和 .a文件.</span></span><br><span class="line"></span><br><span class="line">*.[oa]</span><br><span class="line">配置语法：</span><br><span class="line">以斜杠“/”开头表示目录；</span><br><span class="line">以星号“*”通配多个字符；</span><br><span class="line">以问号“?”通配单个字符</span><br><span class="line">以方括号“[]”包含单个字符的匹配列表；</span><br><span class="line">以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</span><br></pre></td></tr></table></figure>
<p>本地提交<br>#提交至本地仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit &lt;file&gt; -m <span class="string">'提交评论'</span></span><br></pre></td></tr></table></figure>
<p>#快捷提交至本地仓库 <em>新增文件不能直接用此命令</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am <span class="string">'快添加与提交'</span></span><br></pre></td></tr></table></figure>
<p>#查看修改历史</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git blame 文件名 // 查看该文件的修改历史</span><br><span class="line">git blame -L 100,10 文件名 // 从100行开始，到110行 逐行查看文件的修改历史</span><br></pre></td></tr></table></figure>
<p>#对比工作区，暂存区，仓库的差异</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git diff // 查看变更 工作区与暂存区的差异比对</span><br><span class="line">git diff --cached // 暂存区与提交版本的差异</span><br><span class="line">git diff HEAD // 工作区与仓库中最后一次提交版本的差别</span><br><span class="line">git diff 版本哈希值 版本哈希值 // 查看这2个版本哈希之间的区别</span><br><span class="line">或者 git diff HEAD~数字 HEAD~数字</span><br><span class="line">git tag tt HEAD~4 给倒数第5次提交打一个tag tag名字是tt</span><br><span class="line">git diff tt 就是倒数第5个版本与第一个版本之间的差异</span><br><span class="line">git diff --cached tt 暂存区与倒数第5个版本之间的比对</span><br></pre></td></tr></table></figure>
<p>#回撤操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m <span class="string">"提交信息"</span> // 回撤上一次提交并与本次工作区一起提交</span><br><span class="line">git reset HEAD~2 --hard // 回撤2步</span><br><span class="line">git reset --files // 从仓库回撤到暂存区</span><br><span class="line">git reset HEAD // 回撤暂存区内容到工作目录</span><br><span class="line">git reset HEAD --soft 回撤提交到暂存区</span><br><span class="line">git reset HEAD --hard // 回撤提交 放弃变更 (慎用)</span><br><span class="line">git reset HEAD^  // 回撤仓库最后一次提交</span><br><span class="line">git reset --hard commitid // 回撤到该次提交id的位置</span><br><span class="line"></span><br><span class="line">git push -f -u origin 分支名 所有内容都回撤完了 将回撤后的操作强制推送到远程分支</span><br></pre></td></tr></table></figure>
<p>#标签操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git tag // 查看列出所有打过的标签名</span><br><span class="line">git tag -d 标签名 // 删除对应标签</span><br><span class="line">git tag 标签名字 // 在当前仓库打个标签</span><br><span class="line">git tag foo -m <span class="string">"message"</span> // 在当前提交上，打标签foo 并给message信息注释</span><br><span class="line">git tag 标签名 哈希值 -m <span class="string">"message"</span> // 在某个哈希值上打标签并且写上标签的信息</span><br><span class="line">git tag foo HEAD~4 // 在当前提交之前的第4个版本上 打标签foo</span><br><span class="line">git push origin --tags // 把所有打好的标签推送到远程仓库</span><br><span class="line">git push origin 标签名 // 把指定标签推送到远程仓库</span><br><span class="line">git stash // 把暂存区的内容 暂时放在其他中 使暂存区变空</span><br><span class="line">git stash list // 查看stash了哪些存储</span><br><span class="line">git stash pop // 将stash中的内容恢复到当前目录，将缓存堆栈中的对应stash删除</span><br><span class="line">git stash apply // 将stash中的内容恢复到当前目录，不会将缓存堆栈中的对应stash删除</span><br><span class="line">git stash clear // 删除所有缓存的stash</span><br><span class="line">git pull --tags // 把远程仓库的标签也拉取下来</span><br><span class="line">git push origin :refs/tags/远程标签名 // 删除远程仓库的标签</span><br></pre></td></tr></table></figure>
<p>#日志管理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %ad | %s%d [%an]'</span> --graph --date=short</span><br><span class="line">// 获取git <span class="built_in">log</span>里的树形详细信息 包括hasg 日期 提交信息 提交人等</span><br><span class="line">git <span class="built_in">log</span> --oneline //拉出所有提交信息 q是退出</span><br><span class="line">git <span class="built_in">log</span> -5 // 查看前5次的提交记录</span><br><span class="line">git <span class="built_in">log</span> --oneline -5 // 打印出的日志里面只有哈希值和修改的内容备注</span><br><span class="line">git <span class="built_in">log</span> 文件名 // 查看该文件的提交</span><br><span class="line">git <span class="built_in">log</span> --grep // 想过滤看到的内容   过滤日志</span><br><span class="line">git <span class="built_in">log</span> -n // 查看近期提交的n条信息内容</span><br><span class="line">git <span class="built_in">log</span> -p // 查看详细提交记录</span><br><span class="line">git <span class="built_in">log</span> master..experiment  //比较两个版本的区别</span><br></pre></td></tr></table></figure>

<p><strong>3、分支管理</strong><br>#查看当前分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [-avv]</span><br></pre></td></tr></table></figure>
<p>#基于当前分支新建分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch  &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<p>#基于提交新建分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch name&gt; &lt;commit id&gt;</span><br></pre></td></tr></table></figure>
<p>#把远程分支拉到本地</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin dev（dev为远程仓库的分支名）</span><br></pre></td></tr></table></figure>

<p>#删除分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<p>#切换分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<p>#合并分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;merge target&gt;</span><br></pre></td></tr></table></figure>
<p>#解决冲突，如果因冲突导致自动合并失败，此时 status 为mergeing 状态.<br>#需要手动修改后重新提交（commit） </p>
<p><strong>4、远程仓库管理</strong><br>#查看远程配置 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote [-v]</span><br></pre></td></tr></table></figure>
<p>#添加远程地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http:xxx.xxx</span><br></pre></td></tr></table></figure>
<p>#删除远程地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>
<p>#上传新分支至远程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin master</span><br></pre></td></tr></table></figure>
<p>#将本地分支与远程建立关联</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --track --<span class="built_in">set</span>-upstream-to=origin/<span class="built_in">test</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h1 id="三、git-底层原理"><a href="#三、git-底层原理" class="headerlink" title="三、git 底层原理"></a>三、git 底层原理</h1><ul>
<li>GIT存储对像</li>
<li>GIT树对像</li>
<li>GIT提交对像</li>
<li>GIT引用</li>
</ul>
<p><strong>1、GIT存储对像(hashMap)</strong><br>Git 是一个内容寻址文件系统，其核心部分是一个简单的键值对数据库（key-value data store），你可以向数据库中插入任意内容，它会返回一个用于取回该值的hash 键。</p>
<p>#git 键值库中插入数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'luban is good man'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">79362d07cf264f8078b489a47132afbc73f87b9a</span><br></pre></td></tr></table></figure>

<p>#基于键获取指定内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p 79362d07cf264f8078b489a47132afbc73f87b9a</span><br></pre></td></tr></table></figure>

<p>Git基于该功能 把每个文件的版本中内容都保存在数据库中，当要进行版本回滚的时候就通过其中一个键将期取回并替换。</p>
<p>    模拟演示git 版写入与回滚过程<br>#查找所有的git 对像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .git/objects/ -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>

<p>#写入版本1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'version1'</span> &gt; README.MF; git <span class="built_in">hash</span>-object -w README.MF;</span><br></pre></td></tr></table></figure>

<p>#写入版本2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'version2'</span> &gt; README.MF; git <span class="built_in">hash</span>-object -w README.MF;</span><br></pre></td></tr></table></figure>

<p>#写入版本3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'version3'</span> &gt; README.MF; git <span class="built_in">hash</span>-object -w README.MF;</span><br></pre></td></tr></table></figure>

<p>#回滚指定版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p c11e96db44f7f3bc4c608aa7d7cd9ba4ab25066e &gt; </span><br><span class="line">README.MF</span><br></pre></td></tr></table></figure>

<p>所以我们平常用的 git add 其实就是把修改之后的内容 插入到键值库中。当我们执行 git add README.MF 等同于执行了 git hash-object -w README.MF 把文件写到数据库中。</p>
<p>我们解决了存储的问题，但其只能存储内容同并没有存储文件名，如果要进行回滚 怎么知道哪个内容对应哪个文件呢？接下要讲的就是树对象，它解决了文件名存储的问题 。</p>
<p><strong>2、GIT树对像</strong><br>树对像解决了文件名的问题，它的目的将多个文件名组织在一起，其内包含多个文件名称与其对应的Key和其它树对像的用引用，可以理解成操作系统当中的文件夹，一个文件夹包含多个文件和多个其它文件夹。<br><img src="https://img-blog.csdnimg.cn/20200208155735977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQ0Njk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每一个分支当中都关联了一个树对像，他存储了当前分支下所有的文件名及对应的 key.<br>通过以下命令即可查看<br>#查看分支树</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p master^&#123;tree&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、git提交对象</strong><br>一次提交即为当前版本的一个快照，该快照就是通过提交对像保存，其存储的内容为：一个顶级树对象、上一次提交的对像啥希、提交者用户名及邮箱、提交时间戳、提交评论。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p b2395925b5f1c12bf8cb9602f05fc8d580311836</span><br><span class="line">tree 002adb8152f7cd49f400a0480ef2d4c09b060c07</span><br><span class="line">parent 8be903f5e1046b851117a21cdc3c80bdcaf97570</span><br><span class="line">author tommy &lt;tommy@tuling.com&gt; 1532959457 +0800</span><br><span class="line">committer tommy &lt;tommy@tuling.com&gt; 1532959457 +0800</span><br></pre></td></tr></table></figure>

<p>通过上面的知识，我们可以推测出从修改一个文件到提交的过程总共生成了三个对像：<br>一个内容对象 ==&gt; 存储了文件内容<br>一个树对像 ==&gt; 存储了文件名及内容对像的key<br>一个提交对像 ==&gt; 存储了树对像的key 及提交评论。 </p>
<p><strong>4、GIT引用</strong><br>当我们执行 git branch {branchName} 时创建了一个分支，其本质就是在git 基于指定提交创建了一个引用文件，保存在 .git\refs\heads\ 下。</p>
<p>    演示分支的创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch dev </span><br><span class="line">cat.git\refs\heads\dev</span><br></pre></td></tr></table></figure>

<p>git 总共 有三种类型的引用：</p>
<ol>
<li>分支引用</li>
<li>远程分支引用</li>
<li>标签引用</li>
</ol>
<p>#查询比较两个版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> master..experiment</span><br></pre></td></tr></table></figure>

<p>#版本提交历史网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %s'</span> --graph</span><br></pre></td></tr></table></figure>

<p>#查看分支树</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p master^&#123;tree&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2020/03/01/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java动态代理详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-01 15:06:05" itemprop="dateCreated datePublished" datetime="2020-03-01T15:06:05+08:00">2020-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 19:03:21" itemprop="dateModified" datetime="2020-05-01T19:03:21+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaWeb/" itemprop="url" rel="index"><span itemprop="name">JavaWeb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:80px;"> </p>

<p id="1.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:80px;"><a href="#1.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.基于JDK的动态代理</a></p>

<p id="2.%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:80px;"><a href="#2.%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">2.基于CGLIB的动态代理</a></p>

<hr id="hr-toc"><p id="%E7%9B%AE%E5%89%8Djava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E4%B8%BA%E4%B8%A4%E7%A7%8D">目前java动态代理的实现分为两种</p>

<p><strong>1.基于JDK的动态代理</strong></p>

<p><strong>2.基于CGILB的动态代理</strong></p>

<p>在业务中使用动态代理，一般是为了给需要实现的方法添加预处理或者添加后续操作，但是不干预实现类的正常业务，把一些基本业务和主要的业务逻辑分离。我们一般所熟知的Spring的AOP原理就是基于动态代理实现的。</p>

<h3 id="1.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><strong>1.基于JDK的动态代理</strong></h3>

<p>基于JDK的动态代理就需要知道两个类：1.InvocationHandler（接口）、2.Proxy（类）</p>

<p>还要知道JDK是基于接口的动态代理</p>

<p>下面我们实际用代码来讲解这两个类的实际作用</p>

<p>1.第一步，创建一个接口</p>

<p>public interface Subject {<br>
    void hello(String param);<br>
}<br>
2.第二步，实现接口</p>

<p>public class SubjectImpl implements Subject {<br>
    @Override<br>
    public void hello(String param) {<br>
        System.out.println("hello  " + param);<br>
    }<br>
}<br>
3.第三步，创建SubjectImpl的代理类</p>

<p>public class SubjectProxy implements InvocationHandler {<br>
    private Subject subject;</p>

<p>    public SubjectProxy(Subject subject) {<br>
        this.subject = subject;<br>
    }</p>

<p>    @Override<br>
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>
        System.out.println("--------------begin-------------");<br>
        Object invoke = method.invoke(subject, args);<br>
        System.out.println("--------------end-------------");<br>
        return invoke;<br>
    }<br>
}<br>
invoke方法的说明：</p>

<p><img alt src="https://img-blog.csdn.net/20180821150523827?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNTMyMzIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>4.编写代理类实际的调用，利用Proxy类创建代理之后的Subject类。</p>

<p>public class Main {</p>

<p>    public static void main(String[] args) {<br>
        Subject subject = new SubjectImpl();<br>
        InvocationHandler subjectProxy = new SubjectProxy(subject);<br>
        Subject proxyInstance = (Subject) Proxy.newProxyInstance(subjectProxy.getClass().getClassLoader(), subject.getClass().getInterfaces(), subjectProxy);<br>
        proxyInstance.hello("world");<br>
    }</p>

<p>}</p>

<p><img alt src="https://img-blog.csdn.net/20180821150918418?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNTMyMzIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br>
输出：</p>

<p>--------------begin-------------<br>
hello  world<br>
--------------end-------------</p>

<p>看这个结果，实际上在Subject类中只会输出一条hello world，但是在被代理之后，实际调用的方法是SubjectProxy的invoke方法，这样可以在不修改业务类的情况下对业务类增加一些日志等其他操作，甚至可以直接修改有返回值方法的返回值。</p>

<h3 id="2.%E5%9F%BA%E4%BA%8ECGLIB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><strong>2.基于CGLIB的动态代理</strong></h3>

<p>本文主要讲的是CGLIB的动态代理，因为基于JDK的动态代理一定要继承一个接口，而绝大部分情况是基于POJO类的动态代理，那么CGLIB就是一个很好的选择，在Hibernate框架中PO的字节码生产工作就是靠CGLIB来完成的。还是先看代码。</p>

<p>1.引入CGLIB的jar包</p>

<p>2.创建代理类</p>

<p>public class CGsubject {<br>
    public void sayHello(){<br>
        System.out.println("hello world");<br>
    }<br>
}<br>
如果直接对这个类创建对象，那么调用sayHello方法，控制台就会输出hello world，现在我们还是要对输出添加前置和后置的log输出。来打印输出前和输出后的时间。</p>

<p>3.实现MethodInterceptor接口，对方法进行拦截处理。</p>

<p>public class HelloInterceptor implements MethodInterceptor{<br>
    @Override<br>
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {<br>
        System.out.println("begin time -----&gt; "+ System.currentTimeMillis());<br>
        Object o1 = methodProxy.invokeSuper(o, objects);<br>
        System.out.println("end time -----&gt; "+ System.currentTimeMillis());<br>
        return o1;<br>
    }<br>
}</p>

<p><img alt src="https://img-blog.csdn.net/201808211529299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNTMyMzIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br>
4.创建被代理类</p>

<p>public class Main {</p>

<p>    public static void main(String[] args) {<br>
        Enhancer enhancer = new Enhancer();<br>
        enhancer.setSuperclass(CGsubject.class);<br>
        enhancer.setCallback(new HelloInterceptor());<br>
        CGsubject cGsubject = (CGsubject) enhancer.create();<br>
        cGsubject.sayHello();<br>
    }</p>

<p>}<br>
利用Enhancer来生产被代理类，这样可以拦截方法，对方法进行前置和后置log的添加。</p>

<p>输出：</p>

<p>begin time -----&gt; 1534836443741<br>
hello world<br>
end time -----&gt; 1534836443786<br>
 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2020/03/01/MyBatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/MyBatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">MyBatis源码解析(二)——动态代理实现函数调用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-01 15:04:38" itemprop="dateCreated datePublished" datetime="2020-03-01T15:04:38+08:00">2020-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 19:03:21" itemprop="dateModified" datetime="2020-05-01T19:03:21+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mybatis/" itemprop="url" rel="index"><span itemprop="name">Mybatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<p>如果我们要使用MyBatis进行数据库操作的话，大致要做两件事情：</p>

<ol><li>定义DAO接口<br>
    在DAO接口中定义需要进行的数据库操作。</li>
    <li>创建映射文件<br>
    当有了DAO接口后，还需要为该接口创建映射文件。映射文件中定义了一系列SQL语句，这些SQL语句和DAO接口一一对应。</li>
</ol><p>MyBatis在初始化的时候会将映射文件与DAO接口一一对应，并根据映射文件的内容为每个函数创建相应的数据库操作能力。而我们作为MyBatis使用者，只需将DAO接口注入给Service层使用即可。<br>
那么MyBatis是如何根据映射文件为每个DAO接口创建具体实现的？答案是——动态代理。<br>
下面进入正题。</p>

<hr><p>首先来回顾一项MyBatis在初始化过程中所做的事情。<br>
MyBatis在初始化过程中，首先会读取我们的配置文件流程，并使用<code>XMLConfigBuilder</code>来解析配置文件。<code>XMLConfigBuilder</code>会依次解析配置文件中的各个子节点，如：<code>&lt;settings&gt;</code>、<code>&lt;typeAliases&gt;</code>、<code>&lt;mappers&gt;</code>等。这些子节点在解析完成后都会被注册进<code>configuration</code>对象。然后<code>configuration</code>对象将作为参数，创建<code>SqlSessionFactory</code>对象。至此，初始化过程完毕！<br>
下面我们重点分析<code>&lt;mapper&gt;</code>节点解析的过程。</p>

<p>PS：MyBatis详细的初始化过程请移步至：<a href="https://www.jianshu.com/p/7bc6d3b7fb45" target="_blank" rel="external nofollow noopener noreferrer">MyBatis源码解析(一)——MyBatis初始化过程解析</a></p>

<hr><h1>&lt;mapper&gt;节点解析过程</h1>

<p> </p>

<pre>
<code>XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();
</code></pre>

<p>由上述代码可知，解析mapper节点的解析是由<code>XMLMapperBuilder</code>类的<code>parse()</code>函数来完成的，下面我们就详细看一下<code>parse()</code>函数。</p>

<p> </p>

<pre>
<code>  public void parse() {
    // 若当前Mapper.xml尚未加载，则加载
    if (!configuration.isResourceLoaded(resource)) {
      // 解析&lt;mapper&gt;节点
      configurationElement(parser.evalNode("/mapper"));
      // 将当前Mapper.xml标注为『已加载』（下回就不用再加载了）
      configuration.addLoadedResource(resource);
      // 【关键】将Mapper Class添加至Configuration中
      bindMapperForNamespace();
    }

    parsePendingResultMaps();
    parsePendingCacheRefs();
    parsePendingStatements();
  }
</code></pre>

<p>这个函数主要做了两件事：</p>

<ol><li>解析<code>&lt;mapper&gt;</code>节点，并将解析结果注册进<code>configuration</code>中；</li>
    <li>将当前映射文件所对应的DAO接口的Class对象注册进<code>configuration</code>中<br>
    这一步极为关键！是为了给DAO接口创建代理对象，下文会详细介绍。</li>
</ol><p>下面再进入<code>bindMapperForNamespace()</code>函数，看一看它做了什么：</p>

<p> </p>

<pre>
<code>  private void bindMapperForNamespace() {
    // 获取当前映射文件对应的DAO接口的全限定名
    String namespace = builderAssistant.getCurrentNamespace();
    if (namespace != null) {
      // 将全限定名解析成Class对象
      Class&lt;?&gt; boundType = null;
      try {
        boundType = Resources.classForName(namespace);
      } catch (ClassNotFoundException e) {
      }
      if (boundType != null) {
        if (!configuration.hasMapper(boundType)) {
          // 将当前Mapper.xml标注为『已加载』（下回就不用再加载了）
          configuration.addLoadedResource("namespace:" + namespace);
          // 将DAO接口的Class对象注册进configuration中
          configuration.addMapper(boundType);
        }
      }
    }
  }
</code></pre>

<p>这个函数主要做了两件事：</p>

<ol><li>将<code>&lt;mapper&gt;</code>节点上定义的<code>namespace</code>属性（即：当前映射文件所对应的DAO接口的权限定名）解析成Class对象</li>
    <li>将该Class对象存储在<code>configuration</code>对象的<code>MapperRegistry</code>容器中。</li>
</ol><p>可以看一下<code>MapperRegistry</code>：</p>

<p> </p>

<pre>
<code>public class MapperRegistry {
  private final Configuration config;
  private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();
}
</code></pre>

<p><code>MapperRegistry</code>有且仅有两个属性：<code>Configuration</code>和<code>knownMappers</code>。<br>
其中，<code>knownMappers</code>的类型为<code>Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;</code>，由此可见，它是一个Map，key为DAO接口的Class对象，而Value为该DAO接口代理对象的工厂。<br>
那么，这个代理对象工厂是何许人也？它又是如何产生的呢？我们先来看一下<code>MapperRegistry</code>的<code>addMapper()</code>函数。</p>

<p> </p>

<pre>
<code>  public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
    if (type.isInterface()) {
      if (hasMapper(type)) {
        throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
      }
      boolean loadCompleted = false;
      try {
        // 创建MapperProxyFactory对象，并put进knownMappers中
        knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }
</code></pre>

<p>从这个函数可知，<code>MapperProxyFactory</code>是在这里创建，并put进<code>knownMappers</code>中的。<br>
下面我们就来看一下<code>MapperProxyFactory</code>这个类究竟有些啥：</p>

<p> </p>

<pre>
<code>public class MapperProxyFactory&lt;T&gt; {

  private final Class&lt;T&gt; mapperInterface;
  private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;();

  public MapperProxyFactory(Class&lt;T&gt; mapperInterface) {
    this.mapperInterface = mapperInterface;
  }

  public Class&lt;T&gt; getMapperInterface() {
    return mapperInterface;
  }

  public Map&lt;Method, MapperMethod&gt; getMethodCache() {
    return methodCache;
  }

  @SuppressWarnings("unchecked")
  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
  }

  public T newInstance(SqlSession sqlSession) {
    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);
    return newInstance(mapperProxy);
  }
}
</code></pre>

<p>这个类有三个重要成员：</p>

<ol><li>mapperInterface属性<br>
    这个属性就是DAO接口的Class对象，当创建<code>MapperProxyFactory</code>对象的时候需要传入</li>
    <li>methodCache属性<br>
    这个属性用于存储当前DAO接口中所有的方法。</li>
    <li>newInstance函数<br>
    这个函数用于创建DAO接口的代理对象，它需要传入一个MapperProxy对象作为参数。而MapperProxy类实现了InvocationHandler接口，由此可知它是动态代理中的处理类，所有对目标函数的调用请求都会先被这个处理类截获，所以可以在这个处理类中添加目标函数调用前、调用后的逻辑。</li>
</ol><hr><h1>DAO函数调用过程</h1>

<p>当MyBatis初始化完毕后，<code>configuration</code>对象中存储了所有DAO接口的Class对象和相应的<code>MapperProxyFactory</code>对象（用于创建DAO接口的代理对象）。接下来，就到了使用DAO接口中函数的阶段了。</p>

<p> </p>

<pre>
<code>SqlSession sqlSession = sqlSessionFactory.openSession();
try {
    ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
    List&lt;Product&gt; productList = productMapper.selectProductList();
    for (Product product : productList) {
        System.out.printf(product.toString());
    }
} finally {
    sqlSession.close();
}
</code></pre>

<p>我们首先需要从<code>sqlSessionFactory</code>对象中创建一个<code>SqlSession</code>对象，然后调用<code>sqlSession.getMapper(ProductMapper.class)</code>来获取代理对象。</p>

<p><code>sqlSessionFactory.openSession()</code>创建<code>SqlSession</code>对象</p>

<pre>
<code class="language-java">public SqlSession openSession() {
        return this.openSessionFromDataSource(this.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)null, false);
    }</code></pre>

<p>会调用 openSessionFromDataSource 方法，其中执行器为初始化Configuration时默认的 SimpleExecutor，接下来看openSessionFromDataSource方法</p>

<pre>
<code class="language-java">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
        Transaction tx = null;

        DefaultSqlSession var8;
        try {
            Environment environment = this.configuration.getEnvironment();
            TransactionFactory transactionFactory = this.getTransactionFactoryFromEnvironment(environment);
            tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
            Executor executor = this.configuration.newExecutor(tx, execType);
            var8 = new DefaultSqlSession(this.configuration, executor, autoCommit);
        } catch (Exception var12) {
            this.closeTransaction(tx);
            throw ExceptionFactory.wrapException("Error opening session.  Cause: " + var12, var12);
        } finally {
            ErrorContext.instance().reset();
        }

        return var8;
    }</code></pre>

<p>会返回一个 DefaultSqlSession 对象，看一下其中的this.configuration.newExecutor(tx, execType);方法</p>

<pre>
<code class="language-java">public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
        executorType = executorType == null ? this.defaultExecutorType : executorType;
        executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
        Object executor;
        if (ExecutorType.BATCH == executorType) {
            executor = new BatchExecutor(this, transaction);
        } else if (ExecutorType.REUSE == executorType) {
            executor = new ReuseExecutor(this, transaction);
        } else {
            executor = new SimpleExecutor(this, transaction);
        }

        //缓存
        if (this.cacheEnabled) {
            executor = new CachingExecutor((Executor)executor);
        }
        //责任链模式拦截器 
        Executor executor = (Executor)this.interceptorChain.pluginAll(executor);
        return executor;
    }</code></pre>

<p>开启缓存这里SimpleExecutor就会被CachingExecutor替换</p>

<p><br>
我们再来看一下<code>sqlSession.getMapper()</code>是如何创建代理对象的？</p>

<p> </p>

<pre>
<code>  public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
    return configuration.&lt;T&gt;getMapper(type, this);
  }
</code></pre>

<p><code>sqlSession.getMapper()</code>调用了<code>configuration.getMapper()</code>，那我们再看一下<code>configuration.getMapper()</code>：</p>

<p> </p>

<pre>
<code>  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    return mapperRegistry.getMapper(type, sqlSession);
  }
</code></pre>

<p><code>configuration.getMapper()</code>又调用了<code>mapperRegistry.getMapper()</code>，那好，我们再深入看一下<code>mapperRegistry.getMapper()</code>：</p>

<p> </p>

<pre>
<code>  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException("Type " + type + " is not known to the MapperRegistry.");
    }
    try {
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException("Error getting mapper instance. Cause: " + e, e);
    }
  }
</code></pre>

<p>看到这里我们就恍然大悟了，原来它根据上游传递进来DAO接口的Class对象，从<code>configuration</code>中取出了该DAO接口对应的代理对象生成工厂：<code>MapperProxyFactory</code>；<br>
在有了这个工厂后，再通过<code>newInstance</code>函数创建该DAO接口的代理对象，并返回给上游。</p>

<p>OK，此时我们已经获取了代理对象，接下来就可以使用这个代理对象调用相应的函数了。</p>

<p> </p>

<pre>
<code>SqlSession sqlSession = sqlSessionFactory.openSession();
try {
    ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
    List&lt;Product&gt; productList = productMapper.selectProductList();
    for (Product product : productList) {
        System.out.printf(product.toString());
    }
} finally {
    sqlSession.close();
}
</code></pre>

<p>以上述代码为例，当我们获取到<code>ProductMapper</code>的代理对象后，我们调用了它的<code>selectProductList()</code>函数。<br>
下面我们就来分析下代理函数调用过程。</p>

<hr><p>当调用了代理对象的某一个代理函数后，这个调用请求首先会被发送给代理对象处理类<code>MapperProxy</code>的<code>invoke()</code>函数：</p>

<p> </p>

<pre>
<code>  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    // 【核心代理在这里】
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
  }
</code></pre>

<p>先来解释下invoke函数的几个参数：</p>

<ol><li><code>Object proxy</code>：代理对象</li>
    <li><code>Method method</code>：当前正在被调用的代理对象的函数对象</li>
    <li><code>Object[] args</code>：调用函数的所有入参</li>
</ol><p>然后，直接看invoke函数最核心的两行代码：</p>

<ol><li><code>cachedMapperMethod(method)</code>：从当前代理对象处理类<code>MapperProxy</code>的<code>methodCache</code>属性中获取method方法的详细信息（即：<code>MapperMethod</code>对象）。如果<code>methodCache</code>中没有就创建并加进去。</li>
    <li>有了<code>MapperMethod</code>对象后执行它的<code>execute()</code>方法，该方法就会调用JDBC执行相应的SQL语句，并将结果返回给上游调用者。至此，代理对象函数的调用过程结束！</li>
</ol><p>MapperMethod的execute方法</p>

<pre>
<code class="language-java">public Object execute(SqlSession sqlSession, Object[] args) {
        Object result;
        Object param;
        switch(this.command.getType()) {
        case INSERT:
            param = this.method.convertArgsToSqlCommandParam(args);
            result = this.rowCountResult(sqlSession.insert(this.command.getName(), param));
            break;
        case UPDATE:
            param = this.method.convertArgsToSqlCommandParam(args);
            result = this.rowCountResult(sqlSession.update(this.command.getName(), param));
            break;
        case DELETE:
            param = this.method.convertArgsToSqlCommandParam(args);
            result = this.rowCountResult(sqlSession.delete(this.command.getName(), param));
            break;
        case SELECT:
            if (this.method.returnsVoid() &amp;&amp; this.method.hasResultHandler()) {
                this.executeWithResultHandler(sqlSession, args);
                result = null;
            } else if (this.method.returnsMany()) {
                result = this.executeForMany(sqlSession, args);
            } else if (this.method.returnsMap()) {
                result = this.executeForMap(sqlSession, args);
            } else if (this.method.returnsCursor()) {
                result = this.executeForCursor(sqlSession, args);
            } else {
                param = this.method.convertArgsToSqlCommandParam(args);
                result = sqlSession.selectOne(this.command.getName(), param);
                if (this.method.returnsOptional() &amp;&amp; (result == null || !this.method.getReturnType().equals(result.getClass()))) {
                    result = Optional.ofNullable(result);
                }
            }
            break;
        case FLUSH:
            result = sqlSession.flushStatements();
            break;
        default:
            throw new BindingException("Unknown execution method for: " + this.command.getName());
        }

        if (result == null &amp;&amp; this.method.getReturnType().isPrimitive() &amp;&amp; !this.method.returnsVoid()) {
            throw new BindingException("Mapper method '" + this.command.getName() + " attempted to return null from a method with a primitive return type (" + this.method.getReturnType() + ").");
        } else {
            return result;
        }
    }</code></pre>

<p>可以看出是sqlsession通过xml中的sql id和参数在做CRUD操作，再看 result = this.executeForMany(sqlSession, args);方法</p>

<pre>
<code class="language-java">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
        Object param = this.method.convertArgsToSqlCommandParam(args);
        List result;
        if (this.method.hasRowBounds()) {
            RowBounds rowBounds = this.method.extractRowBounds(args);
            result = sqlSession.selectList(this.command.getName(), param, rowBounds);
        } else {
            result = sqlSession.selectList(this.command.getName(), param);
        }

        if (!this.method.getReturnType().isAssignableFrom(result.getClass())) {
            return this.method.getReturnType().isArray() ? this.convertToArray(result) : this.convertToDeclaredCollection(sqlSession.getConfiguration(), result);
        } else {
            return result;
        }
    }</code></pre>

<p>进入 sqlSession.selectList(this.command.getName(), param, rowBounds);方法</p>

<pre>
<code class="language-java">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
        List var5;
        try {
            MappedStatement ms = this.configuration.getMappedStatement(statement);
            var5 = this.executor.query(ms, this.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
        } catch (Exception var9) {
            throw ExceptionFactory.wrapException("Error querying database.  Cause: " + var9, var9);
        } finally {
            ErrorContext.instance().reset();
        }

        return var5;
    }</code></pre>

<p>继续看 this.executor.query 方法</p>

<pre>
<code class="language-java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
        BoundSql boundSql = ms.getBoundSql(parameterObject);
        CacheKey key = this.createCacheKey(ms, parameterObject, rowBounds, boundSql);
        return this.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }</code></pre>

<p>这里的cacheKey是通过 id +sql+limit+offsetxxx 等等参数确定一个缓存的key</p>

<p>接着看query方法：</p>

<pre>
<code class="language-java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        // 获取二级缓存
        Cache cache = ms.getCache();
        if (cache != null) {
            // 根据ms来决定是否刷新缓存
            this.flushCacheIfRequired(ms);
            if (ms.isUseCache() &amp;&amp; resultHandler == null) {
                this.ensureNoOutParams(ms, boundSql);
                List&lt;E&gt; list = (List)this.tcm.getObject(cache, key);
                if (list == null) {
                    list = this.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
                    // 放入二级缓存
                    this.tcm.putObject(cache, key, list);
                }

                return list;
            }
        }

        return this.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }</code></pre>

<p>有缓存就从缓存中取，无缓存就调用初始化CachingExecutor时传入的SimpleExecutor的query方法，继续看 this.delegate.query 方法：</p>

<pre>
<code class="language-java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        ErrorContext.instance().resource(ms.getResource()).activity("executing a query").object(ms.getId());
        if (this.closed) {
            throw new ExecutorException("Executor was closed.");
        } else {
            // 上一个查询执行完成 并且 &lt;select&gt;标签增加了flushCache="true" 刷新一级缓存
            if (this.queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
                this.clearLocalCache();
            }

            List list;
            try {
                ++this.queryStack;
                // 对于指定了resultHandler的查询，不走缓存。否则从缓存中查询。
                list = resultHandler == null ? (List)this.localCache.getObject(key) : null;
                if (list != null) {
                    // 如果存在缓存参数值，取出来覆盖当前参数值，只针对Callable
                    this.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
                } else {
                    // 缓存中没有，从数据库中查询放入缓存
                    list = this.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
                }
            } finally {
                --this.queryStack;
            }

            if (this.queryStack == 0) {
                Iterator var8 = this.deferredLoads.iterator();

                while(var8.hasNext()) {
                    BaseExecutor.DeferredLoad deferredLoad = (BaseExecutor.DeferredLoad)var8.next();
                    deferredLoad.load();
                }

                this.deferredLoads.clear();
                // 如果cacheScope配置了statement，查询完后清除缓存
                if (this.configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
                    this.clearLocalCache();
                }
            }

            return list;
        }
    }</code></pre>

<p>再看 queryFromDatabase 方法：</p>

<pre>
<code class="language-java">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        // 放入一个初始值
        this.localCache.putObject(key, ExecutionPlaceholder.EXECUTION_PLACEHOLDER);

        List list;
        try {
            list = this.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
        } finally {
            this.localCache.removeObject(key);
        }
        // 放入一级缓存
        this.localCache.putObject(key, list);
        if (ms.getStatementType() == StatementType.CALLABLE) {
            this.localOutputParameterCache.putObject(key, parameter);
        }

        return list;
    }</code></pre>

<p>可以看到上面的查询方法先是看&lt;select&gt;有没有flushCache=”true”，有就刷新一级缓存，没有的话先去从一级缓存取数据，如果一级缓存里没有结果，调用<code>queryFromDatabase</code>方法，从数据库查询结果并返回。</p>

<p>一级缓存的范围有 <code>SESSION</code> 和 <code>STATEMENT</code> 两种，默认是 <code>SESSION</code> ，如果我们不需要使用一级缓存，那么我们可以把一级缓存的范围指定为STATEMENT，这样每次执行完一个Mapper语句后都会将一级缓存清除。如果需要更改一级缓存的范围，请在Mybatis的配置文件中，在&lt;settings&gt;下通过localCacheScope指定。</p>

<p>至此，一次完整的Mybatis执行过程到此结束。</p>

<p> </p>

<p>需要注意的是与spring整合之后，mybatis的一级缓存就失效了</p>

<p>1.mybatis的一级缓存生效的范围是sqlsession，是为了在sqlsession没有关闭时，业务需要重复查询相同数据使用的。一旦sqlsession关闭，则由这个sqlsession缓存的数据将会被清空。</p>

<p>2.spring对mybatis的sqlsession的使用是由template控制的，sqlSessionTemplate又被spring当作resource放在当前线程的上下文里（threadlocal),spring通过mybatis调用数据库的过程如下：</p>

<blockquote>
<ol><li>我们需要访问数据</li>
    <li>spring检查到了这种需求，于是去申请一个mybatis的sqlsession（资源池），并将申请到的sqlsession与当前线程绑定，放入threadlocal里面</li>
    <li>sqlSessionTemplate从threadlocal获取到sqlsession，去执行查询</li>
    <li>查询结束，清空threadlocal中与当前线程绑定的sqlsession，释放资源</li>
    <li>我们又需要访问数据</li>
    <li>返回到步骤2</li>
</ol><p>通过以上步骤后发现，同一线程里面两次查询同一数据所使用的sqlsession是不相同的，所以，给人的印象就是结合spring后，mybatis的一级缓存失效了。</p>
</blockquote>

<p>对于spring开启事务时，getSqlSession方法里面维护了个SqlSessionHolder，关联了事务与session，如果存在则直接取出，否则则新建个session，所以在有事务的里，每个session都是同一个，故能用上缓存了。</p>

<p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2020/03/01/MyBatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)%E2%80%94%E2%80%94MyBatis%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/MyBatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)%E2%80%94%E2%80%94MyBatis%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">MyBatis源码解析(一)——MyBatis初始化过程解析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-01 15:03:52" itemprop="dateCreated datePublished" datetime="2020-03-01T15:03:52+08:00">2020-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 19:03:21" itemprop="dateModified" datetime="2020-05-01T19:03:21+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mybatis/" itemprop="url" rel="index"><span itemprop="name">Mybatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<h1>1. 准备工作</h1>

<p>为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示：</p>

<p> </p>

<p><img alt src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yOTk0NjA0LTk0Y2EzOTk4YmVlMGFiYjcucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMjk0L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"></p>

<h2>1.1 Product 产品实体类</h2>

<p> </p>

<pre>
<code>public class Product {
    private long id;
    private String productName;
    private String productContent;
    private String price;
    private int sort;
    private int falseSales;
    private long category_id;
    private byte type;
    private byte state;
    // PS：省略setter、getter函数
}
</code></pre>

<h2>1.2 ProductMapper 产品持久化接口</h2>

<p> </p>

<pre>
<code>public interface ProductMapper {
    /**
     * 查询所有的产品
     * @return
     */
    List&lt;Product&gt; selectProductList();
}
</code></pre>

<h2>1.3 ProductMapper.xml 产品映射文件</h2>

<p> </p>

<pre>
<code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;

&lt;mapper namespace="team.njupt.mapper.ProductMapper"&gt;
    &lt;select id="selectProductList" resultType="team.njupt.entity.Product"&gt;
        select * from product
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>

<h2>1.4 db.properties 数据库配置文件</h2>

<p> </p>

<pre>
<code>driver=com.mysql.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;characterEncoding=utf8
username=root
password=xxxxxx
</code></pre>

<h2>1.5 mybatis.xml MyBatis的配置文件</h2>

<p> </p>

<pre>
<code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;properties resource="db.properties"&gt;
        &lt;!--&lt;property name="username" value="dev_user"/&gt;--&gt;
        &lt;!--&lt;property name="password" value="F2Fa3!33TYyg"/&gt;--&gt;
    &lt;/properties&gt;

    &lt;environments default="development"&gt;
        &lt;environment id="development"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="${driver}"/&gt;
                &lt;property name="url" value="${url}"/&gt;
                &lt;property name="username" value="${username}"/&gt;
                &lt;property name="password" value="${password}"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource="team/njupt/mapper/ProductMapper.xml"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>

<h2>1.6 Main 主函数</h2>

<p> </p>

<pre>
<code>public class Main {
    public static void main(String[] args) throws IOException {

        String resource = "mybatis.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        SqlSession sqlSession = sqlSessionFactory.openSession();
        try {
            ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
            List&lt;Product&gt; productList = productMapper.selectProductList();
            for (Product product : productList) {
                System.out.printf(product.toString());
            }
        } finally {
            sqlSession.close();
        }
    }
}
</code></pre>

<hr><h1>2. MyBatis初始化过程</h1>

<h2>2.1 获取配置文件</h2>

<p>当系统初始化时，首先会读取配置文件，并将其解析成InputStream</p>

<p> </p>

<pre>
<code>String resource = "mybatis.xml";
InputStream inputStream = Resources.getResourceAsStream(resource);
</code></pre>

<h2>2.2 创建SqlSessionFactoryBuilder对象</h2>

<p>从<code>SqlSessionFactoryBuilder</code>的名字中可以看出，<code>SqlSessionFactoryBuilder</code>是用来创建<code>SqlSessionFactory</code>对象的。<br>
来看一下SqlSessionFactoryBuilder源码：</p>

<p><img alt src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yOTk0NjA0LWIwZjNlOTk1YWM1NmYyMGEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMzQ5L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"></p>

<p><br>
SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。</p>

<p> </p>

<h2>2.3 SqlSessionFactory创建过程</h2>

<p>下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。</p>

<p> </p>

<pre>
<code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException("Error building SqlSession.", e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}
</code></pre>

<p>2.3.1 构造XMLConfigBuilder对象</p>

<p>build函数首先会构造一个<code>XMLConfigBuilder</code>对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下<code>XMLConfigBuilder</code>的体系结构。</p>

<p><img alt src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yOTk0NjA0LTM5OThmOTcyYTZhNGUyNTEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNzQ4L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"></p>

<p> </p>

<ul><li>
    <p><code>XMLxxxBuilder</code>是用来解析XML配置文件的，不同类型<code>XMLxxxBuilder</code>用来解析MyBatis配置文件的不同部位。比如：<code>XMLConfigBuilder</code>用来解析MyBatis的配置文件，<code>XMLMapperBuilder</code>用来解析MyBatis中的映射文件（如上文提到的<code>ProductMapper.xml</code>），<code>XMLStatementBuilder</code>用来解析映射文件中的SQL语句。</p>
    </li>
    <li>
    <p>这些<code>XMLxxxBuilder</code>都有一个共同的父类——<code>BaseBuilder</code>。这个父类维护了一个全局的<code>Configuration</code>对象，MyBatis的配置文件解析后就以<code>Configuration</code>对象的形式存储。</p>
    </li>
    <li>
    <p>当创建<code>XMLConfigBuilder</code>对象时，就会初始化<code>Configuration</code>对象，并且在初始化<code>Configuration</code>对象的时候，一些别名会被注册到<code>Configuration</code>的<code>typeAliasRegistry</code>容器中。</p>

<pre><code>&lt;pre&gt;</code></pre><p><code>private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {<br>super(new Configuration());<br>ErrorContext.instance().resource("SQL Mapper Configuration");<br>this.configuration.setVariables(props);<br>this.parsed = false;<br>this.environment = environment;<br>this.parser = parser;<br>}<br></code></p>
<pre><code>&lt;pre&gt;</code></pre><p><code>public Configuration() {<br>typeAliasRegistry.registerAlias("JDBC", JdbcTransactionFactory.class);<br>typeAliasRegistry.registerAlias("MANAGED", ManagedTransactionFactory.class);</code></p>
<p>typeAliasRegistry.registerAlias("JNDI", JndiDataSourceFactory.class);<br>typeAliasRegistry.registerAlias("POOLED", PooledDataSourceFactory.class);<br>typeAliasRegistry.registerAlias("UNPOOLED", UnpooledDataSourceFactory.class);</p>
<p>typeAliasRegistry.registerAlias("PERPETUAL", PerpetualCache.class);<br>typeAliasRegistry.registerAlias("FIFO", FifoCache.class);<br>typeAliasRegistry.registerAlias("LRU", LruCache.class);<br>typeAliasRegistry.registerAlias("SOFT", SoftCache.class);<br>typeAliasRegistry.registerAlias("WEAK", WeakCache.class);<br>……<br>}<br><br>    </p></li><p></p>
</ul><h3>2.3.2 解析配置文件</h3>

<p>当有了<code>XMLConfigBuilder</code>对象之后，接下来就可以用它来解析配置文件了。</p>

<p> </p>

<pre>
<code>  private void parseConfiguration(XNode root) {
  try {
    // 解析&lt;properties&gt;节点
    propertiesElement(root.evalNode("properties"));
    // 解析&lt;settings&gt;节点
    Properties settings = settingsAsProperties(root.evalNode("settings"));
    loadCustomVfs(settings);
    // 解析&lt;typeAliases&gt;节点
    typeAliasesElement(root.evalNode("typeAliases"));
    // 解析&lt;plugins&gt;节点
    pluginElement(root.evalNode("plugins"));
    // 解析&lt;objectFactory&gt;节点
    objectFactoryElement(root.evalNode("objectFactory"));
    objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
    // 解析&lt;reflectorFactory&gt;节点
    reflectorFactoryElement(root.evalNode("reflectorFactory"));
    settingsElement(settings);
    // 解析&lt;environments&gt;节点
    environmentsElement(root.evalNode("environments"));
    databaseIdProviderElement(root.evalNode("databaseIdProvider"));
    typeHandlerElement(root.evalNode("typeHandlers"));
    // 解析&lt;mappers&gt;节点
    mapperElement(root.evalNode("mappers"));
  } catch (Exception e) {
    throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
  }
}
</code></pre>

<p>从上述代码中可以看到，<code>XMLConfigBuilder</code>会依次解析配置文件中的<code>&lt;properties&gt;</code>、<code>&lt; settings &gt;</code>、<code>&lt; environments&gt;</code>、<code>&lt; typeAliases &gt;</code>、<code>&lt; plugins &gt;</code>、<code>&lt; mappers &gt;</code>等属性。下面介绍下几个重要属性的解析过程。</p>

<p>2.3.2.1 &lt;properties&gt;节点的解析过程</p>

<ul><li>
    <p>&lt;properties&gt;节点的定义如下：</p>

<pre><code>&lt;pre&gt;</code></pre><p><code class="language-java">&lt;properties resource="org/mybatis/example/config.properties"&gt;<br>  &lt;property name="username" value="dev_user"/&gt;<br>  &lt;property name="password" value="F2Fa3!33TYyg"/&gt;<br>&lt;/properties&gt;<br></code><br>    </p></li><p></p>
</ul><p> </p>

<ul><li>
    <p>&lt;properties&gt;节点的解析过程：</p>

<pre><code>&lt;pre&gt;</code></pre><p><code>/**</code></p>
<ul>
<li><p>@Param context &lt;properties&gt;节点</p>
</li>
<li><p>/<br>private void propertiesElement(XNode context) throws Exception {<br>if (context != null) {<br> // 获取&lt;properties&gt;节点的所有子节点<br> Properties defaults = context.getChildrenAsProperties();<br> // 获取&lt;properties&gt;节点上的resource属性<br> String resource = context.getStringAttribute("resource");<br> // 获取&lt;properties&gt;节点上的url属性<br> String url = context.getStringAttribute("url");<br> // resource和url不能同时存在<br> if (resource != null &amp;&amp; url != null) {<br>   throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.");<br> }<br> if (resource != null) {<br>   // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中<br>   defaults.putAll(Resources.getResourceAsProperties(resource));<br> } else if (url != null) {<br>   // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中<br>   defaults.putAll(Resources.getUrlAsProperties(url));<br> }<br> // 获取configuration中原本的属性，并添加至defaults容器中<br> Properties vars = configuration.getVariables();<br> if (vars != null) {<br>   defaults.putAll(vars);<br> }<br> parser.setVariables(defaults);<br> // 将defaults容器添加至configuration中<br> configuration.setVariables(defaults);<br>}<br>}<br></p>
 <p>如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载：</p>
 </li>
 <li>在 properties 元素体内指定的属性首先被读取。</li>
 <li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。</li>
</ul><p>因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。</p>

</li>
</ul>
<ul><li>最终，携带所有属性的<code>Properties</code>对象会被存储在<code>Configuration</code>对象中。</li>
</ul><p>2.3.2.2 &lt;settings&gt;节点的解析过程</p>

<ul><li>&lt;settings&gt;节点的定义如下：
    <pre>
<code>&lt;settings&gt;
  &lt;setting name="cacheEnabled" value="true"/&gt;
  &lt;setting name="lazyLoadingEnabled" value="true"/&gt;
  &lt;setting name="multipleResultSetsEnabled" value="true"/&gt;
&lt;/settings&gt;
</code></pre>
    </li>
    <li>&lt;settings&gt;节点的解析过程：<br><code>&lt;settings&gt;</code>属性的解析过程和 <code>&lt;properties&gt;</code>属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在<code>Configuration</code>对象中。</li>
</ul><p>2.3.2.3 &lt;typeAliases&gt;属性的解析过程</p>

<p><code>&lt;typeAliases&gt;</code>属性的定义方式有如下两种：</p>

<ul><li>方式1：
    <pre>
<code>&lt;typeAliases&gt;
  &lt;typeAlias alias="Author" type="domain.blog.Author"/&gt;
  &lt;typeAlias alias="Blog" type="domain.blog.Blog"/&gt;
&lt;/typeAliases&gt;
</code></pre>
    </li>
    <li>方式2：
    <pre>
<code>&lt;typeAliases&gt;
  &lt;package name="domain.blog"/&gt;
&lt;/typeAliases&gt;
</code></pre>
    采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。</li>
</ul><p><code>&lt;typeAliases&gt;</code>节点的解析过程如下：</p>

<p> </p>

<pre>
<code>  private void typeAliasesElement(XNode parent) {
  if (parent != null) {
    // 遍历&lt;typeAliases&gt;下的所有子节点
    for (XNode child : parent.getChildren()) {
      // 若当前结点为&lt;package&gt;
      if ("package".equals(child.getName())) {
        // 获取&lt;package&gt;上的name属性（包名）
        String typeAliasPackage = child.getStringAttribute("name");
        // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中          
        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
      } 
      // 如果当前结点为&lt; typeAlias &gt;
      else {
        // 获取alias和type属性
        String alias = child.getStringAttribute("alias");
        String type = child.getStringAttribute("type");
        // 注册进configuration的typeAliasRegistry中
        try {
          Class&lt;?&gt; clazz = Resources.classForName(type);
          if (alias == null) {
            typeAliasRegistry.registerAlias(clazz);
          } else {
            typeAliasRegistry.registerAlias(alias, clazz);
          }
        } catch (ClassNotFoundException e) {
          throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e);
        }
      }
    }
  }
}
</code></pre>

<ul><li>如果<code>&lt;typeAliases&gt;</code>节点下定义了<code>&lt;package&gt;</code>节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名）</li>
    <li>如果<code>&lt;typeAliases&gt;</code>节点下定义了<code>&lt;typeAlias&gt;</code>节点，那么MyBatis就会给指定的类起指定的别名。</li>
    <li>这些别名都会被存入<code>configuration</code>的<code>typeAliasRegistry</code>容器中。</li>
</ul><p>2.3.2.4 &lt;mappers&gt;节点的解析过程</p>

<p><code>&lt;mappers&gt;</code>节点的定义方式有如下四种：</p>

<ul><li>方式1：</li>
</ul><p> </p>

<pre>
<code>&lt;mappers&gt;
  &lt;package name="org.mybatis.builder"/&gt;
&lt;/mappers&gt;
</code></pre>

<ul><li>方式2：</li>
</ul><p> </p>

<pre>
<code>&lt;mappers&gt;
  &lt;mapper resource="org/mybatis/builder/AuthorMapper.xml"/&gt;
&lt;/mappers&gt;
</code></pre>

<ul><li>方式3：</li>
</ul><p> </p>

<pre>
<code>&lt;mappers&gt;
  &lt;mapper url="file:///var/mappers/AuthorMapper.xml"/&gt;
&lt;/mappers&gt;
</code></pre>

<ul><li>方式4：</li>
</ul><p> </p>

<pre>
<code>&lt;mappers&gt;
  &lt;mapper class="org.mybatis.builder.AuthorMapper"/&gt;
&lt;/mappers&gt;
</code></pre>

<p><code>&lt;mappers&gt;</code>节点的解析过程如下：</p>

<p> </p>

<pre>
<code>  private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    // 遍历&lt;mappers&gt;下所有子节点
    for (XNode child : parent.getChildren()) {
      // 如果当前节点为&lt;package&gt;
      if ("package".equals(child.getName())) {
        // 获取&lt;package&gt;的name属性（该属性值为mapper class所在的包名）
        String mapperPackage = child.getStringAttribute("name");
        // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中
        configuration.addMappers(mapperPackage);
      } 
      // 如果当前节点为&lt;mapper&gt;
      else {
        // 依次获取resource、url、class属性
        String resource = child.getStringAttribute("resource");
        String url = child.getStringAttribute("url");
        String mapperClass = child.getStringAttribute("class");
        // 解析resource属性（Mapper.xml文件的路径）
        if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {
          ErrorContext.instance().resource(resource);
          // 将Mapper.xml文件解析成输入流
          InputStream inputStream = Resources.getResourceAsStream(resource);
          // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析url属性（Mapper.xml文件的路径）
        else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {
          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析class属性（Mapper Class的全限定名）
        else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {
          // 将Mapper Class的权限定名转化成Class对象
          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);
          // 注册进configuration对象的mapperRegistry容器中
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException("A mapper element may only specify a url, resource or class, but not more than one.");
        }
      }
    }
  }
}
</code></pre>

<ul><li>MyBatis会遍历<code>&lt;mappers&gt;</code>下所有的子节点，如果当前遍历到的节点是<code>&lt;package&gt;</code>，则MyBatis会将该包下的所有Mapper Class注册到<code>configuration</code>的<code>mapperRegistry</code>容器中。</li>
    <li>如果当前节点为<code>&lt;mapper&gt;</code>，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到<code>configuration</code>的<code>mapperRegistry</code>容器中。</li>
</ul><p>其中，<code>&lt;mapper&gt;</code>节点的解析过程如下：</p>

<p> </p>

<pre>
<code>XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();
</code></pre>

<ul><li>
    <p>在解析前，首先需要创建<code>XMLMapperBuilder</code>，创建过程如下：</p>

<pre><code>&lt;pre&gt;</code></pre><p><code>private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&lt;String, XNode&gt; sqlFragments) {<br>  // 将configuration赋给BaseBuilder<br>  super(configuration);<br>  // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者）<br>  this.builderAssistant = new  MapperBuilderAssistant(configuration, resource);<br>  this.parser = parser;<br>  this.sqlFragments = sqlFragments;<br>  this.resource = resource;<br>}<br></code></p>
<pre><code>&lt;ul&gt;&lt;li&gt;首先会初始化父类&lt;code&gt;BaseBuilder&lt;/code&gt;，并将&lt;code&gt;configuration&lt;/code&gt;赋给BaseBuilder；&lt;/li&gt;
    &lt;li&gt;然后创建&lt;code&gt;MapperBuilderAssistant&lt;/code&gt;对象，该对象为&lt;code&gt;XMLMapperBuilder&lt;/code&gt;的协助者，用来协助&lt;code&gt;XMLMapperBuilder&lt;/code&gt;完成一些解析映射文件的动作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当有了&lt;code&gt;XMLMapperBuilder&lt;/code&gt;后，便可进入解析&lt;code&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;的过程：&lt;/p&gt;

&lt;pre&gt;</code></pre><p><code>public void parse() {<br>  // 若当前的Mapper.xml尚未被解析，则开始解析<br>  // PS：若&lt;mappers&gt;节点下有相同的&lt;mapper&gt;节点，那么就无需再次解析了<br>  if (!configuration.isResourceLoaded(resource)) {<br>    // 解析&lt;mapper&gt;节点<br>    configurationElement(parser.evalNode("/mapper"));<br>    // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析<br>    configuration.addLoadedResource(resource);<br>    // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中<br>    bindMapperForNamespace();<br>  }</code></p>
<p>  parsePendingResultMaps();<br>  parsePendingCacheRefs();<br>  parsePendingStatements();<br>}<br><br>    </p></li><br>    <li><br>    <p><code>configurationElement</code>函数</p><p></p>
<pre><code>&lt;pre&gt;</code></pre><p><code>private void configurationElement(XNode context) {<br>try {<br>  // 获取&lt;mapper&gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁<br>  String namespace = context.getStringAttribute("namespace");<br>  if (namespace == null || namespace.equals("")) {<br>    throw new BuilderException("Mapper's namespace cannot be empty");<br>  }<br>  // 将namespace属性值赋给builderAssistant<br>  builderAssistant.setCurrentNamespace(namespace);<br>  // 解析&lt;cache-ref&gt;节点<br>  cacheRefElement(context.evalNode("cache-ref"));<br>  // 解析&lt;cache&gt;节点<br>  cacheElement(context.evalNode("cache"));<br>  // 解析&lt;parameterMap&gt;节点<br>  parameterMapElement(context.evalNodes("/mapper/parameterMap"));<br>  // 解析&lt;resultMap&gt;节点<br>  resultMapElements(context.evalNodes("/mapper/resultMap"));<br>  // 解析&lt;sql&gt;节点<br>  sqlElement(context.evalNodes("/mapper/sql"));<br>  // 解析sql语句<br>  buildStatementFromContext(context.evalNodes("select|insert|update|delete"));<br>} catch (Exception e) {<br>  throw new BuilderException("Error parsing Mapper XML. Cause: " + e, e);<br>}<br>}<br></code><br>    </p></li><br>    <li><br>    <p><code>resultMapElements</code>函数<br><br>    该函数用于解析映射文件中所有的<code>&lt;resultMap&gt;</code>节点，这些节点会被解析成<code>ResultMap</code>对象，存储在<code>Configuration</code>对象的<code>resultMaps</code>容器中。</p><p></p>
<pre><code>&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点定义如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;</code></pre><p><code> &lt;resultMap id="userResultMap" type="User"&gt;<br>  &lt;constructor&gt;<br>     &lt;idArg column="id" javaType="int"/&gt;<br>     &lt;arg column="username" javaType="String"/&gt;<br>  &lt;/constructor&gt;<br>  &lt;result property="username" column="user_name"/&gt;<br>  &lt;result property="password" column="hashed_password"/&gt;<br>&lt;/resultMap&gt;<br></code></p>
<pre><code>&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点的解析过程：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;</code></pre><p><code>private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception {<br>  ErrorContext.instance().activity("processing " + resultMapNode.getValueBasedIdentifier());<br>  // 获取&lt;ResultMap&gt;上的id属性<br>  String id = resultMapNode.getStringAttribute("id",<br>    resultMapNode.getValueBasedIdentifier());<br>  // 获取&lt;ResultMap&gt;上的type属性（即resultMap的返回值类型）<br>  String type = resultMapNode.getStringAttribute("type",<br>    resultMapNode.getStringAttribute("ofType",<br>        resultMapNode.getStringAttribute("resultType",<br>            resultMapNode.getStringAttribute("javaType"))));<br>  // 获取extends属性<br>  String extend = resultMapNode.getStringAttribute("extends");<br>  // 获取autoMapping属性<br>  Boolean autoMapping = resultMapNode.getBooleanAttribute("autoMapping");<br>  // 将resultMap的返回值类型转换成Class对象<br>  Class&lt;?&gt; typeClass = resolveClass(type);<br>  Discriminator discriminator = null;<br>  // resultMappings用于存储&lt;resultMap&gt;下所有的子节点<br>  List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;ResultMapping&gt;();<br>  resultMappings.addAll(additionalResultMappings);<br>  // 获取并遍历&lt;resultMap&gt;下所有的子节点<br>  List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();<br>  for (XNode resultChild : resultChildren) {<br>    // 若当前节点为&lt;constructor&gt;，则将它的子节点们添加到resultMappings中去<br>    if ("constructor".equals(resultChild.getName())) {<br>      processConstructorElement(resultChild, typeClass, resultMappings);<br>    }<br>    // 若当前节点为&lt;discriminator&gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去<br>    else if ("discriminator".equals(resultChild.getName())) {<br>      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);<br>    }<br>    // 若当前节点为&lt;result&gt;、&lt;association&gt;、&lt;collection&gt;，则将其添加到resultMappings中去<br>    else {<br>      // PS:flags仅用于区分当前节点是否是&lt;id&gt;或&lt;idArg&gt;，因为这两个节点的属性名为name，而其他节点的属性名为property<br>      List&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;();<br>      if ("id".equals(resultChild.getName())) {<br>        flags.add(ResultFlag.ID);<br>      }<br>      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));<br>    }<br>  }<br>  // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下）<br>  ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);<br>  try {<br>    return resultMapResolver.resolve();<br>  } catch (IncompleteElementException  e) {<br>    configuration.addIncompleteResultMap(resultMapResolver);<br>    throw e;<br>  }<br>}<br></code></p>
<pre><code>&lt;p&gt;&lt;code&gt;ResultMapResolver&lt;/code&gt;这个类很纯粹，有且仅有一个函数&lt;code&gt;resolve&lt;/code&gt;，用于构造&lt;code&gt;ResultMap&lt;/code&gt;对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于&lt;code&gt;MapperBuilderAssistant.addResultMap&lt;/code&gt;完成的。&lt;/p&gt;

&lt;pre&gt;</code></pre><p><code>public ResultMap resolve() {<br>  return assistant.addResultMap(this.id, this.type, this.extend,  this.discriminator, this.resultMappings, this.autoMapping);<br>}<br></code><br>    </p></li><br>    <li><br>    <p><code>sqlElement</code>函数<br><br>    该函数用于解析映射文件中所有的<code>&lt;sql&gt;</code>节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。</p><p></p>
<pre><code>&lt;pre&gt;</code></pre><p><code>&lt;sql id="userColumns"&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt;<br></code><br>    </p></li><p></p>
</ul><ul><li><code>buildStatementFromContext</code>函数<br>
    该函数会将映射文件中的sql语句解析成<code>MappedStatement</code>对象，并存在<code>configuration</code>的<code>mappedStatements</code>。</li>
</ul><h3>2.3.3 创建SqlSessionFactory对象</h3>

<p> </p>

<pre>
<code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException("Error building SqlSession.", e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}
</code></pre>

<p>回过头来再看一下<code>SqlSessionFactory</code>的<code>build</code>函数，刚才说了半天，介绍了<code>XMLConfigBuilder</code>解析映射文件的过程，解析完成之后<code>parser.parse()</code>函数会返回一个包含了映射文件解析结果的<code>configuration</code>对象，紧接着，这个对象将作为参数传递给另一个build函数，如下：</p>

<p> </p>

<pre>
<code>  public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
  }
</code></pre>

<p>这个函数将<code>configuration</code>作为参数，创建了<code>DefaultSqlSessionFactory</code>对象。<br><code>DefaultSqlSessionFactory</code>是接口<code>SqlSessionFactory</code>的一个实现类，<code>SqlSessionFactory</code>的体系结构如下图所示：</p>

<p><img alt src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yOTk0NjA0LWRhMmRiZDhmMWYyYWM4NDQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNDM2L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"></p>

<p> </p>

<p>此时，<code>SqlSessionFactory</code>创建完毕！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2019/12/08/Nginx%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/08/Nginx%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">Nginx的反向代理和负载均衡</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-08 19:01:57" itemprop="dateCreated datePublished" datetime="2019-12-08T19:01:57+08:00">2019-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 19:44:24" itemprop="dateModified" datetime="2020-05-01T19:44:24+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<h2>一、Nginx配置虚拟主机</h2>

<ul><li>什么是虚拟主机？ </li>
</ul><p>       虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供www服务，这样就可以实现一台主机对外提供多个web服务，每个虚拟主机之间是独立的，互不影响的。 </p>

<p>     通过nginx可以实现虚拟主机的配置，nginx支持三种类型的虚拟主机配置，1、基于ip的虚拟主机， 2、基于域名的虚拟主机 3、基于端口的虚拟主机。</p>

<h3><strong>1.1  基于ip的虚拟主机配置</strong></h3>

<p>      Linux操作系统允许添加IP别名，IP别名就是在一块物理网卡上绑定多个lP地址。这样就能够在使用单一网卡的同一个服务器上运行多个基于IP的虚拟主机。</p>

<p>一台nginx服务器绑定两个ip：192.168.101.3、192.168.101.103   </p>

<p>访问不同的ip请求不同的html目录，即：</p>

<p style="margin-left:0cm;">访问http://192.168.101.3将访问“html3”目录下的html网页</p>

<p>访问http://192.168.101.103将访问“html103”目录下的html网页</p>

<p><strong>1.1.1 创建html文件夹</strong></p>

<p>将原来nginx的html目录拷贝两个目录 “html3”和“html103”，为了方便测试需要修改每个目录下的index.html内容使之个性化。</p>

<p><strong>1.1.2 绑定多ip：</strong></p>

<p style="margin-left:0cm;">1、将/etc/sysconfig/network-scripts/ifcfg-eth0文件复制一份，命名为ifcfg-eth0:1</p>

<p style="margin-left:0cm;">修改其中内容：</p>

<p style="margin-left:0cm;">DEVICE=eth0:1</p>

<p style="margin-left:0cm;">IPADDR=192.168.25.103</p>

<p style="margin-left:0cm;">其他项不用修改</p>

<p style="margin-left:0cm;">2、重启系统</p>

<p style="margin-left:0cm;"><strong>1.1.3 配置虚拟主机</strong></p>

<p style="margin-left:0cm;">修改/usr/local/nginx/conf/nginx.conf文件，添加两个虚拟主机，如下：</p>

<pre class="has">
<code class="language-bash">#user  nobody;
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;
    #配置虚拟主机192.168.101.3
    server {
    #监听的ip和端口，配置192.168.101.3:80
        listen       80;
    #虚拟主机名称这里配置ip地址
        server_name  192.168.101.3;
    #所有的请求都以/开始，所有的请求都可以匹配此location
        location / {
        #使用root指令指定虚拟主机目录即网页存放目录
        #比如访问http://ip/test.html将找到/usr/local/html3/test.html
        #比如访问http://ip/item/test.html将找到/usr/local/html3/item/test.html

            root   /usr/local/nginx/html3;
        #指定欢迎页面，按从左到右顺序查找
            index  index.html index.htm;
        }

    }
    #配置虚拟主机192.168.101.103
    server {
        listen       80;
        server_name  192.168.101.103;

        location / {
            root   /usr/local/nginx/html103;
            index  index.html index.htm;
        }

    }

}
</code></pre>

<h3>1.2 基于端口的虚拟主机 </h3>

<p style="margin-left:0cm;">nginx对外提供80和8080两个端口监听服务。</p>

<p style="margin-left:0cm;">请求80端口则请求html80目录下的html</p>

<p style="margin-left:0cm;">请求8080端口则请求html8080目录下的html</p>

<p style="margin-left:0cm;"><strong>1.2.1 创建html目录</strong></p>

<p style="margin-left:0cm;">将原来nginx的html目录拷贝两个目录 “html80”和“html8080”，为了方便测试需要修改每个目录下的index.html内容使之个性化。</p>

<p style="margin-left:0cm;"><strong>1.2.2 配置虚拟主机</strong></p>

<p style="margin-left:0cm;">修改/usr/local/nginx/conf/nginx.conf文件，添加两个虚拟主机，如下：</p>

<pre class="has">
<code class="language-bash">#user  nobody;
worker_processes  1;
events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;
    #配置虚拟主机
    server {
    #监听的ip和端口，配置80
        listen       80;
    #虚拟主机名称这里配置ip地址
        server_name  192.168.101.3;
    #所有的请求都以/开始，所有的请求都可以匹配此location
        location / {
        #使用root指令指定虚拟主机目录即网页存放目录
        #比如访问http://ip/test.html将找到/usr/local/html3/test.html
        #比如访问http://ip/item/test.html将找到/usr/local/html3/item/test.html

            root   /usr/local/nginx/html80;
        #指定欢迎页面，按从左到右顺序查找
            index  index.html index.htm;
        }

    }
    #配置虚拟主机
    server {
        listen       8080;
        server_name  192.168.101.3;

        location / {
            root   /usr/local/nginx/html8080;
            index  index.html index.htm;
        }

    }

}
</code></pre>

<h3>1.3 基于域名的虚拟主机</h3>

<p style="margin-left:0cm;">两个域名指向同一台nginx服务器，用户访问不同的域名显示不同的网页内容。</p>

<p style="margin-left:0cm;">两个域名是aaa.test.com和bbb.test.com</p>

<p style="margin-left:0cm;">nginx服务器使用虚拟机192.168.101.3</p>

<p style="margin-left:0cm;"><strong>1.3.1 创建html目录</strong></p>

<p style="margin-left:0cm;">在192.168.101.3上创建/usr/local/aaa_html，此目录为aaa.test.com域名访问的目录</p>

<p style="margin-left:0cm;">在192.168.101.3上创建/usr/local/bbb_html，此目录为bbb.test.com域名访问的目录</p>

<p style="margin-left:0cm;">目录中的内容使用nginx自带的html文件，将/usr/local/nginx/html中的内容拷贝分别拷贝到上边两个目录中，并且将aaa_html目录中的index.html内容改为：“Welcome to aaa nginx!”</p>

<p style="margin-left:0cm;">将bbb_html目录中的index.html内容改为“Welcome to bbb nginx!”</p>

<p style="margin-left:0cm;"><strong>1.3.2 配置虚拟主机</strong></p>

<p style="margin-left:0cm;">修改/usr/local/nginx/conf/nginx.conf文件，添加两个虚拟主机，如下： </p>

<pre class="has">
<code>#配置虚拟主机aaa.test.com 
server {
        #监听的ip和端口，配置本机ip和端口
        listen 192.168.101.3:80;        
        #虚拟主机名称是aaa.test.com，请求域名aaa.test.com的url将由此server配置解析
        server_name aaa.test.com;     
        #所有的请求都以/开始，所有的请求都可以匹配此location
        location / {
        #使用root指令指定虚拟主机目录即网页存放目录
        #比如访问http://ip/test.html将找到/usr/local/aaa_html/test.html
        #比如访问http://ip/item/test.html将找到/usr/local/aaa_html/item/test.html
                root /usr/local/aaa_html;    
                #指定欢迎页面，按从左到右顺序查找
                index index.html index.htm;    
        }
    }

#配置虚拟主机bbb.test.com
    server {
        listen 192.168.101.3:80;
        server_name bbb.test.com;
        location / {
                root /usr/local/bbb_html;
                index index.html index.htm;
        }
    }

</code></pre>

<p style="margin-left:0cm;"> </p>

<h2 style="margin-left:0cm;">二 、Nginx反向代理</h2>

<ol><li style="margin-left:0cm;">什么是反向代理？</li>
</ol><p style="margin-left:0cm;">      通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中由代理服务器向Internet上的web服务器发起请求，最终达到客户机上网的目的。</p>

<p style="margin-left:0cm;">      而反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>

<p style="margin-left:0cm;">两个tomcat服务通过nginx反向代理，本例子使用三台虚拟机进行测试，</p>

<p style="margin-left:0cm;">         nginx服务器：192.168.101.3</p>

<p style="margin-left:0cm;">         tomcat1服务器：192.168.101.5</p>

<p style="margin-left:0cm;">         tomcat2服务器：192.168.101.6</p>

<p style="margin-left:0cm;"><strong>Nginx反向代理配置</strong></p>

<p style="margin-left:0cm;">根据上边的需求在nginx.conf文件中配置反向代理，如下：</p>

<pre class="has">
<code>#配置一个代理即tomcat1服务器
upstream tomcat_server1 {
            server 192.168.101.5:8080;
        }
#配置一个代理即tomcat2服务器
    upstream tomcat_server2 {
            server 192.168.101.6:8080;
        }

#配置一个虚拟主机
    server {
        listen 80;
        server_name aaa.test.com;
        location / {
                #域名aaa.test.com的请求全部转发到tomcat_server1即tomcat1服务上
                proxy_pass http://tomcat_server1;
                #欢迎页面，按照从左到右的顺序查找页面
                index index.jsp index.html index.htm;
        }

    }

    server {
        listen 80;
        server_name bbb.test.com;

        location / {
                 #域名bbb.test.com的请求全部转发到tomcat_server2即tomcat2服务上
                  proxy_pass http://tomcat_server2;
                  index index.jsp index.html index.htm;
        }
    }
</code></pre>

<p style="margin-left:0cm;">如果在同一个域名下有多台服务器提供服务，此时需要nginx负载均衡。</p>

<h2 style="margin-left:0cm;">三、Nginx负载均衡</h2>

<ol><li>什么是负载均衡？</li>
</ol><p style="margin-left:0cm;">       负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p>

<p style="margin-left:0cm;">       负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>

<p style="margin-left:0cm;">nginx作为负载均衡服务器，用户请求先到达nginx，再由nginx根据负载配置将请求转发至 tomcat服务器。</p>

<p style="margin-left:0cm;">         nginx负载均衡服务器：192.168.101.3</p>

<p style="margin-left:0cm;">         tomcat1服务器：192.168.101.5</p>

<p style="margin-left:0cm;">         tomcat2服务器：192.168.101.6</p>

<p style="margin-left:0cm;"><strong>Nginx负载均衡配置</strong></p>

<p style="margin-left:0cm;">根据上边的需求在nginx.conf文件中配置负载均衡，如下：</p>

<pre class="has">
<code>upstream tomcat_server_pool{
        server 192.168.101.5:8080 weight=10;
        server 192.168.101.6:8080 weight=10;
        }

    server {
        listen 80;
        server_name aaa.test.com;
        location / {
                 proxy_pass http://tomcat_server_pool;
                 index index.jsp index.html index.htm;
        }
    }
</code></pre>

<pre class="has">
<code>节点说明：
在http节点里添加:

#定义负载均衡设备的 Ip及设备状态 
upstream myServer {   

    server 127.0.0.1:9090 down; 
    server 127.0.0.1:8080 weight=2; 
    server 127.0.0.1:6060; 
    server 127.0.0.1:7070 backup; 
}

在需要使用负载的Server节点下添加

proxy_pass http://myServer;

upstream 每个设备的状态:

down 表示单前的server暂时不参与负载 
weight  默认为1.weight越大，负载的权重就越大。 
max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 
fail_timeout:max_fails 次失败后，暂停的时间。 
backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。
</code></pre>

<p style="margin-left:0cm;">解决高可用的方案就是添加冗余。</p>

<p style="margin-left:0cm;"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2019/11/05/Java%E9%80%9A%E8%BF%87%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/05/Java%E9%80%9A%E8%BF%87%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">Java通过序列化实现深度复制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-05 23:29:04" itemprop="dateCreated datePublished" datetime="2019-11-05T23:29:04+08:00">2019-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 19:03:21" itemprop="dateModified" datetime="2020-05-01T19:03:21+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Java学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<pre class="has">
<code class="language-java">package beanCopy;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

public class SerializeTest {

    public static void main(String[] args) throws IOException, ClassNotFoundException {

        Son son=new Son("qwer", "15");
        List sons=new ArrayList&lt;Son&gt;();
        sons.add(son);
        Person p1=new Person("zs", "30",sons);

        ByteArrayOutputStream bos=new ByteArrayOutputStream();
        ObjectOutputStream oos=new ObjectOutputStream(bos);

        oos.writeObject(p1);

        ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois=new ObjectInputStream(bis);

        Person p2=(Person) ois.readObject();

        System.out.println(p1);
        System.out.println(p2);


    }

}


class Person implements Serializable{

    private String name;

    private String age;

    private List&lt;Son&gt; sons;


    /*@Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + ", sons=" + sons + "]";
    }*/



    public Person(String name, String age, List&lt;Son&gt; sons) {
        super();
        this.name = name;
        this.age = age;
        this.sons = sons;
    }



    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }



}


class Son implements Serializable{
    private String name;

    private String age;



    /*@Override
    public String toString() {
        return "Son [name=" + name + ", age=" + age + "]";
    }*/

    public Son(String name, String age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }


}</code></pre>

<p>输出</p>

<p><img alt class="has" height="74" src="https://img-blog.csdnimg.cn/20191105233038132.png" width="378"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2019/06/11/%EF%BC%88Linux%EF%BC%89%E8%BF%9C%E7%A8%8B%E6%8C%82%E8%BD%BD%E7%BD%91%E7%BB%9C%E7%A3%81%E7%9B%98%E8%AF%A6%E8%A7%A3---nfs%E5%85%B1%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/11/%EF%BC%88Linux%EF%BC%89%E8%BF%9C%E7%A8%8B%E6%8C%82%E8%BD%BD%E7%BD%91%E7%BB%9C%E7%A3%81%E7%9B%98%E8%AF%A6%E8%A7%A3---nfs%E5%85%B1%E4%BA%AB/" class="post-title-link" itemprop="url">（Linux）远程挂载网络磁盘详解---nfs共享</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-11 13:28:04" itemprop="dateCreated datePublished" datetime="2019-06-11T13:28:04+08:00">2019-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 19:15:31" itemprop="dateModified" datetime="2020-05-01T19:15:31+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<h1><strong>前言</strong></h1>

<hr><p>在Linux或Windows乃至其他的系统，我们经常会需要进行磁盘的挂载。通常从挂载的方式的上分为本地挂载和远程挂载。Linux的本地挂载就不介绍了，这篇文章介绍的是远程挂载网络磁盘。</p>

<hr><h1> </h1>

<h1><strong>远程挂载网络磁盘</strong></h1>

<hr><p>实际上，这个操作与使用nfs共享一个文件的方法是相同的。思路是服务端将一块磁盘空间本地挂载到一个目录，然后通过网络使用nfs将这个目录进行共享，客户端最后将服务端共享的目录挂载到自己本地的一个目录，这样就使客户端拥有了一块网络磁盘。</p>

<p>优点是:服务端的同一块磁盘可以挂载到不同的客户端，实现文件的共享；可以扩充客户端的存储空间。<br>
缺点是：依赖网络，当网络联通失败，客户端挂载的网络磁盘会无法使用。</p>

<p>做网络挂载，服务端与客户端网络要联通，最好是在同一局域网内，还要注意防火墙的设置。<br>
 </p>

<hr><h2><strong>NFS简介</strong></h2>

<ul><li>
    <p>Sun公司于1984年发布。</p>
    </li>
    <li>
    <p>NFS 是一种可分散式的网络文件系统。</p>
    </li>
    <li>
    <p>可以通过网络使不同的机器、不同的操作系统，能够分享资料，使客户端能通过网络访问并分享文件到位于服务端的磁盘中。</p>
    </li>
    <li>NFS在文件传送或信息传送过程中依赖于RPC协议。RPC负责负责信息的传输。</li>
</ul><hr><h2> </h2>

<h2><strong>服务端操作</strong></h2>

<hr><p>【1】安装NFS程序</p>

<p>yum -y install nfs*</p>

<p>rpcbind,在centos6以前自带的yum源中为portmap。<br>
使用yum安装nfs时会下载依赖，因此只要下载nfs即可，无需再下载rpcbind.</p>

<p>【2】查看是否安装了nfs与rpcbind</p>

<p>rpm -qa |grep nfs<br>
rpm -qa |grep rpcbind<br><img alt="è¿éåå¾çæè¿°" class="has" src="https://img-blog.csdn.net/20180915190249681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dYXzFfMTFfcmVhbA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>【3】创建共享的目录并共享</p>

<p>如要共享的目录已存在请跳过创建</p>

<p>&lt;1&gt;mkdir /mnt/nfs01</p>

<p>&lt;2&gt;vim /etc/exports<br>
/mnt/nfs01 10.10.10.0/24 (rw,no_root_squash,no_all_squash,sync)<br>
 </p>

<pre class="has">
<code class="language-bash">
配置


/mnt/nfs01      10.10.10.0/24    (rw,no_root_squash,no_all_squash,sync)

要共享的目录     要分享给的客户端   客户端对此共享目录的权限

----------


客户端指定


192.168.1.125           指定特定的的IP可以共享nfs目录

*                       指定所有网段及ip都可以共享nfs目录

192.168.1.0/24          指定子网中的所有主机都可以共享nfs目录

2018fs.wxyonghe.com     指定域名的主机可以共享nfs目录

----------


权限


rw                      可读可写     

ro                      只读(还与文件系统的rwx有关)

sync　　                 数据同步写入到内存与硬盘中

async                   数据先暂存于内存当中，不会直接写入硬盘

wdelay                  当有写操作，就会检查是否有相关的写操作，并在一起执行(默认设置)

no_wdelay               当有写操作就立即执行，通常要与sync配合使用

root_squash             当客户端登陆NFS的身份为root用户时，将客户端的root用户及所属组都映射为匿名用户或用户组（默认设置） 

no_root_squash　　       使客户端可以使用root身份及权限来操作共享的目录

all_squash              无论客户端登陆NFS的身份为何，都将映射为匿名用户

no_all_squash           无论客户端登陆NFS的身份为何，都将映射为root用户（默认设置）

anonuid                 将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户

anongid                 将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户

secure                  使客户端只能从小于1024的tcp/ip端口连接服务端(默认设置)

insecure                允许客户端从大于1024的tcp/ip端口连接服务端

subtree                 当共享的目录是一个子目录，服务端会检查其父目录的权限(默认设置)

no_subtree              当共享的目录是一个子目录，服务端不检查其父目录的权限
</code></pre>

<p>【4】启动nfs,rpcbind,并设为开机自启</p>

<p>(centos7)<br>
systemctl start nfs<br>
systemctl start rpcbind<br>
systemctl enable nfs<br>
systemclt enable rpcbind</p>

<p>(centos6)<br>
service nfs start<br>
service rpcbind start</p>

<p>【5】查看是否共享成功</p>

<p>showmount -e localhost<br><img alt="è¿éåå¾çæè¿°" class="has" src="https://img-blog.csdn.net/2018091520415162?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dYXzFfMTFfcmVhbA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>可看到共享的目录及客户端，即为成功</p>

<hr><p> </p>

<h2><strong>客户端操作</strong></h2>

<hr><p>【1】安装NFS程序</p>

<p>yum -y install nfs*</p>

<p>【2】启动nfs</p>

<p>(centos7)<br>
systemctl start nfs<br>
systemctl start rpcbind<br>
systemctl enable nfs<br>
systemctl enable rpcbind</p>

<p>(centos6)<br>
service nfs start<br>
service rpcbind start<br>
chkconfig nfs on<br>
chkconfig rpcbind on</p>

<p>【3】创建挂载目录</p>

<p>mkdir /data/nfsone</p>

<p>【4】查看是否共享成功</p>

<p>showmount -e nfs服务端IP</p>

<p>showmount -e 10.10.20.212<br><img alt="è¿éåå¾çæè¿°" class="has" src="https://img-blog.csdn.net/20180915205422918?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dYXzFfMTFfcmVhbA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>【5】网络挂载</p>

<p>mount -t nfs -o nolock 服务端IP:共享目录绝对路径 本地挂载目录<br>
mount -t nfs -o nolock 10.10.20.212:/mnt/nfs01 /data/nfsone</p>

<p>centos7的nfs默认使用的是nfs4,所以mount -t 无需指定nfs4也可以</p>

<p>【6】查看是否成功</p>

<p>df -Th<br><img alt="è¿éåå¾çæè¿°" class="has" src="https://img-blog.csdn.net/20180915211531532?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dYXzFfMTFfcmVhbA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>【7】卸载网络磁盘</p>

<p>与卸载本地挂载相同</p>

<p>umount /data/nfsone<br>
或<br>
umount 10.10.20.212:/mnt/nfs01</p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yyguy123.github.io/2019/03/19/Java%E5%AF%BC%E5%87%BACSV%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="yyguy123">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyguy123的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/19/Java%E5%AF%BC%E5%87%BACSV%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Java导出CSV格式文件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-19 18:52:31" itemprop="dateCreated datePublished" datetime="2019-03-19T18:52:31+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 19:17:33" itemprop="dateModified" datetime="2020-05-01T19:17:33+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Java学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<p>导出csv格式文件的本质是导出以逗号为分隔的文本数据</p>

<pre class="has">
<code>import java.io.BufferedWriter;  
import java.io.File;  
import java.io.FileInputStream;  
import java.io.FileNotFoundException;  
import java.io.FileOutputStream;  
import java.io.IOException;  
import java.io.InputStream;  
import java.io.OutputStream;  
import java.io.OutputStreamWriter;  
import java.net.URLEncoder;  
import java.util.ArrayList;  
import java.util.Iterator;  
import java.util.LinkedHashMap;  
import java.util.List;  
import java.util.Map;  

import javax.servlet.http.HttpServletResponse;  

import com.alibaba.druid.util.StringUtils;



/** 
 * 文件操作 
 */  
public class CSVUtils {  


    /**
    * 功能说明：获取UTF-8编码文本文件开头的BOM签名。
    * BOM(Byte Order Mark)，是UTF编码方案里用于标识编码的标准标记。例：接收者收到以EF BB BF开头的字节流，就知道是UTF-8编码。
    * @return UTF-8编码文本文件开头的BOM签名
    */
    public static String getBOM() {

         byte b[] = {(byte)0xEF, (byte)0xBB, (byte)0xBF};
         return new String(b);
    }


  /** 
   * 生成CVS文件
   * @param exportData 
   *       源数据List 
   * @param map 
   *       csv文件的列表头map 
   * @param outPutPath 
   *       文件路径 
   * @param fileName 
   *       文件名称 
   * @return 
      */  
    @SuppressWarnings("rawtypes")  
    public static File createCSVFile(List exportData, LinkedHashMap map, String outPutPath,  
                   String fileName) {  

    File csvFile = null;  
    BufferedWriter csvFileOutputStream = null;  
    try {  
      File file = new File(outPutPath);  
      if (!file.exists()) {  
        file.mkdirs();  
      }  
      //定义文件名格式并创建  
      csvFile =new File(outPutPath+fileName+".csv");
      file.createNewFile();  
      // UTF-8使正确读取分隔符","  
      //如果生产文件乱码，windows下用gbk，linux用UTF-8
      csvFileOutputStream = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(  
        csvFile), "UTF-8"), 1024);  

      //写入前段字节流，防止乱码
      csvFileOutputStream.write(getBOM());
      // 写入文件头部
      for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator.hasNext();) {  
        java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator.next();  
        csvFileOutputStream.write((String) propertyEntry.getValue() != null ? (String) propertyEntry.getValue() : "" );  
        if (propertyIterator.hasNext()) {  
          csvFileOutputStream.write(",");  
        }  
      }  
      csvFileOutputStream.newLine();  
      // 写入文件内容  
      for (Iterator iterator = exportData.iterator(); iterator.hasNext();) {  
          Object row = (Object) iterator.next();
        for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator  
          .hasNext();) {  
          java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator  
            .next();  
          String str=row!=null?((String)((Map)row).get( propertyEntry.getKey())):"";

          if(StringUtils.isEmpty(str)){
              str="";
          }else{
              str=str.replaceAll("\"","\"\"");
              if(str.indexOf(",")&gt;=0){
                  str="\""+str+"\"";
              }
          }
          csvFileOutputStream.write(str);  
          if (propertyIterator.hasNext()) {  
            csvFileOutputStream.write(",");  
          }  
        }  
        if (iterator.hasNext()) {  
          csvFileOutputStream.newLine();  
        }  
      }  
      csvFileOutputStream.flush();  
    } catch (Exception e) {  
      e.printStackTrace();  
    } finally {  
      try {  
        csvFileOutputStream.close();  
      } catch (IOException e) {  
        e.printStackTrace();  
      }  
    }  
    return csvFile;  
  }  

  /**
   *     生成并下载csv文件
   * @param response
   * @param exportData
   * @param map
   * @param outPutPath
   * @param fileName
   * @throws IOException
      */
    @SuppressWarnings("rawtypes")
    public static void exportDataFile(HttpServletResponse response,List exportData, LinkedHashMap map, String outPutPath,String fileName) throws IOException{
      File csvFile = null;  
        BufferedWriter csvFileOutputStream = null;  
        try {  
          File file = new File(outPutPath);  
          if (!file.exists()) {  
            file.mkdirs();  
          }  
          //定义文件名格式并创建  
          csvFile =new File(outPutPath+fileName+".csv");
          if(csvFile.exists()){
             csvFile.delete(); 
          }
          csvFile.createNewFile();  
          // UTF-8使正确读取分隔符","  
          //如果生产文件乱码，windows下用gbk，linux用UTF-8
          csvFileOutputStream = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(csvFile), "UTF-8"), 1024);  
          //写入前段字节流，防止乱码
          csvFileOutputStream.write(getBOM());
          // 写入文件头部  
          for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator.hasNext();) {  
            java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator.next();  
            csvFileOutputStream.write((String) propertyEntry.getValue() != null ? (String) propertyEntry.getValue() : "" );  
            if (propertyIterator.hasNext()) {  
              csvFileOutputStream.write(",");  
            }  
          }  
          csvFileOutputStream.newLine();  
          // 写入文件内容  
          for (Iterator iterator = exportData.iterator(); iterator.hasNext();) {  
            Object row = (Object) iterator.next();  
            for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator  
              .hasNext();) {  
              java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator  
                .next();  
              String str=row!=null?((String)((Map)row).get( propertyEntry.getKey())):"";
              if(StringUtils.isEmpty(str)){
                  str="";
              }else{
                  str=str.replaceAll("\"","\"\"");
                  if(str.indexOf(",")&gt;=0){
                      str="\""+str+"\"";
                  }
              }
              csvFileOutputStream.write(str);  
              if (propertyIterator.hasNext()) {  
                csvFileOutputStream.write(",");  
              }  
            }  
            if (iterator.hasNext()) {  
              csvFileOutputStream.newLine();  
            }  
          }  
          csvFileOutputStream.flush();  
        } catch (Exception e) {  
          e.printStackTrace();  
        } finally {  
          try {  
            csvFileOutputStream.close();  
          } catch (IOException e) {  
            e.printStackTrace();  
          }  
        }  




        InputStream in = null;  
        try {  
          in = new FileInputStream(outPutPath+fileName+".csv");  
          int len = 0;  
          byte[] buffer = new byte[1024];  

          OutputStream out = response.getOutputStream(); 
          response.reset(); 

          response.setContentType("application/csv;charset=UTF-8");  
          response.setHeader("Content-Disposition","attachment; filename=" + URLEncoder.encode(fileName+".csv", "UTF-8"));  
          response.setCharacterEncoding("UTF-8"); 
          while ((len = in.read(buffer)) &gt; 0) {  
            out.write(new byte[] { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF });  
            out.write(buffer, 0, len);  
          }
          out.close();
        } catch (FileNotFoundException e) {  
        } finally {  
          if (in != null) {  
            try {  
              in.close();  
            } catch (Exception e) {  
              throw new RuntimeException(e);  
            }  
          }  
        }


  }

  /** 
   * 删除该目录filePath下的所有文件 
   * @param filePath 
   *      文件目录路径 
      */  
    public static void deleteFiles(String filePath) {  

    File file = new File(filePath);  
    if (file.exists()) {  
      File[] files = file.listFiles();  
      for (int i = 0; i &lt; files.length; i++) {  
        if (files[i].isFile()) {  
          files[i].delete();  
        }  
      }  
    }  
  }  

  /** 
   * 删除单个文件 
   * @param filePath 
   *     文件目录路径 
   * @param fileName 
   *     文件名称 
      */  
    public static void deleteFile(String filePath, String fileName) {  

    File file = new File(filePath);  
    if (file.exists()) {  
      File[] files = file.listFiles();  
      for (int i = 0; i &lt; files.length; i++) {  
        if (files[i].isFile()) {  
          if (files[i].getName().equals(fileName)) {  
            files[i].delete();  
            return;  
          }  
        }  
      }  
    }  
  }  

  /** 
   * 测试数据 
   * @param args 
      */  
    @SuppressWarnings({ "rawtypes", "unchecked" })  
    public static void main(String[] args) {  

    List exportData = new ArrayList&lt;Map&gt;();  
    Map row1 = new LinkedHashMap&lt;String, String&gt;();  
    row1.put("1", "11");  
    row1.put("2", "12");  
    row1.put("3", "13");  
    row1.put("4", "14");  
    exportData.add(row1);  
    row1 = new LinkedHashMap&lt;String, String&gt;();  
    row1.put("1", "21");  
    row1.put("2", "22");  
    row1.put("3", "23");  
    row1.put("4", "24");  
    exportData.add(row1);  
    LinkedHashMap map = new LinkedHashMap();  

    //设置列名
    map.put("1", "第一列名称");  
    map.put("2", "第二列名称");  
    map.put("3", "第三列名称");  
    map.put("4", "第四列名称");  
    //这个文件上传到路径，可以配置在数据库从数据库读取，这样方便一些！
    String path = "E:/";  

   //文件名=生产的文件名称+时间戳
    String fileName = "文件导出";  
    File file = CSVUtils.createCSVFile(exportData, map, path, fileName);  
    String fileName2 = file.getName();  
    System.out.println("文件名称：" + fileName2);  
  }  
}</code></pre>

<p><img alt class="has" src="https://images2018.cnblogs.com/blog/1443172/201808/1443172-20180813231232388-1283590677.png"></p>

<p>转自<a href="https://www.cnblogs.com/hanfengyeqiao/p/9471694.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/hanfengyeqiao/p/9471694.html</a></p>

<p> </p>

<p>需要注意的是生成的csv其中的数字若过长，csv中查看没有问题，但是用excel打开数字就会变成科学计数法 </p>

<p>解决方法是在生成csv的时候,在数字的前面或后面加上"\t"制表符，再用excel打开问题解决！如 “1234567890\ t”,“\ t1213212312”</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yyguy123" src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">yyguy123</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yyguy123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yyguy123" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yyguy123@gmail.com" title="E-Mail → mailto:yyguy123@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yyguy123</span>
</div>
  
  <div>
      <span>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
